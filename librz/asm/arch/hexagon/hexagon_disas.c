// SPDX-FileCopyrightText: 2021 Rot127 <unisono@quyllur.org>
//
// SPDX-License-Identifier: LGPL-3.0-only

//========================================
// The following code is generated.
// Do not edit. Repository of code generator:
// https://github.com/rizinorg/rz-hexagon

#include <stdio.h>
#include <stdbool.h>
#include <rz_types.h>
#include <rz_util.h>
#include <rz_asm.h>
#include "hexagon.h"
#include "hexagon_insn.h"

extern ut32 constant_extender;

int hexagon_disasm_instruction(ut32 hi_u32, HexInsn *hi, ut32 addr) {
	char signed_imm[16] = "";
	// DUPLEXES
	if (((hi_u32 >> 14) & 0x3) == 0) {
		switch ((((hi_u32 >> 29) & 0xF) << 1) | ((hi_u32 >> 13) & 1)) {
		case 0x0:
			if ((hi_u32 & 0xf000f000) == 0x0) {
				// 0000IIIISSSSDDDDEE00iiiissssdddd | RD = memw(RS+#II) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f000) == 0x1000) {
				// 0000IIIISSSSDDDDEE01iiiissssdddd | RD = memw(RS+#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f000) == 0x10001000) {
				// 0001IIIISSSSDDDDEE01iiiissssdddd | RD = memub(RS+#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x1:
			if ((hi_u32 & 0xf000ffff) == 0x3f00) {
				// 0000iiiissssddddEE11111100000000 | Rd = memw(Rs+#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003f00) {
				// 0001iiiissssddddEE11111100000000 | Rd = memub(Rs+#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3fc0) {
				// 0000iiiissssddddEE11111111000000 | Rd = memw(Rs+#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003fc0) {
				// 0001iiiissssddddEE11111111000000 | Rd = memub(Rs+#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3fc5) {
				// 0000iiiissssddddEE11111111000101 | Rd = memw(Rs+#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003fc5) {
				// 0001iiiissssddddEE11111111000101 | Rd = memub(Rs+#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3fc7) {
				// 0000iiiissssddddEE11111111000111 | Rd = memw(Rs+#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003fc7) {
				// 0001iiiissssddddEE11111111000111 | Rd = memub(Rs+#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3fc4) {
				// 0000iiiissssddddEE11111111000100 | Rd = memw(Rs+#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003fc4) {
				// 0001iiiissssddddEE11111111000100 | Rd = memub(Rs+#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3fc6) {
				// 0000iiiissssddddEE11111111000110 | Rd = memw(Rs+#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003fc6) {
				// 0001iiiissssddddEE11111111000110 | Rd = memub(Rs+#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0x3000) {
				// 0000IIIISSSSDDDDEE110iiissssdddd | RD = memw(RS+#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0x10003000) {
				// 0001IIIISSSSDDDDEE110iiissssdddd | RD = memub(RS+#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0x3e00) {
				// 0000IIIIssssDDDDEE111110iiiiiddd | RD = memw(Rs+#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 3;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0x10003e00) {
				// 0001IIIIssssDDDDEE111110iiiiiddd | RD = memub(Rs+#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 3;
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0x2000) {
				// 0000IIIISSSSDDDDEE100iiissssdddd | RD = memw(RS+#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0x10002000) {
				// 0001IIIISSSSDDDDEE100iiissssdddd | RD = memub(RS+#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0x3c00) {
				// 0000IIIIssssDDDDEE11110iiiiidddd | RD = memw(Rs+#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0x10003c00) {
				// 0001IIIIssssDDDDEE11110iiiiidddd | RD = memub(Rs+#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0x2800) {
				// 0000IIIISSSSDDDDEE101iiissssdddd | RD = memw(RS+#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0x10002800) {
				// 0001IIIISSSSDDDDEE101iiissssdddd | RD = memub(RS+#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3f40) {
				// 0000iiiissssddddEE11111101000000 | Rd = memw(Rs+#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003f40) {
				// 0001iiiissssddddEE11111101000000 | Rd = memub(Rs+#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3f45) {
				// 0000iiiissssddddEE11111101000101 | Rd = memw(Rs+#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003f45) {
				// 0001iiiissssddddEE11111101000101 | Rd = memub(Rs+#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3f47) {
				// 0000iiiissssddddEE11111101000111 | Rd = memw(Rs+#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003f47) {
				// 0001iiiissssddddEE11111101000111 | Rd = memub(Rs+#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3f44) {
				// 0000iiiissssddddEE11111101000100 | Rd = memw(Rs+#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003f44) {
				// 0001iiiissssddddEE11111101000100 | Rd = memub(Rs+#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x3f46) {
				// 0000iiiissssddddEE11111101000110 | Rd = memw(Rs+#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ffff) == 0x10003f46) {
				// 0001iiiissssddddEE11111101000110 | Rd = memub(Rs+#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x2:
			if ((hi_u32 & 0xffffffff) == 0x3f001f00) {
				// 0011111100000000EE01111100000000 | deallocframe ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; deallocframe %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001f00) {
				// 00110iiissssddddEE01111100000000 | Rd = memb(Rs+#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001f00) {
				// 00111110iiiiidddEE01111100000000 | Rdd = memd(r29+#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001f00) {
				// 00100iiissssddddEE01111100000000 | Rd = memh(Rs+#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001f00) {
				// 0011110iiiiiddddEE01111100000000 | Rd = memw(r29+#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001f00) {
				// 00101iiissssddddEE01111100000000 | Rd = memuh(Rs+#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001fc0) {
				// 0011111100000000EE01111111000000 | deallocframe ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001fc0) {
				// 00110iiissssddddEE01111111000000 | Rd = memb(Rs+#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001fc0) {
				// 00111110iiiiidddEE01111111000000 | Rdd = memd(r29+#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001fc0) {
				// 00100iiissssddddEE01111111000000 | Rd = memh(Rs+#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001fc0) {
				// 0011110iiiiiddddEE01111111000000 | Rd = memw(r29+#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001fc0) {
				// 00101iiissssddddEE01111111000000 | Rd = memuh(Rs+#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401fc0) {
				// 0011111101000000EE01111111000000 | dealloc_return ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f451fc0) {
				// 0011111101000101EE01111111000000 | if (!p0) dealloc_return ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f471fc0) {
				// 0011111101000111EE01111111000000 | if (!p0.new) dealloc_return:nt ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441fc0) {
				// 0011111101000100EE01111111000000 | if (p0) dealloc_return ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f461fc0) {
				// 0011111101000110EE01111111000000 | if (p0.new) dealloc_return:nt ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001fc5) {
				// 0011111100000000EE01111111000101 | deallocframe ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001fc5) {
				// 00110iiissssddddEE01111111000101 | Rd = memb(Rs+#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001fc5) {
				// 00111110iiiiidddEE01111111000101 | Rdd = memd(r29+#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001fc5) {
				// 00100iiissssddddEE01111111000101 | Rd = memh(Rs+#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001fc5) {
				// 0011110iiiiiddddEE01111111000101 | Rd = memw(r29+#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001fc5) {
				// 00101iiissssddddEE01111111000101 | Rd = memuh(Rs+#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401fc5) {
				// 0011111101000000EE01111111000101 | dealloc_return ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f451fc5) {
				// 0011111101000101EE01111111000101 | if (!p0) dealloc_return ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f471fc5) {
				// 0011111101000111EE01111111000101 | if (!p0.new) dealloc_return:nt ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441fc5) {
				// 0011111101000100EE01111111000101 | if (p0) dealloc_return ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f461fc5) {
				// 0011111101000110EE01111111000101 | if (p0.new) dealloc_return:nt ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001fc7) {
				// 0011111100000000EE01111111000111 | deallocframe ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001fc7) {
				// 00110iiissssddddEE01111111000111 | Rd = memb(Rs+#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001fc7) {
				// 00111110iiiiidddEE01111111000111 | Rdd = memd(r29+#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001fc7) {
				// 00100iiissssddddEE01111111000111 | Rd = memh(Rs+#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001fc7) {
				// 0011110iiiiiddddEE01111111000111 | Rd = memw(r29+#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001fc7) {
				// 00101iiissssddddEE01111111000111 | Rd = memuh(Rs+#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401fc7) {
				// 0011111101000000EE01111111000111 | dealloc_return ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f451fc7) {
				// 0011111101000101EE01111111000111 | if (!p0) dealloc_return ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f471fc7) {
				// 0011111101000111EE01111111000111 | if (!p0.new) dealloc_return:nt ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441fc7) {
				// 0011111101000100EE01111111000111 | if (p0) dealloc_return ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f461fc7) {
				// 0011111101000110EE01111111000111 | if (p0.new) dealloc_return:nt ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001fc4) {
				// 0011111100000000EE01111111000100 | deallocframe ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001fc4) {
				// 00110iiissssddddEE01111111000100 | Rd = memb(Rs+#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001fc4) {
				// 00111110iiiiidddEE01111111000100 | Rdd = memd(r29+#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001fc4) {
				// 00100iiissssddddEE01111111000100 | Rd = memh(Rs+#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001fc4) {
				// 0011110iiiiiddddEE01111111000100 | Rd = memw(r29+#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001fc4) {
				// 00101iiissssddddEE01111111000100 | Rd = memuh(Rs+#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401fc4) {
				// 0011111101000000EE01111111000100 | dealloc_return ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f451fc4) {
				// 0011111101000101EE01111111000100 | if (!p0) dealloc_return ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f471fc4) {
				// 0011111101000111EE01111111000100 | if (!p0.new) dealloc_return:nt ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441fc4) {
				// 0011111101000100EE01111111000100 | if (p0) dealloc_return ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f461fc4) {
				// 0011111101000110EE01111111000100 | if (p0.new) dealloc_return:nt ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001fc6) {
				// 0011111100000000EE01111111000110 | deallocframe ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001fc6) {
				// 00110iiissssddddEE01111111000110 | Rd = memb(Rs+#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001fc6) {
				// 00111110iiiiidddEE01111111000110 | Rdd = memd(r29+#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001fc6) {
				// 00100iiissssddddEE01111111000110 | Rd = memh(Rs+#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001fc6) {
				// 0011110iiiiiddddEE01111111000110 | Rd = memw(r29+#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001fc6) {
				// 00101iiissssddddEE01111111000110 | Rd = memuh(Rs+#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401fc6) {
				// 0011111101000000EE01111111000110 | dealloc_return ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f451fc6) {
				// 0011111101000101EE01111111000110 | if (!p0) dealloc_return ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f471fc6) {
				// 0011111101000111EE01111111000110 | if (!p0.new) dealloc_return:nt ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441fc6) {
				// 0011111101000100EE01111111000110 | if (p0) dealloc_return ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f461fc6) {
				// 0011111101000110EE01111111000110 | if (p0.new) dealloc_return:nt ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x30001000) {
				// 00110IIISSSSDDDDEE010iiissssdddd | RD = memb(RS+#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x20001000) {
				// 00100IIISSSSDDDDEE010iiissssdddd | RD = memh(RS+#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x28001000) {
				// 00101IIISSSSDDDDEE010iiissssdddd | RD = memuh(RS+#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x30001e00) {
				// 00110IIIssssDDDDEE011110iiiiiddd | RD = memb(Rs+#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 3;
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x3e001e00) {
				// 00111110IIIIIDDDEE011110iiiiiddd | RDD = memd(r29+#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20001e00) {
				// 00100IIIssssDDDDEE011110iiiiiddd | RD = memh(Rs+#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 3;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0x3c001e00) {
				// 0011110IIIIIDDDDEE011110iiiiiddd | RD = memw(r29+#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x28001e00) {
				// 00101IIIssssDDDDEE011110iiiiiddd | RD = memuh(Rs+#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 3;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x20000000) {
				// 00100IIISSSSDDDDEE000iiissssdddd | RD = memh(RS+#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0x30001c00) {
				// 00110IIIssssDDDDEE01110iiiiidddd | RD = memb(Rs+#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0x20001c00) {
				// 00100IIIssssDDDDEE01110iiiiidddd | RD = memh(Rs+#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe00) == 0x3c001c00) {
				// 0011110IIIIIDDDDEE01110iiiiidddd | RD = memw(r29+#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0x28001c00) {
				// 00101IIIssssDDDDEE01110iiiiidddd | RD = memuh(Rs+#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x20000800) {
				// 00100IIISSSSDDDDEE001iiissssdddd | RD = memh(RS+#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x28000800) {
				// 00101IIISSSSDDDDEE001iiissssdddd | RD = memuh(RS+#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001f40) {
				// 0011111100000000EE01111101000000 | deallocframe ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001f40) {
				// 00110iiissssddddEE01111101000000 | Rd = memb(Rs+#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001f40) {
				// 00111110iiiiidddEE01111101000000 | Rdd = memd(r29+#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001f40) {
				// 00100iiissssddddEE01111101000000 | Rd = memh(Rs+#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001f40) {
				// 0011110iiiiiddddEE01111101000000 | Rd = memw(r29+#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001f40) {
				// 00101iiissssddddEE01111101000000 | Rd = memuh(Rs+#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401f40) {
				// 0011111101000000EE01111101000000 | dealloc_return ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001f45) {
				// 0011111100000000EE01111101000101 | deallocframe ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001f45) {
				// 00110iiissssddddEE01111101000101 | Rd = memb(Rs+#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001f45) {
				// 00111110iiiiidddEE01111101000101 | Rdd = memd(r29+#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001f45) {
				// 00100iiissssddddEE01111101000101 | Rd = memh(Rs+#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001f45) {
				// 0011110iiiiiddddEE01111101000101 | Rd = memw(r29+#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001f45) {
				// 00101iiissssddddEE01111101000101 | Rd = memuh(Rs+#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401f45) {
				// 0011111101000000EE01111101000101 | dealloc_return ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f451f45) {
				// 0011111101000101EE01111101000101 | if (!p0) dealloc_return ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441f45) {
				// 0011111101000100EE01111101000101 | if (p0) dealloc_return ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001f47) {
				// 0011111100000000EE01111101000111 | deallocframe ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001f47) {
				// 00110iiissssddddEE01111101000111 | Rd = memb(Rs+#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001f47) {
				// 00111110iiiiidddEE01111101000111 | Rdd = memd(r29+#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001f47) {
				// 00100iiissssddddEE01111101000111 | Rd = memh(Rs+#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001f47) {
				// 0011110iiiiiddddEE01111101000111 | Rd = memw(r29+#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001f47) {
				// 00101iiissssddddEE01111101000111 | Rd = memuh(Rs+#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401f47) {
				// 0011111101000000EE01111101000111 | dealloc_return ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f451f47) {
				// 0011111101000101EE01111101000111 | if (!p0) dealloc_return ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f471f47) {
				// 0011111101000111EE01111101000111 | if (!p0.new) dealloc_return:nt ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441f47) {
				// 0011111101000100EE01111101000111 | if (p0) dealloc_return ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f461f47) {
				// 0011111101000110EE01111101000111 | if (p0.new) dealloc_return:nt ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001f44) {
				// 0011111100000000EE01111101000100 | deallocframe ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001f44) {
				// 00110iiissssddddEE01111101000100 | Rd = memb(Rs+#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001f44) {
				// 00111110iiiiidddEE01111101000100 | Rdd = memd(r29+#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001f44) {
				// 00100iiissssddddEE01111101000100 | Rd = memh(Rs+#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001f44) {
				// 0011110iiiiiddddEE01111101000100 | Rd = memw(r29+#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001f44) {
				// 00101iiissssddddEE01111101000100 | Rd = memuh(Rs+#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401f44) {
				// 0011111101000000EE01111101000100 | dealloc_return ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441f44) {
				// 0011111101000100EE01111101000100 | if (p0) dealloc_return ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f001f46) {
				// 0011111100000000EE01111101000110 | deallocframe ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s deallocframe ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x30001f46) {
				// 00110iiissssddddEE01111101000110 | Rd = memb(Rs+#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x3e001f46) {
				// 00111110iiiiidddEE01111101000110 | Rdd = memd(r29+#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x20001f46) {
				// 00100iiissssddddEE01111101000110 | Rd = memh(Rs+#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ffff) == 0x3c001f46) {
				// 0011110iiiiiddddEE01111101000110 | Rd = memw(r29+#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x28001f46) {
				// 00101iiissssddddEE01111101000110 | Rd = memuh(Rs+#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f401f46) {
				// 0011111101000000EE01111101000110 | dealloc_return ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s dealloc_return ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f451f46) {
				// 0011111101000101EE01111101000110 | if (!p0) dealloc_return ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f441f46) {
				// 0011111101000100EE01111101000110 | if (p0) dealloc_return ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffffff) == 0x3f461f46) {
				// 0011111101000110EE01111101000110 | if (p0.new) dealloc_return:nt ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 0;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x3:
			if ((hi_u32 & 0xf800ff00) == 0x20003800) {
				// 00100iiiiiiiXXXXEE111000ssssxxxx | RX = add(RXin,#Ii) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RX16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // RX16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x38003800) {
				// 00111000SSSSXXXXEE111000ssssxxxx | RX = add(RXin,RS) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RX16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // RX16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003800) {
				// 001011iiiiiiddddEE111000ssssxxxx | Rd = add(r29,#Ii) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x32003800) {
				// 00110010SSSSddddEE111000ssssxxxx | Rd = and(RS,#1) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x33003800) {
				// 00110011SSSSddddEE111000ssssxxxx | Rd = add(RS,#n1) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x31003800) {
				// 00110001SSSSddddEE111000ssssxxxx | Rd = add(RS,#1) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003800) {
				// 001010iiiiiiddddEE111000ssssxxxx | Rd = #Ii ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x35003800) {
				// 00110101SSSSddddEE111000ssssxxxx | Rd = sxtb(RS) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x34003800) {
				// 00110100SSSSddddEE111000ssssxxxx | Rd = sxth(RS) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003800) {
				// 00110000SSSSddddEE111000ssssxxxx | Rd = RS ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x37003800) {
				// 00110111SSSSddddEE111000ssssxxxx | Rd = and(RS,#255) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x36003800) {
				// 00110110SSSSddddEE111000ssssxxxx | Rd = zxth(RS) ; Rx = add(Rxin,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_ADDRX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rx16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rx16in
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = add(%sin,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fc00) == 0x20002c00) {
				// 00100IIIIIIIxxxxEE1011iiiiiidddd | Rx = add(Rxin,#II) ; Rd = add(r29,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_ADDSP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x3f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = add(R29,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fc00) == 0x2c002c00) {
				// 001011IIIIIIDDDDEE1011iiiiiidddd | RD = add(r29,#II) ; Rd = add(r29,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_ADDSP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = add(R29,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fc00) == 0x28002c00) {
				// 001010IIIIIIDDDDEE1011iiiiiidddd | RD = #II ; Rd = add(r29,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_ADDSP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = add(R29,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20003200) {
				// 00100iiiiiiixxxxEE110010ssssdddd | Rx = add(Rxin,#Ii) ; Rd = and(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_AND1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = and(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003200) {
				// 001011iiiiiiDDDDEE110010ssssdddd | RD = add(r29,#Ii) ; Rd = and(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_AND1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = and(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x32003200) {
				// 00110010SSSSDDDDEE110010ssssdddd | RD = and(RS,#1) ; Rd = and(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_AND1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = and(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x31003200) {
				// 00110001SSSSDDDDEE110010ssssdddd | RD = add(RS,#1) ; Rd = and(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_AND1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = and(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003200) {
				// 001010iiiiiiDDDDEE110010ssssdddd | RD = #Ii ; Rd = and(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_AND1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = and(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003200) {
				// 00110000SSSSDDDDEE110010ssssdddd | RD = RS ; Rd = and(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_AND1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = and(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fff0) == 0x20003a70) {
				// 00100iiiiiiixxxxEE1110100111dddd | Rx = add(Rxin,#Ii) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x38003a70) {
				// 00111000ssssxxxxEE1110100111dddd | Rx = add(Rxin,Rs) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x2c003a70) {
				// 001011iiiiiiDDDDEE1110100111dddd | RD = add(r29,#Ii) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x32003a70) {
				// 00110010ssssDDDDEE1110100111dddd | RD = and(Rs,#1) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a703a70) {
				// 001110100111DDDDEE1110100111dddd | if (!p0) RD = #0 ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a503a70) {
				// 001110100101DDDDEE1110100111dddd | if (!p0.new) RD = #0 ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a603a70) {
				// 001110100110DDDDEE1110100111dddd | if (p0) RD = #0 ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a403a70) {
				// 001110100100DDDDEE1110100111dddd | if (p0.new) RD = #0 ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfff0) == 0x39003a70) {
				// 00111001ssss00iiEE1110100111dddd | p0 = cmp.eq(Rs,#Ii) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x33003a70) {
				// 00110011ssssDDDDEE1110100111dddd | RD = add(Rs,#n1) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x31003a70) {
				// 00110001ssssDDDDEE1110100111dddd | RD = add(Rs,#1) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x28003a70) {
				// 001010iiiiiiDDDDEE1110100111dddd | RD = #Ii ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a003a70) {
				// 001110100000DDDDEE1110100111dddd | RD = #n1 ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x35003a70) {
				// 00110101ssssDDDDEE1110100111dddd | RD = sxtb(Rs) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x34003a70) {
				// 00110100ssssDDDDEE1110100111dddd | RD = sxth(Rs) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x30003a70) {
				// 00110000ssssDDDDEE1110100111dddd | RD = Rs ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = %s ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x37003a70) {
				// 00110111ssssDDDDEE1110100111dddd | RD = and(Rs,#255) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x36003a70) {
				// 00110110ssssDDDDEE1110100111dddd | RD = zxth(Rs) ; if (!p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_CLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (!P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fff0) == 0x20003a50) {
				// 00100iiiiiiixxxxEE1110100101dddd | Rx = add(Rxin,#Ii) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x38003a50) {
				// 00111000ssssxxxxEE1110100101dddd | Rx = add(Rxin,Rs) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x2c003a50) {
				// 001011iiiiiiDDDDEE1110100101dddd | RD = add(r29,#Ii) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x32003a50) {
				// 00110010ssssDDDDEE1110100101dddd | RD = and(Rs,#1) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a503a50) {
				// 001110100101DDDDEE1110100101dddd | if (!p0.new) RD = #0 ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a403a50) {
				// 001110100100DDDDEE1110100101dddd | if (p0.new) RD = #0 ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfff0) == 0x39003a50) {
				// 00111001ssss00iiEE1110100101dddd | p0 = cmp.eq(Rs,#Ii) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x33003a50) {
				// 00110011ssssDDDDEE1110100101dddd | RD = add(Rs,#n1) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x31003a50) {
				// 00110001ssssDDDDEE1110100101dddd | RD = add(Rs,#1) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x28003a50) {
				// 001010iiiiiiDDDDEE1110100101dddd | RD = #Ii ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a003a50) {
				// 001110100000DDDDEE1110100101dddd | RD = #n1 ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x35003a50) {
				// 00110101ssssDDDDEE1110100101dddd | RD = sxtb(Rs) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x34003a50) {
				// 00110100ssssDDDDEE1110100101dddd | RD = sxth(Rs) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x30003a50) {
				// 00110000ssssDDDDEE1110100101dddd | RD = Rs ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = %s ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x37003a50) {
				// 00110111ssssDDDDEE1110100101dddd | RD = and(Rs,#255) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x36003a50) {
				// 00110110ssssDDDDEE1110100101dddd | RD = zxth(Rs) ; if (!p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_CLRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (!P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fff0) == 0x20003a60) {
				// 00100iiiiiiixxxxEE1110100110dddd | Rx = add(Rxin,#Ii) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x38003a60) {
				// 00111000ssssxxxxEE1110100110dddd | Rx = add(Rxin,Rs) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x2c003a60) {
				// 001011iiiiiiDDDDEE1110100110dddd | RD = add(r29,#Ii) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x32003a60) {
				// 00110010ssssDDDDEE1110100110dddd | RD = and(Rs,#1) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a503a60) {
				// 001110100101DDDDEE1110100110dddd | if (!p0.new) RD = #0 ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a603a60) {
				// 001110100110DDDDEE1110100110dddd | if (p0) RD = #0 ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a403a60) {
				// 001110100100DDDDEE1110100110dddd | if (p0.new) RD = #0 ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfff0) == 0x39003a60) {
				// 00111001ssss00iiEE1110100110dddd | p0 = cmp.eq(Rs,#Ii) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x33003a60) {
				// 00110011ssssDDDDEE1110100110dddd | RD = add(Rs,#n1) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x31003a60) {
				// 00110001ssssDDDDEE1110100110dddd | RD = add(Rs,#1) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x28003a60) {
				// 001010iiiiiiDDDDEE1110100110dddd | RD = #Ii ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a003a60) {
				// 001110100000DDDDEE1110100110dddd | RD = #n1 ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x35003a60) {
				// 00110101ssssDDDDEE1110100110dddd | RD = sxtb(Rs) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x34003a60) {
				// 00110100ssssDDDDEE1110100110dddd | RD = sxth(Rs) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x30003a60) {
				// 00110000ssssDDDDEE1110100110dddd | RD = Rs ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = %s ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x37003a60) {
				// 00110111ssssDDDDEE1110100110dddd | RD = and(Rs,#255) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x36003a60) {
				// 00110110ssssDDDDEE1110100110dddd | RD = zxth(Rs) ; if (p0) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_CLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (P0) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fff0) == 0x20003a40) {
				// 00100iiiiiiixxxxEE1110100100dddd | Rx = add(Rxin,#Ii) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x38003a40) {
				// 00111000ssssxxxxEE1110100100dddd | Rx = add(Rxin,Rs) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x2c003a40) {
				// 001011iiiiiiDDDDEE1110100100dddd | RD = add(r29,#Ii) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x32003a40) {
				// 00110010ssssDDDDEE1110100100dddd | RD = and(Rs,#1) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a403a40) {
				// 001110100100DDDDEE1110100100dddd | if (p0.new) RD = #0 ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfff0) == 0x39003a40) {
				// 00111001ssss00iiEE1110100100dddd | p0 = cmp.eq(Rs,#Ii) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x33003a40) {
				// 00110011ssssDDDDEE1110100100dddd | RD = add(Rs,#n1) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x31003a40) {
				// 00110001ssssDDDDEE1110100100dddd | RD = add(Rs,#1) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x28003a40) {
				// 001010iiiiiiDDDDEE1110100100dddd | RD = #Ii ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a003a40) {
				// 001110100000DDDDEE1110100100dddd | RD = #n1 ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x35003a40) {
				// 00110101ssssDDDDEE1110100100dddd | RD = sxtb(Rs) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x34003a40) {
				// 00110100ssssDDDDEE1110100100dddd | RD = sxth(Rs) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x30003a40) {
				// 00110000ssssDDDDEE1110100100dddd | RD = Rs ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = %s ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x37003a40) {
				// 00110111ssssDDDDEE1110100100dddd | RD = and(Rs,#255) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x36003a40) {
				// 00110110ssssDDDDEE1110100100dddd | RD = zxth(Rs) ; if (p0.new) Rd = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_CLRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (P0.new) %s = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff0c) == 0x20003900) {
				// 00100IIIIIIIxxxxEE111001ssss00ii | Rx = add(Rxin,#II) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x38003900) {
				// 00111000SSSSxxxxEE111001ssss00ii | Rx = add(Rxin,RS) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff0c) == 0x2c003900) {
				// 001011IIIIIIddddEE111001ssss00ii | Rd = add(r29,#II) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x32003900) {
				// 00110010SSSSddddEE111001ssss00ii | Rd = and(RS,#1) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff0c) == 0x39003900) {
				// 00111001SSSS00IIEE111001ssss00ii | p0 = cmp.eq(RS,#II) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x33003900) {
				// 00110011SSSSddddEE111001ssss00ii | Rd = add(RS,#n1) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x31003900) {
				// 00110001SSSSddddEE111001ssss00ii | Rd = add(RS,#1) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff0c) == 0x28003900) {
				// 001010IIIIIIddddEE111001ssss00ii | Rd = #II ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x35003900) {
				// 00110101SSSSddddEE111001ssss00ii | Rd = sxtb(RS) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x34003900) {
				// 00110100SSSSddddEE111001ssss00ii | Rd = sxth(RS) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x30003900) {
				// 00110000SSSSddddEE111001ssss00ii | Rd = RS ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = %s ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x37003900) {
				// 00110111SSSSddddEE111001ssss00ii | Rd = and(RS,#255) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff0c) == 0x36003900) {
				// 00110110SSSSddddEE111001ssss00ii | Rd = zxth(RS) ; p0 = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; P0 = cmp.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff98) == 0x20003c00) {
				// 00100IIIIIIIxxxxEE1111000ii00ddd | Rx = add(Rxin,#II) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x38003c00) {
				// 00111000ssssxxxxEE1111000ii00ddd | Rx = add(Rxin,Rs) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff98) == 0x2c003c00) {
				// 001011IIIIIIDDDDEE1111000ii00ddd | RD = add(r29,#II) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x32003c00) {
				// 00110010ssssDDDDEE1111000ii00ddd | RD = and(Rs,#1) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a703c00) {
				// 001110100111DDDDEE1111000ii00ddd | if (!p0) RD = #0 ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a503c00) {
				// 001110100101DDDDEE1111000ii00ddd | if (!p0.new) RD = #0 ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a603c00) {
				// 001110100110DDDDEE1111000ii00ddd | if (p0) RD = #0 ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a403c00) {
				// 001110100100DDDDEE1111000ii00ddd | if (p0.new) RD = #0 ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff98) == 0x39003c00) {
				// 00111001ssss00IIEE1111000ii00ddd | p0 = cmp.eq(Rs,#II) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c003c00) {
				// 001111000II00DDDEE1111000ii00ddd | RDD = combine(#0,#II) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x33003c00) {
				// 00110011ssssDDDDEE1111000ii00ddd | RD = add(Rs,#n1) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x31003c00) {
				// 00110001ssssDDDDEE1111000ii00ddd | RD = add(Rs,#1) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff98) == 0x28003c00) {
				// 001010IIIIIIDDDDEE1111000ii00ddd | RD = #II ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a003c00) {
				// 001110100000DDDDEE1111000ii00ddd | RD = #n1 ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = #-1 ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x35003c00) {
				// 00110101ssssDDDDEE1111000ii00ddd | RD = sxtb(Rs) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x34003c00) {
				// 00110100ssssDDDDEE1111000ii00ddd | RD = sxth(Rs) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x30003c00) {
				// 00110000ssssDDDDEE1111000ii00ddd | RD = Rs ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = %s ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x37003c00) {
				// 00110111ssssDDDDEE1111000ii00ddd | RD = and(Rs,#255) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x36003c00) {
				// 00110110ssssDDDDEE1111000ii00ddd | RD = zxth(Rs) ; Rdd = combine(#0,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_COMBINE0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = combine(#0,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff98) == 0x20003c08) {
				// 00100IIIIIIIxxxxEE1111000ii01ddd | Rx = add(Rxin,#II) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x38003c08) {
				// 00111000ssssxxxxEE1111000ii01ddd | Rx = add(Rxin,Rs) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff98) == 0x2c003c08) {
				// 001011IIIIIIDDDDEE1111000ii01ddd | RD = add(r29,#II) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x32003c08) {
				// 00110010ssssDDDDEE1111000ii01ddd | RD = and(Rs,#1) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a703c08) {
				// 001110100111DDDDEE1111000ii01ddd | if (!p0) RD = #0 ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a503c08) {
				// 001110100101DDDDEE1111000ii01ddd | if (!p0.new) RD = #0 ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a603c08) {
				// 001110100110DDDDEE1111000ii01ddd | if (p0) RD = #0 ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a403c08) {
				// 001110100100DDDDEE1111000ii01ddd | if (p0.new) RD = #0 ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff98) == 0x39003c08) {
				// 00111001ssss00IIEE1111000ii01ddd | p0 = cmp.eq(Rs,#II) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c003c08) {
				// 001111000II00DDDEE1111000ii01ddd | RDD = combine(#0,#II) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c083c08) {
				// 001111000II01DDDEE1111000ii01ddd | RDD = combine(#1,#II) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x33003c08) {
				// 00110011ssssDDDDEE1111000ii01ddd | RD = add(Rs,#n1) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x31003c08) {
				// 00110001ssssDDDDEE1111000ii01ddd | RD = add(Rs,#1) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff98) == 0x28003c08) {
				// 001010IIIIIIDDDDEE1111000ii01ddd | RD = #II ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a003c08) {
				// 001110100000DDDDEE1111000ii01ddd | RD = #n1 ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = #-1 ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x35003c08) {
				// 00110101ssssDDDDEE1111000ii01ddd | RD = sxtb(Rs) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x34003c08) {
				// 00110100ssssDDDDEE1111000ii01ddd | RD = sxth(Rs) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x30003c08) {
				// 00110000ssssDDDDEE1111000ii01ddd | RD = Rs ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = %s ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x37003c08) {
				// 00110111ssssDDDDEE1111000ii01ddd | RD = and(Rs,#255) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x36003c08) {
				// 00110110ssssDDDDEE1111000ii01ddd | RD = zxth(Rs) ; Rdd = combine(#1,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_COMBINE1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = combine(#1,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff98) == 0x20003c10) {
				// 00100IIIIIIIxxxxEE1111000ii10ddd | Rx = add(Rxin,#II) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x38003c10) {
				// 00111000ssssxxxxEE1111000ii10ddd | Rx = add(Rxin,Rs) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff98) == 0x2c003c10) {
				// 001011IIIIIIDDDDEE1111000ii10ddd | RD = add(r29,#II) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x32003c10) {
				// 00110010ssssDDDDEE1111000ii10ddd | RD = and(Rs,#1) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a703c10) {
				// 001110100111DDDDEE1111000ii10ddd | if (!p0) RD = #0 ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a503c10) {
				// 001110100101DDDDEE1111000ii10ddd | if (!p0.new) RD = #0 ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a603c10) {
				// 001110100110DDDDEE1111000ii10ddd | if (p0) RD = #0 ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a403c10) {
				// 001110100100DDDDEE1111000ii10ddd | if (p0.new) RD = #0 ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff98) == 0x39003c10) {
				// 00111001ssss00IIEE1111000ii10ddd | p0 = cmp.eq(Rs,#II) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c003c10) {
				// 001111000II00DDDEE1111000ii10ddd | RDD = combine(#0,#II) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c083c10) {
				// 001111000II01DDDEE1111000ii10ddd | RDD = combine(#1,#II) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c103c10) {
				// 001111000II10DDDEE1111000ii10ddd | RDD = combine(#2,#II) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x33003c10) {
				// 00110011ssssDDDDEE1111000ii10ddd | RD = add(Rs,#n1) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x31003c10) {
				// 00110001ssssDDDDEE1111000ii10ddd | RD = add(Rs,#1) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff98) == 0x28003c10) {
				// 001010IIIIIIDDDDEE1111000ii10ddd | RD = #II ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a003c10) {
				// 001110100000DDDDEE1111000ii10ddd | RD = #n1 ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = #-1 ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x35003c10) {
				// 00110101ssssDDDDEE1111000ii10ddd | RD = sxtb(Rs) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x34003c10) {
				// 00110100ssssDDDDEE1111000ii10ddd | RD = sxth(Rs) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x30003c10) {
				// 00110000ssssDDDDEE1111000ii10ddd | RD = Rs ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = %s ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x37003c10) {
				// 00110111ssssDDDDEE1111000ii10ddd | RD = and(Rs,#255) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x36003c10) {
				// 00110110ssssDDDDEE1111000ii10ddd | RD = zxth(Rs) ; Rdd = combine(#2,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_COMBINE2I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = combine(#2,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff98) == 0x20003c18) {
				// 00100IIIIIIIxxxxEE1111000ii11ddd | Rx = add(Rxin,#II) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x38003c18) {
				// 00111000ssssxxxxEE1111000ii11ddd | Rx = add(Rxin,Rs) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff98) == 0x2c003c18) {
				// 001011IIIIIIDDDDEE1111000ii11ddd | RD = add(r29,#II) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x32003c18) {
				// 00110010ssssDDDDEE1111000ii11ddd | RD = and(Rs,#1) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a703c18) {
				// 001110100111DDDDEE1111000ii11ddd | if (!p0) RD = #0 ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a503c18) {
				// 001110100101DDDDEE1111000ii11ddd | if (!p0.new) RD = #0 ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a603c18) {
				// 001110100110DDDDEE1111000ii11ddd | if (p0) RD = #0 ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a403c18) {
				// 001110100100DDDDEE1111000ii11ddd | if (p0.new) RD = #0 ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff98) == 0x39003c18) {
				// 00111001ssss00IIEE1111000ii11ddd | p0 = cmp.eq(Rs,#II) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c003c18) {
				// 001111000II00DDDEE1111000ii11ddd | RDD = combine(#0,#II) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c083c18) {
				// 001111000II01DDDEE1111000ii11ddd | RDD = combine(#1,#II) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c103c18) {
				// 001111000II10DDDEE1111000ii11ddd | RDD = combine(#2,#II) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff98) == 0x3c183c18) {
				// 001111000II11DDDEE1111000ii11ddd | RDD = combine(#3,#II) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x33003c18) {
				// 00110011ssssDDDDEE1111000ii11ddd | RD = add(Rs,#n1) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x31003c18) {
				// 00110001ssssDDDDEE1111000ii11ddd | RD = add(Rs,#1) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff98) == 0x28003c18) {
				// 001010IIIIIIDDDDEE1111000ii11ddd | RD = #II ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff98) == 0x3a003c18) {
				// 001110100000DDDDEE1111000ii11ddd | RD = #n1 ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = #-1 ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x35003c18) {
				// 00110101ssssDDDDEE1111000ii11ddd | RD = sxtb(Rs) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x34003c18) {
				// 00110100ssssDDDDEE1111000ii11ddd | RD = sxth(Rs) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x30003c18) {
				// 00110000ssssDDDDEE1111000ii11ddd | RD = Rs ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = %s ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x37003c18) {
				// 00110111ssssDDDDEE1111000ii11ddd | RD = and(Rs,#255) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff98) == 0x36003c18) {
				// 00110110ssssDDDDEE1111000ii11ddd | RD = zxth(Rs) ; Rdd = combine(#3,#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_COMBINE3I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = combine(#3,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff08) == 0x20003d08) {
				// 00100iiiiiiixxxxEE111101ssss1ddd | Rx = add(Rxin,#Ii) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x38003d08) {
				// 00111000SSSSxxxxEE111101ssss1ddd | Rx = add(Rxin,RS) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff08) == 0x2c003d08) {
				// 001011iiiiiiDDDDEE111101ssss1ddd | RD = add(r29,#Ii) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x32003d08) {
				// 00110010SSSSDDDDEE111101ssss1ddd | RD = and(RS,#1) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a703d08) {
				// 001110100111DDDDEE111101ssss1ddd | if (!p0) RD = #0 ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a503d08) {
				// 001110100101DDDDEE111101ssss1ddd | if (!p0.new) RD = #0 ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a603d08) {
				// 001110100110DDDDEE111101ssss1ddd | if (p0) RD = #0 ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a403d08) {
				// 001110100100DDDDEE111101ssss1ddd | if (p0.new) RD = #0 ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff08) == 0x39003d08) {
				// 00111001SSSS00iiEE111101ssss1ddd | p0 = cmp.eq(RS,#Ii) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff08) == 0x3c003d08) {
				// 001111000ii00DDDEE111101ssss1ddd | RDD = combine(#0,#Ii) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff08) == 0x3c083d08) {
				// 001111000ii01DDDEE111101ssss1ddd | RDD = combine(#1,#Ii) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff08) == 0x3c103d08) {
				// 001111000ii10DDDEE111101ssss1ddd | RDD = combine(#2,#Ii) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff08) == 0x3c183d08) {
				// 001111000ii11DDDEE111101ssss1ddd | RDD = combine(#3,#Ii) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff08) == 0x3d083d08) {
				// 00111101SSSS1DDDEE111101ssss1ddd | RDD = combine(RS,#0) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff08) == 0x3d003d08) {
				// 00111101SSSS0DDDEE111101ssss1ddd | RDD = combine(#0,RS) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x33003d08) {
				// 00110011SSSSDDDDEE111101ssss1ddd | RD = add(RS,#n1) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x31003d08) {
				// 00110001SSSSDDDDEE111101ssss1ddd | RD = add(RS,#1) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff08) == 0x28003d08) {
				// 001010iiiiiiDDDDEE111101ssss1ddd | RD = #Ii ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a003d08) {
				// 001110100000DDDDEE111101ssss1ddd | RD = #n1 ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = #-1 ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x35003d08) {
				// 00110101SSSSDDDDEE111101ssss1ddd | RD = sxtb(RS) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x34003d08) {
				// 00110100SSSSDDDDEE111101ssss1ddd | RD = sxth(RS) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x30003d08) {
				// 00110000SSSSDDDDEE111101ssss1ddd | RD = RS ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x37003d08) {
				// 00110111SSSSDDDDEE111101ssss1ddd | RD = and(RS,#255) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x36003d08) {
				// 00110110SSSSDDDDEE111101ssss1ddd | RD = zxth(RS) ; Rdd = combine(Rs,#0)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_COMBINERZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = combine(%s,#0) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff08) == 0x20003d00) {
				// 00100iiiiiiixxxxEE111101ssss0ddd | Rx = add(Rxin,#Ii) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x38003d00) {
				// 00111000SSSSxxxxEE111101ssss0ddd | Rx = add(Rxin,RS) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff08) == 0x2c003d00) {
				// 001011iiiiiiDDDDEE111101ssss0ddd | RD = add(r29,#Ii) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x32003d00) {
				// 00110010SSSSDDDDEE111101ssss0ddd | RD = and(RS,#1) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a703d00) {
				// 001110100111DDDDEE111101ssss0ddd | if (!p0) RD = #0 ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a503d00) {
				// 001110100101DDDDEE111101ssss0ddd | if (!p0.new) RD = #0 ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a603d00) {
				// 001110100110DDDDEE111101ssss0ddd | if (p0) RD = #0 ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a403d00) {
				// 001110100100DDDDEE111101ssss0ddd | if (p0.new) RD = #0 ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff08) == 0x39003d00) {
				// 00111001SSSS00iiEE111101ssss0ddd | p0 = cmp.eq(RS,#Ii) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff08) == 0x3c003d00) {
				// 001111000ii00DDDEE111101ssss0ddd | RDD = combine(#0,#Ii) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff08) == 0x3c083d00) {
				// 001111000ii01DDDEE111101ssss0ddd | RDD = combine(#1,#Ii) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff08) == 0x3c103d00) {
				// 001111000ii10DDDEE111101ssss0ddd | RDD = combine(#2,#Ii) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff08) == 0x3c183d00) {
				// 001111000ii11DDDEE111101ssss0ddd | RDD = combine(#3,#Ii) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff08) == 0x3d003d00) {
				// 00111101SSSS0DDDEE111101ssss0ddd | RDD = combine(#0,RS) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x33003d00) {
				// 00110011SSSSDDDDEE111101ssss0ddd | RD = add(RS,#n1) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x31003d00) {
				// 00110001SSSSDDDDEE111101ssss0ddd | RD = add(RS,#1) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff08) == 0x28003d00) {
				// 001010iiiiiiDDDDEE111101ssss0ddd | RD = #Ii ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff08) == 0x3a003d00) {
				// 001110100000DDDDEE111101ssss0ddd | RD = #n1 ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = #-1 ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x35003d00) {
				// 00110101SSSSDDDDEE111101ssss0ddd | RD = sxtb(RS) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x34003d00) {
				// 00110100SSSSDDDDEE111101ssss0ddd | RD = sxth(RS) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x30003d00) {
				// 00110000SSSSDDDDEE111101ssss0ddd | RD = RS ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x37003d00) {
				// 00110111SSSSDDDDEE111101ssss0ddd | RD = and(RS,#255) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff08) == 0x36003d00) {
				// 00110110SSSSDDDDEE111101ssss0ddd | RD = zxth(RS) ; Rdd = combine(#0,Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_COMBINEZR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = combine(#0,%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20003300) {
				// 00100iiiiiiixxxxEE110011ssssdddd | Rx = add(Rxin,#Ii) ; Rd = add(Rs,#n1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_DEC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = add(%s,#-1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003300) {
				// 001011iiiiiiDDDDEE110011ssssdddd | RD = add(r29,#Ii) ; Rd = add(Rs,#n1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_DEC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = add(%s,#-1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x32003300) {
				// 00110010SSSSDDDDEE110011ssssdddd | RD = and(RS,#1) ; Rd = add(Rs,#n1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_DEC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = add(%s,#-1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x33003300) {
				// 00110011SSSSDDDDEE110011ssssdddd | RD = add(RS,#N1) ; Rd = add(Rs,#n1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_DEC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = add(%s,#-1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x31003300) {
				// 00110001SSSSDDDDEE110011ssssdddd | RD = add(RS,#1) ; Rd = add(Rs,#n1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_DEC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = add(%s,#-1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003300) {
				// 001010iiiiiiDDDDEE110011ssssdddd | RD = #Ii ; Rd = add(Rs,#n1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_DEC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = add(%s,#-1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003300) {
				// 00110000SSSSDDDDEE110011ssssdddd | RD = RS ; Rd = add(Rs,#n1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_DEC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = add(%s,#-1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20003100) {
				// 00100iiiiiiixxxxEE110001ssssdddd | Rx = add(Rxin,#Ii) ; Rd = add(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_INC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = add(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003100) {
				// 001011iiiiiiDDDDEE110001ssssdddd | RD = add(r29,#Ii) ; Rd = add(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_INC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = add(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x31003100) {
				// 00110001SSSSDDDDEE110001ssssdddd | RD = add(RS,#1) ; Rd = add(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_INC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = add(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003100) {
				// 001010iiiiiiDDDDEE110001ssssdddd | RD = #Ii ; Rd = add(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_INC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = add(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003100) {
				// 00110000SSSSDDDDEE110001ssssdddd | RD = RS ; Rd = add(Rs,#1)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_INC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = add(%s,#1) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fff0) == 0x20003a00) {
				// 00100iiiiiiixxxxEE1110100000dddd | Rx = add(Rxin,#Ii) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x38003a00) {
				// 00111000ssssxxxxEE1110100000dddd | Rx = add(Rxin,Rs) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x2c003a00) {
				// 001011iiiiiiDDDDEE1110100000dddd | RD = add(r29,#Ii) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x32003a00) {
				// 00110010ssssDDDDEE1110100000dddd | RD = and(Rs,#1) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfff0) == 0x39003a00) {
				// 00111001ssss00iiEE1110100000dddd | p0 = cmp.eq(Rs,#Ii) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x33003a00) {
				// 00110011ssssDDDDEE1110100000dddd | RD = add(Rs,#N1) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x31003a00) {
				// 00110001ssssDDDDEE1110100000dddd | RD = add(Rs,#1) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fff0) == 0x28003a00) {
				// 001010iiiiiiDDDDEE1110100000dddd | RD = #Ii ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fff0) == 0x3a003a00) {
				// 001110100000DDDDEE1110100000dddd | RD = #N1 ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x35003a00) {
				// 00110101ssssDDDDEE1110100000dddd | RD = sxtb(Rs) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x34003a00) {
				// 00110100ssssDDDDEE1110100000dddd | RD = sxth(Rs) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x30003a00) {
				// 00110000ssssDDDDEE1110100000dddd | RD = Rs ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = %s ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x37003a00) {
				// 00110111ssssDDDDEE1110100000dddd | RD = and(Rs,#255) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fff0) == 0x36003a00) {
				// 00110110ssssDDDDEE1110100000dddd | RD = zxth(Rs) ; Rd = #n1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_SETIN1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = #-1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20003500) {
				// 00100iiiiiiixxxxEE110101ssssdddd | Rx = add(Rxin,#Ii) ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003500) {
				// 001011iiiiiiDDDDEE110101ssssdddd | RD = add(r29,#Ii) ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x32003500) {
				// 00110010SSSSDDDDEE110101ssssdddd | RD = and(RS,#1) ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x33003500) {
				// 00110011SSSSDDDDEE110101ssssdddd | RD = add(RS,#n1) ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x31003500) {
				// 00110001SSSSDDDDEE110101ssssdddd | RD = add(RS,#1) ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003500) {
				// 001010iiiiiiDDDDEE110101ssssdddd | RD = #Ii ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x35003500) {
				// 00110101SSSSDDDDEE110101ssssdddd | RD = sxtb(RS) ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x34003500) {
				// 00110100SSSSDDDDEE110101ssssdddd | RD = sxth(RS) ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003500) {
				// 00110000SSSSDDDDEE110101ssssdddd | RD = RS ; Rd = sxtb(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20003400) {
				// 00100iiiiiiixxxxEE110100ssssdddd | Rx = add(Rxin,#Ii) ; Rd = sxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003400) {
				// 001011iiiiiiDDDDEE110100ssssdddd | RD = add(r29,#Ii) ; Rd = sxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x32003400) {
				// 00110010SSSSDDDDEE110100ssssdddd | RD = and(RS,#1) ; Rd = sxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x33003400) {
				// 00110011SSSSDDDDEE110100ssssdddd | RD = add(RS,#n1) ; Rd = sxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x31003400) {
				// 00110001SSSSDDDDEE110100ssssdddd | RD = add(RS,#1) ; Rd = sxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003400) {
				// 001010iiiiiiDDDDEE110100ssssdddd | RD = #Ii ; Rd = sxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x34003400) {
				// 00110100SSSSDDDDEE110100ssssdddd | RD = sxth(RS) ; Rd = sxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003400) {
				// 00110000SSSSDDDDEE110100ssssdddd | RD = RS ; Rd = sxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20003000) {
				// 00100iiiiiiixxxxEE110000ssssdddd | Rx = add(Rxin,#Ii) ; Rd = Rs
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_TFR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003000) {
				// 001011iiiiiiDDDDEE110000ssssdddd | RD = add(r29,#Ii) ; Rd = Rs
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_TFR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003000) {
				// 001010iiiiiiDDDDEE110000ssssdddd | RD = #Ii ; Rd = Rs
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_TFR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003000) {
				// 00110000SSSSDDDDEE110000ssssdddd | RD = RS ; Rd = Rs
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_TFR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20003700) {
				// 00100iiiiiiixxxxEE110111ssssdddd | Rx = add(Rxin,#Ii) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003700) {
				// 001011iiiiiiDDDDEE110111ssssdddd | RD = add(r29,#Ii) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x32003700) {
				// 00110010SSSSDDDDEE110111ssssdddd | RD = and(RS,#1) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x33003700) {
				// 00110011SSSSDDDDEE110111ssssdddd | RD = add(RS,#n1) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x31003700) {
				// 00110001SSSSDDDDEE110111ssssdddd | RD = add(RS,#1) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003700) {
				// 001010iiiiiiDDDDEE110111ssssdddd | RD = #Ii ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x35003700) {
				// 00110101SSSSDDDDEE110111ssssdddd | RD = sxtb(RS) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x34003700) {
				// 00110100SSSSDDDDEE110111ssssdddd | RD = sxth(RS) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003700) {
				// 00110000SSSSDDDDEE110111ssssdddd | RD = RS ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x37003700) {
				// 00110111SSSSDDDDEE110111ssssdddd | RD = and(RS,#255) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x36003700) {
				// 00110110SSSSDDDDEE110111ssssdddd | RD = zxth(RS) ; Rd = and(Rs,#255)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_ZXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = and(%s,#255) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x20003600) {
				// 00100iiiiiiixxxxEE110110ssssdddd | Rx = add(Rxin,#Ii) ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x2c003600) {
				// 001011iiiiiiDDDDEE110110ssssdddd | RD = add(r29,#Ii) ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x32003600) {
				// 00110010SSSSDDDDEE110110ssssdddd | RD = and(RS,#1) ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x33003600) {
				// 00110011SSSSDDDDEE110110ssssdddd | RD = add(RS,#n1) ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x31003600) {
				// 00110001SSSSDDDDEE110110ssssdddd | RD = add(RS,#1) ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x28003600) {
				// 001010iiiiiiDDDDEE110110ssssdddd | RD = #Ii ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x35003600) {
				// 00110101SSSSDDDDEE110110ssssdddd | RD = sxtb(RS) ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x34003600) {
				// 00110100SSSSDDDDEE110110ssssdddd | RD = sxth(RS) ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x30003600) {
				// 00110000SSSSDDDDEE110110ssssdddd | RD = RS ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x36003600) {
				// 00110110SSSSDDDDEE110110ssssdddd | RD = zxth(RS) ; Rd = zxth(Rs)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SA1_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x4:
			if ((hi_u32 & 0xf800f000) == 0x40000000) {
				// 01000IIIIIIIxxxxEE00iiiissssdddd | Rx = add(Rxin,#II) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x58000000) {
				// 01011000SSSSxxxxEE00iiiissssdddd | Rx = add(Rxin,RS) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f000) == 0x4c000000) {
				// 010011IIIIIIDDDDEE00iiiissssdddd | RD = add(r29,#II) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x52000000) {
				// 01010010SSSSDDDDEE00iiiissssdddd | RD = and(RS,#1) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a700000) {
				// 010110100111DDDDEE00iiiissssdddd | if (!p0) RD = #0 ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a500000) {
				// 010110100101DDDDEE00iiiissssdddd | if (!p0.new) RD = #0 ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a600000) {
				// 010110100110DDDDEE00iiiissssdddd | if (p0) RD = #0 ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a400000) {
				// 010110100100DDDDEE00iiiissssdddd | if (p0.new) RD = #0 ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cf000) == 0x59000000) {
				// 01011001SSSS00IIEE00iiiissssdddd | p0 = cmp.eq(RS,#II) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x5c000000) {
				// 010111000II00DDDEE00iiiissssdddd | RDD = combine(#0,#II) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x5c080000) {
				// 010111000II01DDDEE00iiiissssdddd | RDD = combine(#1,#II) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x5c100000) {
				// 010111000II10DDDEE00iiiissssdddd | RDD = combine(#2,#II) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x5c180000) {
				// 010111000II11DDDEE00iiiissssdddd | RDD = combine(#3,#II) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f000) == 0x5d080000) {
				// 01011101SSSS1DDDEE00iiiissssdddd | RDD = combine(RS,#0) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f000) == 0x5d000000) {
				// 01011101SSSS0DDDEE00iiiissssdddd | RDD = combine(#0,RS) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x53000000) {
				// 01010011SSSSDDDDEE00iiiissssdddd | RD = add(RS,#n1) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x51000000) {
				// 01010001SSSSDDDDEE00iiiissssdddd | RD = add(RS,#1) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f000) == 0x48000000) {
				// 010010IIIIIIDDDDEE00iiiissssdddd | RD = #II ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a000000) {
				// 010110100000DDDDEE00iiiissssdddd | RD = #n1 ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = #-1 ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x55000000) {
				// 01010101SSSSDDDDEE00iiiissssdddd | RD = sxtb(RS) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x54000000) {
				// 01010100SSSSDDDDEE00iiiissssdddd | RD = sxth(RS) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x50000000) {
				// 01010000SSSSDDDDEE00iiiissssdddd | RD = RS ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = %s ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x57000000) {
				// 01010111SSSSDDDDEE00iiiissssdddd | RD = and(RS,#255) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x56000000) {
				// 01010110SSSSDDDDEE00iiiissssdddd | RD = zxth(RS) ; Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL1_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = memw(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f000) == 0x40001000) {
				// 01000IIIIIIIxxxxEE01iiiissssdddd | Rx = add(Rxin,#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x58001000) {
				// 01011000SSSSxxxxEE01iiiissssdddd | Rx = add(Rxin,RS) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f000) == 0x4c001000) {
				// 010011IIIIIIDDDDEE01iiiissssdddd | RD = add(r29,#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x52001000) {
				// 01010010SSSSDDDDEE01iiiissssdddd | RD = and(RS,#1) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a701000) {
				// 010110100111DDDDEE01iiiissssdddd | if (!p0) RD = #0 ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a501000) {
				// 010110100101DDDDEE01iiiissssdddd | if (!p0.new) RD = #0 ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a601000) {
				// 010110100110DDDDEE01iiiissssdddd | if (p0) RD = #0 ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a401000) {
				// 010110100100DDDDEE01iiiissssdddd | if (p0.new) RD = #0 ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cf000) == 0x59001000) {
				// 01011001SSSS00IIEE01iiiissssdddd | p0 = cmp.eq(RS,#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x5c001000) {
				// 010111000II00DDDEE01iiiissssdddd | RDD = combine(#0,#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x5c081000) {
				// 010111000II01DDDEE01iiiissssdddd | RDD = combine(#1,#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x5c101000) {
				// 010111000II10DDDEE01iiiissssdddd | RDD = combine(#2,#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x5c181000) {
				// 010111000II11DDDEE01iiiissssdddd | RDD = combine(#3,#II) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f000) == 0x5d081000) {
				// 01011101SSSS1DDDEE01iiiissssdddd | RDD = combine(RS,#0) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f000) == 0x5d001000) {
				// 01011101SSSS0DDDEE01iiiissssdddd | RDD = combine(#0,RS) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x53001000) {
				// 01010011SSSSDDDDEE01iiiissssdddd | RD = add(RS,#n1) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x51001000) {
				// 01010001SSSSDDDDEE01iiiissssdddd | RD = add(RS,#1) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f000) == 0x48001000) {
				// 010010IIIIIIDDDDEE01iiiissssdddd | RD = #II ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x5a001000) {
				// 010110100000DDDDEE01iiiissssdddd | RD = #n1 ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = #-1 ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x55001000) {
				// 01010101SSSSDDDDEE01iiiissssdddd | RD = sxtb(RS) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x54001000) {
				// 01010100SSSSDDDDEE01iiiissssdddd | RD = sxth(RS) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x50001000) {
				// 01010000SSSSDDDDEE01iiiissssdddd | RD = RS ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = %s ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x57001000) {
				// 01010111SSSSDDDDEE01iiiissssdddd | RD = and(RS,#255) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x56001000) {
				// 01010110SSSSDDDDEE01iiiissssdddd | RD = zxth(RS) ; Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL1_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = memub(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x5:
			if ((hi_u32 & 0xf800ffff) == 0x40003f00) {
				// 01000iiiiiiixxxxEE11111100000000 | Rx = add(Rxin,#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003f00) {
				// 01011000ssssxxxxEE11111100000000 | Rx = add(Rxin,Rs) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003f00) {
				// 010011iiiiiiddddEE11111100000000 | Rd = add(r29,#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003f00) {
				// 01010010ssssddddEE11111100000000 | Rd = and(Rs,#1) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703f00) {
				// 010110100111ddddEE11111100000000 | if (!p0) Rd = #0 ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503f00) {
				// 010110100101ddddEE11111100000000 | if (!p0.new) Rd = #0 ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603f00) {
				// 010110100110ddddEE11111100000000 | if (p0) Rd = #0 ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403f00) {
				// 010110100100ddddEE11111100000000 | if (p0.new) Rd = #0 ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003f00) {
				// 01011001ssss00iiEE11111100000000 | p0 = cmp.eq(Rs,#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003f00) {
				// 010111000ii00dddEE11111100000000 | Rdd = combine(#0,#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083f00) {
				// 010111000ii01dddEE11111100000000 | Rdd = combine(#1,#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103f00) {
				// 010111000ii10dddEE11111100000000 | Rdd = combine(#2,#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183f00) {
				// 010111000ii11dddEE11111100000000 | Rdd = combine(#3,#Ii) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083f00) {
				// 01011101ssss1dddEE11111100000000 | Rdd = combine(Rs,#0) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003f00) {
				// 01011101ssss0dddEE11111100000000 | Rdd = combine(#0,Rs) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003f00) {
				// 01010011ssssddddEE11111100000000 | Rd = add(Rs,#n1) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003f00) {
				// 01010001ssssddddEE11111100000000 | Rd = add(Rs,#1) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003f00) {
				// 010010iiiiiiddddEE11111100000000 | Rd = #Ii ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003f00) {
				// 010110100000ddddEE11111100000000 | Rd = #n1 ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003f00) {
				// 01010101ssssddddEE11111100000000 | Rd = sxtb(Rs) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003f00) {
				// 01010100ssssddddEE11111100000000 | Rd = sxth(Rs) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003f00) {
				// 01010000ssssddddEE11111100000000 | Rd = Rs ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003f00) {
				// 01010111ssssddddEE11111100000000 | Rd = and(Rs,#255) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003f00) {
				// 01010110ssssddddEE11111100000000 | Rd = zxth(Rs) ; deallocframe
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; deallocframe %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003fc0) {
				// 01000iiiiiiixxxxEE11111111000000 | Rx = add(Rxin,#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003fc0) {
				// 01011000ssssxxxxEE11111111000000 | Rx = add(Rxin,Rs) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003fc0) {
				// 010011iiiiiiddddEE11111111000000 | Rd = add(r29,#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003fc0) {
				// 01010010ssssddddEE11111111000000 | Rd = and(Rs,#1) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703fc0) {
				// 010110100111ddddEE11111111000000 | if (!p0) Rd = #0 ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503fc0) {
				// 010110100101ddddEE11111111000000 | if (!p0.new) Rd = #0 ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603fc0) {
				// 010110100110ddddEE11111111000000 | if (p0) Rd = #0 ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403fc0) {
				// 010110100100ddddEE11111111000000 | if (p0.new) Rd = #0 ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003fc0) {
				// 01011001ssss00iiEE11111111000000 | p0 = cmp.eq(Rs,#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003fc0) {
				// 010111000ii00dddEE11111111000000 | Rdd = combine(#0,#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083fc0) {
				// 010111000ii01dddEE11111111000000 | Rdd = combine(#1,#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103fc0) {
				// 010111000ii10dddEE11111111000000 | Rdd = combine(#2,#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183fc0) {
				// 010111000ii11dddEE11111111000000 | Rdd = combine(#3,#Ii) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083fc0) {
				// 01011101ssss1dddEE11111111000000 | Rdd = combine(Rs,#0) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003fc0) {
				// 01011101ssss0dddEE11111111000000 | Rdd = combine(#0,Rs) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003fc0) {
				// 01010011ssssddddEE11111111000000 | Rd = add(Rs,#n1) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003fc0) {
				// 01010001ssssddddEE11111111000000 | Rd = add(Rs,#1) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003fc0) {
				// 010010iiiiiiddddEE11111111000000 | Rd = #Ii ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003fc0) {
				// 010110100000ddddEE11111111000000 | Rd = #n1 ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003fc0) {
				// 01010101ssssddddEE11111111000000 | Rd = sxtb(Rs) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003fc0) {
				// 01010100ssssddddEE11111111000000 | Rd = sxth(Rs) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003fc0) {
				// 01010000ssssddddEE11111111000000 | Rd = Rs ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003fc0) {
				// 01010111ssssddddEE11111111000000 | Rd = and(Rs,#255) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003fc0) {
				// 01010110ssssddddEE11111111000000 | Rd = zxth(Rs) ; jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_JUMPR31;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003fc5) {
				// 01000iiiiiiixxxxEE11111111000101 | Rx = add(Rxin,#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003fc5) {
				// 01011000ssssxxxxEE11111111000101 | Rx = add(Rxin,Rs) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003fc5) {
				// 010011iiiiiiddddEE11111111000101 | Rd = add(r29,#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003fc5) {
				// 01010010ssssddddEE11111111000101 | Rd = and(Rs,#1) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703fc5) {
				// 010110100111ddddEE11111111000101 | if (!p0) Rd = #0 ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503fc5) {
				// 010110100101ddddEE11111111000101 | if (!p0.new) Rd = #0 ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603fc5) {
				// 010110100110ddddEE11111111000101 | if (p0) Rd = #0 ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403fc5) {
				// 010110100100ddddEE11111111000101 | if (p0.new) Rd = #0 ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003fc5) {
				// 01011001ssss00iiEE11111111000101 | p0 = cmp.eq(Rs,#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003fc5) {
				// 010111000ii00dddEE11111111000101 | Rdd = combine(#0,#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083fc5) {
				// 010111000ii01dddEE11111111000101 | Rdd = combine(#1,#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103fc5) {
				// 010111000ii10dddEE11111111000101 | Rdd = combine(#2,#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183fc5) {
				// 010111000ii11dddEE11111111000101 | Rdd = combine(#3,#Ii) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083fc5) {
				// 01011101ssss1dddEE11111111000101 | Rdd = combine(Rs,#0) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003fc5) {
				// 01011101ssss0dddEE11111111000101 | Rdd = combine(#0,Rs) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003fc5) {
				// 01010011ssssddddEE11111111000101 | Rd = add(Rs,#n1) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003fc5) {
				// 01010001ssssddddEE11111111000101 | Rd = add(Rs,#1) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003fc5) {
				// 010010iiiiiiddddEE11111111000101 | Rd = #Ii ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003fc5) {
				// 010110100000ddddEE11111111000101 | Rd = #n1 ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003fc5) {
				// 01010101ssssddddEE11111111000101 | Rd = sxtb(Rs) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003fc5) {
				// 01010100ssssddddEE11111111000101 | Rd = sxth(Rs) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003fc5) {
				// 01010000ssssddddEE11111111000101 | Rd = Rs ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003fc5) {
				// 01010111ssssddddEE11111111000101 | Rd = and(Rs,#255) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003fc5) {
				// 01010110ssssddddEE11111111000101 | Rd = zxth(Rs) ; if (!p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_JUMPR31_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (!P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003fc7) {
				// 01000iiiiiiixxxxEE11111111000111 | Rx = add(Rxin,#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003fc7) {
				// 01011000ssssxxxxEE11111111000111 | Rx = add(Rxin,Rs) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003fc7) {
				// 010011iiiiiiddddEE11111111000111 | Rd = add(r29,#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003fc7) {
				// 01010010ssssddddEE11111111000111 | Rd = and(Rs,#1) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703fc7) {
				// 010110100111ddddEE11111111000111 | if (!p0) Rd = #0 ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503fc7) {
				// 010110100101ddddEE11111111000111 | if (!p0.new) Rd = #0 ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603fc7) {
				// 010110100110ddddEE11111111000111 | if (p0) Rd = #0 ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403fc7) {
				// 010110100100ddddEE11111111000111 | if (p0.new) Rd = #0 ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003fc7) {
				// 01011001ssss00iiEE11111111000111 | p0 = cmp.eq(Rs,#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003fc7) {
				// 010111000ii00dddEE11111111000111 | Rdd = combine(#0,#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083fc7) {
				// 010111000ii01dddEE11111111000111 | Rdd = combine(#1,#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103fc7) {
				// 010111000ii10dddEE11111111000111 | Rdd = combine(#2,#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183fc7) {
				// 010111000ii11dddEE11111111000111 | Rdd = combine(#3,#Ii) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083fc7) {
				// 01011101ssss1dddEE11111111000111 | Rdd = combine(Rs,#0) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003fc7) {
				// 01011101ssss0dddEE11111111000111 | Rdd = combine(#0,Rs) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003fc7) {
				// 01010011ssssddddEE11111111000111 | Rd = add(Rs,#n1) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003fc7) {
				// 01010001ssssddddEE11111111000111 | Rd = add(Rs,#1) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003fc7) {
				// 010010iiiiiiddddEE11111111000111 | Rd = #Ii ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003fc7) {
				// 010110100000ddddEE11111111000111 | Rd = #n1 ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003fc7) {
				// 01010101ssssddddEE11111111000111 | Rd = sxtb(Rs) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003fc7) {
				// 01010100ssssddddEE11111111000111 | Rd = sxth(Rs) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003fc7) {
				// 01010000ssssddddEE11111111000111 | Rd = Rs ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003fc7) {
				// 01010111ssssddddEE11111111000111 | Rd = and(Rs,#255) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003fc7) {
				// 01010110ssssddddEE11111111000111 | Rd = zxth(Rs) ; if (!p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_JUMPR31_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (!P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003fc4) {
				// 01000iiiiiiixxxxEE11111111000100 | Rx = add(Rxin,#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003fc4) {
				// 01011000ssssxxxxEE11111111000100 | Rx = add(Rxin,Rs) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003fc4) {
				// 010011iiiiiiddddEE11111111000100 | Rd = add(r29,#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003fc4) {
				// 01010010ssssddddEE11111111000100 | Rd = and(Rs,#1) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703fc4) {
				// 010110100111ddddEE11111111000100 | if (!p0) Rd = #0 ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503fc4) {
				// 010110100101ddddEE11111111000100 | if (!p0.new) Rd = #0 ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603fc4) {
				// 010110100110ddddEE11111111000100 | if (p0) Rd = #0 ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403fc4) {
				// 010110100100ddddEE11111111000100 | if (p0.new) Rd = #0 ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003fc4) {
				// 01011001ssss00iiEE11111111000100 | p0 = cmp.eq(Rs,#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003fc4) {
				// 010111000ii00dddEE11111111000100 | Rdd = combine(#0,#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083fc4) {
				// 010111000ii01dddEE11111111000100 | Rdd = combine(#1,#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103fc4) {
				// 010111000ii10dddEE11111111000100 | Rdd = combine(#2,#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183fc4) {
				// 010111000ii11dddEE11111111000100 | Rdd = combine(#3,#Ii) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083fc4) {
				// 01011101ssss1dddEE11111111000100 | Rdd = combine(Rs,#0) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003fc4) {
				// 01011101ssss0dddEE11111111000100 | Rdd = combine(#0,Rs) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003fc4) {
				// 01010011ssssddddEE11111111000100 | Rd = add(Rs,#n1) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003fc4) {
				// 01010001ssssddddEE11111111000100 | Rd = add(Rs,#1) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003fc4) {
				// 010010iiiiiiddddEE11111111000100 | Rd = #Ii ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003fc4) {
				// 010110100000ddddEE11111111000100 | Rd = #n1 ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003fc4) {
				// 01010101ssssddddEE11111111000100 | Rd = sxtb(Rs) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003fc4) {
				// 01010100ssssddddEE11111111000100 | Rd = sxth(Rs) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003fc4) {
				// 01010000ssssddddEE11111111000100 | Rd = Rs ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003fc4) {
				// 01010111ssssddddEE11111111000100 | Rd = and(Rs,#255) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003fc4) {
				// 01010110ssssddddEE11111111000100 | Rd = zxth(Rs) ; if (p0) jumpr r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_JUMPR31_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (P0) jumpr R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003fc6) {
				// 01000iiiiiiixxxxEE11111111000110 | Rx = add(Rxin,#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003fc6) {
				// 01011000ssssxxxxEE11111111000110 | Rx = add(Rxin,Rs) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003fc6) {
				// 010011iiiiiiddddEE11111111000110 | Rd = add(r29,#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003fc6) {
				// 01010010ssssddddEE11111111000110 | Rd = and(Rs,#1) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703fc6) {
				// 010110100111ddddEE11111111000110 | if (!p0) Rd = #0 ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503fc6) {
				// 010110100101ddddEE11111111000110 | if (!p0.new) Rd = #0 ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603fc6) {
				// 010110100110ddddEE11111111000110 | if (p0) Rd = #0 ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403fc6) {
				// 010110100100ddddEE11111111000110 | if (p0.new) Rd = #0 ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003fc6) {
				// 01011001ssss00iiEE11111111000110 | p0 = cmp.eq(Rs,#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003fc6) {
				// 010111000ii00dddEE11111111000110 | Rdd = combine(#0,#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083fc6) {
				// 010111000ii01dddEE11111111000110 | Rdd = combine(#1,#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103fc6) {
				// 010111000ii10dddEE11111111000110 | Rdd = combine(#2,#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183fc6) {
				// 010111000ii11dddEE11111111000110 | Rdd = combine(#3,#Ii) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083fc6) {
				// 01011101ssss1dddEE11111111000110 | Rdd = combine(Rs,#0) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003fc6) {
				// 01011101ssss0dddEE11111111000110 | Rdd = combine(#0,Rs) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003fc6) {
				// 01010011ssssddddEE11111111000110 | Rd = add(Rs,#n1) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003fc6) {
				// 01010001ssssddddEE11111111000110 | Rd = add(Rs,#1) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003fc6) {
				// 010010iiiiiiddddEE11111111000110 | Rd = #Ii ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003fc6) {
				// 010110100000ddddEE11111111000110 | Rd = #n1 ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003fc6) {
				// 01010101ssssddddEE11111111000110 | Rd = sxtb(Rs) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003fc6) {
				// 01010100ssssddddEE11111111000110 | Rd = sxth(Rs) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003fc6) {
				// 01010000ssssddddEE11111111000110 | Rd = Rs ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003fc6) {
				// 01010111ssssddddEE11111111000110 | Rd = and(Rs,#255) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003fc6) {
				// 01010110ssssddddEE11111111000110 | Rd = zxth(Rs) ; if (p0.new) jumpr:nt r31
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_JUMPR31_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (P0.new) jumpr:nt R31 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x40003000) {
				// 01000IIIIIIIxxxxEE110iiissssdddd | Rx = add(Rxin,#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x58003000) {
				// 01011000SSSSxxxxEE110iiissssdddd | Rx = add(Rxin,RS) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f800) == 0x4c003000) {
				// 010011IIIIIIDDDDEE110iiissssdddd | RD = add(r29,#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x52003000) {
				// 01010010SSSSDDDDEE110iiissssdddd | RD = and(RS,#1) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a703000) {
				// 010110100111DDDDEE110iiissssdddd | if (!p0) RD = #0 ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a503000) {
				// 010110100101DDDDEE110iiissssdddd | if (!p0.new) RD = #0 ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a603000) {
				// 010110100110DDDDEE110iiissssdddd | if (p0) RD = #0 ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a403000) {
				// 010110100100DDDDEE110iiissssdddd | if (p0.new) RD = #0 ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cf800) == 0x59003000) {
				// 01011001SSSS00IIEE110iiissssdddd | p0 = cmp.eq(RS,#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c003000) {
				// 010111000II00DDDEE110iiissssdddd | RDD = combine(#0,#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c083000) {
				// 010111000II01DDDEE110iiissssdddd | RDD = combine(#1,#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c103000) {
				// 010111000II10DDDEE110iiissssdddd | RDD = combine(#2,#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c183000) {
				// 010111000II11DDDEE110iiissssdddd | RDD = combine(#3,#II) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f800) == 0x5d083000) {
				// 01011101SSSS1DDDEE110iiissssdddd | RDD = combine(RS,#0) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f800) == 0x5d003000) {
				// 01011101SSSS0DDDEE110iiissssdddd | RDD = combine(#0,RS) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x53003000) {
				// 01010011SSSSDDDDEE110iiissssdddd | RD = add(RS,#n1) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x51003000) {
				// 01010001SSSSDDDDEE110iiissssdddd | RD = add(RS,#1) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f800) == 0x48003000) {
				// 010010IIIIIIDDDDEE110iiissssdddd | RD = #II ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a003000) {
				// 010110100000DDDDEE110iiissssdddd | RD = #n1 ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = #-1 ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x55003000) {
				// 01010101SSSSDDDDEE110iiissssdddd | RD = sxtb(RS) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x54003000) {
				// 01010100SSSSDDDDEE110iiissssdddd | RD = sxth(RS) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x50003000) {
				// 01010000SSSSDDDDEE110iiissssdddd | RD = RS ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = %s ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x57003000) {
				// 01010111SSSSDDDDEE110iiissssdddd | RD = and(RS,#255) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x56003000) {
				// 01010110SSSSDDDDEE110iiissssdddd | RD = zxth(RS) ; Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = memb(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x40003e00) {
				// 01000IIIIIIIxxxxEE111110iiiiiddd | Rx = add(Rxin,#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 3;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x58003e00) {
				// 01011000ssssxxxxEE111110iiiiiddd | Rx = add(Rxin,Rs) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 3;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x4c003e00) {
				// 010011IIIIIIDDDDEE111110iiiiiddd | RD = add(r29,#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x52003e00) {
				// 01010010ssssDDDDEE111110iiiiiddd | RD = and(Rs,#1) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x5a703e00) {
				// 010110100111DDDDEE111110iiiiiddd | if (!p0) RD = #0 ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x5a503e00) {
				// 010110100101DDDDEE111110iiiiiddd | if (!p0.new) RD = #0 ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x5a603e00) {
				// 010110100110DDDDEE111110iiiiiddd | if (p0) RD = #0 ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x5a403e00) {
				// 010110100100DDDDEE111110iiiiiddd | if (p0.new) RD = #0 ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff00) == 0x59003e00) {
				// 01011001ssss00IIEE111110iiiiiddd | p0 = cmp.eq(Rs,#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x5c003e00) {
				// 010111000II00DDDEE111110iiiiiddd | RDD = combine(#0,#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x5c083e00) {
				// 010111000II01DDDEE111110iiiiiddd | RDD = combine(#1,#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x5c103e00) {
				// 010111000II10DDDEE111110iiiiiddd | RDD = combine(#2,#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x5c183e00) {
				// 010111000II11DDDEE111110iiiiiddd | RDD = combine(#3,#II) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x5d083e00) {
				// 01011101ssss1DDDEE111110iiiiiddd | RDD = combine(Rs,#0) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x5d003e00) {
				// 01011101ssss0DDDEE111110iiiiiddd | RDD = combine(#0,Rs) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x53003e00) {
				// 01010011ssssDDDDEE111110iiiiiddd | RD = add(Rs,#n1) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 3;
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x51003e00) {
				// 01010001ssssDDDDEE111110iiiiiddd | RD = add(Rs,#1) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x48003e00) {
				// 010010IIIIIIDDDDEE111110iiiiiddd | RD = #II ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x5a003e00) {
				// 010110100000DDDDEE111110iiiiiddd | RD = #n1 ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = #-1 ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x55003e00) {
				// 01010101ssssDDDDEE111110iiiiiddd | RD = sxtb(Rs) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x54003e00) {
				// 01010100ssssDDDDEE111110iiiiiddd | RD = sxth(Rs) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x50003e00) {
				// 01010000ssssDDDDEE111110iiiiiddd | RD = Rs ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = %s ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x57003e00) {
				// 01010111ssssDDDDEE111110iiiiiddd | RD = and(Rs,#255) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x56003e00) {
				// 01010110ssssDDDDEE111110iiiiiddd | RD = zxth(Rs) ; Rdd = memd(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_LOADRD_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rdd8
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = memd(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x40002000) {
				// 01000IIIIIIIxxxxEE100iiissssdddd | Rx = add(Rxin,#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x58002000) {
				// 01011000SSSSxxxxEE100iiissssdddd | Rx = add(Rxin,RS) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f800) == 0x4c002000) {
				// 010011IIIIIIDDDDEE100iiissssdddd | RD = add(r29,#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x52002000) {
				// 01010010SSSSDDDDEE100iiissssdddd | RD = and(RS,#1) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a702000) {
				// 010110100111DDDDEE100iiissssdddd | if (!p0) RD = #0 ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a502000) {
				// 010110100101DDDDEE100iiissssdddd | if (!p0.new) RD = #0 ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a602000) {
				// 010110100110DDDDEE100iiissssdddd | if (p0) RD = #0 ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a402000) {
				// 010110100100DDDDEE100iiissssdddd | if (p0.new) RD = #0 ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cf800) == 0x59002000) {
				// 01011001SSSS00IIEE100iiissssdddd | p0 = cmp.eq(RS,#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c002000) {
				// 010111000II00DDDEE100iiissssdddd | RDD = combine(#0,#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c082000) {
				// 010111000II01DDDEE100iiissssdddd | RDD = combine(#1,#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c102000) {
				// 010111000II10DDDEE100iiissssdddd | RDD = combine(#2,#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c182000) {
				// 010111000II11DDDEE100iiissssdddd | RDD = combine(#3,#II) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f800) == 0x5d082000) {
				// 01011101SSSS1DDDEE100iiissssdddd | RDD = combine(RS,#0) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f800) == 0x5d002000) {
				// 01011101SSSS0DDDEE100iiissssdddd | RDD = combine(#0,RS) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x53002000) {
				// 01010011SSSSDDDDEE100iiissssdddd | RD = add(RS,#n1) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x51002000) {
				// 01010001SSSSDDDDEE100iiissssdddd | RD = add(RS,#1) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f800) == 0x48002000) {
				// 010010IIIIIIDDDDEE100iiissssdddd | RD = #II ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a002000) {
				// 010110100000DDDDEE100iiissssdddd | RD = #n1 ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = #-1 ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x55002000) {
				// 01010101SSSSDDDDEE100iiissssdddd | RD = sxtb(RS) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x54002000) {
				// 01010100SSSSDDDDEE100iiissssdddd | RD = sxth(RS) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x50002000) {
				// 01010000SSSSDDDDEE100iiissssdddd | RD = RS ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = %s ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x57002000) {
				// 01010111SSSSDDDDEE100iiissssdddd | RD = and(RS,#255) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x56002000) {
				// 01010110SSSSDDDDEE100iiissssdddd | RD = zxth(RS) ; Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = memh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0x40003c00) {
				// 01000IIIIIIIxxxxEE11110iiiiidddd | Rx = add(Rxin,#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x58003c00) {
				// 01011000ssssxxxxEE11110iiiiidddd | Rx = add(Rxin,Rs) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fe00) == 0x4c003c00) {
				// 010011IIIIIIDDDDEE11110iiiiidddd | RD = add(r29,#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x52003c00) {
				// 01010010ssssDDDDEE11110iiiiidddd | RD = and(Rs,#1) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x5a703c00) {
				// 010110100111DDDDEE11110iiiiidddd | if (!p0) RD = #0 ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x5a503c00) {
				// 010110100101DDDDEE11110iiiiidddd | if (!p0.new) RD = #0 ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x5a603c00) {
				// 010110100110DDDDEE11110iiiiidddd | if (p0) RD = #0 ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x5a403c00) {
				// 010110100100DDDDEE11110iiiiidddd | if (p0.new) RD = #0 ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfe00) == 0x59003c00) {
				// 01011001ssss00IIEE11110iiiiidddd | p0 = cmp.eq(Rs,#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x5c003c00) {
				// 010111000II00DDDEE11110iiiiidddd | RDD = combine(#0,#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x5c083c00) {
				// 010111000II01DDDEE11110iiiiidddd | RDD = combine(#1,#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x5c103c00) {
				// 010111000II10DDDEE11110iiiiidddd | RDD = combine(#2,#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x5c183c00) {
				// 010111000II11DDDEE11110iiiiidddd | RDD = combine(#3,#II) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08fe00) == 0x5d083c00) {
				// 01011101ssss1DDDEE11110iiiiidddd | RDD = combine(Rs,#0) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08fe00) == 0x5d003c00) {
				// 01011101ssss0DDDEE11110iiiiidddd | RDD = combine(#0,Rs) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x53003c00) {
				// 01010011ssssDDDDEE11110iiiiidddd | RD = add(Rs,#n1) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x51003c00) {
				// 01010001ssssDDDDEE11110iiiiidddd | RD = add(Rs,#1) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fe00) == 0x48003c00) {
				// 010010IIIIIIDDDDEE11110iiiiidddd | RD = #II ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x5a003c00) {
				// 010110100000DDDDEE11110iiiiidddd | RD = #n1 ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = #-1 ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x55003c00) {
				// 01010101ssssDDDDEE11110iiiiidddd | RD = sxtb(Rs) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x54003c00) {
				// 01010100ssssDDDDEE11110iiiiidddd | RD = sxth(Rs) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x50003c00) {
				// 01010000ssssDDDDEE11110iiiiidddd | RD = Rs ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = %s ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x57003c00) {
				// 01010111ssssDDDDEE11110iiiiidddd | RD = and(Rs,#255) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x56003c00) {
				// 01010110ssssDDDDEE11110iiiiidddd | RD = zxth(Rs) ; Rd = memw(r29+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_LOADRI_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = memw(R29+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x40002800) {
				// 01000IIIIIIIxxxxEE101iiissssdddd | Rx = add(Rxin,#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x58002800) {
				// 01011000SSSSxxxxEE101iiissssdddd | Rx = add(Rxin,RS) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f800) == 0x4c002800) {
				// 010011IIIIIIDDDDEE101iiissssdddd | RD = add(r29,#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x52002800) {
				// 01010010SSSSDDDDEE101iiissssdddd | RD = and(RS,#1) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a702800) {
				// 010110100111DDDDEE101iiissssdddd | if (!p0) RD = #0 ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a502800) {
				// 010110100101DDDDEE101iiissssdddd | if (!p0.new) RD = #0 ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a602800) {
				// 010110100110DDDDEE101iiissssdddd | if (p0) RD = #0 ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a402800) {
				// 010110100100DDDDEE101iiissssdddd | if (p0.new) RD = #0 ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cf800) == 0x59002800) {
				// 01011001SSSS00IIEE101iiissssdddd | p0 = cmp.eq(RS,#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c002800) {
				// 010111000II00DDDEE101iiissssdddd | RDD = combine(#0,#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c082800) {
				// 010111000II01DDDEE101iiissssdddd | RDD = combine(#1,#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c102800) {
				// 010111000II10DDDEE101iiissssdddd | RDD = combine(#2,#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x5c182800) {
				// 010111000II11DDDEE101iiissssdddd | RDD = combine(#3,#II) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f800) == 0x5d082800) {
				// 01011101SSSS1DDDEE101iiissssdddd | RDD = combine(RS,#0) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f800) == 0x5d002800) {
				// 01011101SSSS0DDDEE101iiissssdddd | RDD = combine(#0,RS) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // RDD8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x53002800) {
				// 01010011SSSSDDDDEE101iiissssdddd | RD = add(RS,#n1) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[5].type = HEX_OP_TYPE_IMM;
				hi->ops[5].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[5].attr = HEX_OP_IMM_SCALED;
				hi->ops[5].shift = 1;
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hex_get_general_sub_regs(hi->ops[4].op.reg), hi->ops[5].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x51002800) {
				// 01010001SSSSDDDDEE101iiissssdddd | RD = add(RS,#1) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f800) == 0x48002800) {
				// 010010IIIIIIDDDDEE101iiissssdddd | RD = #II ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = ##0x%x ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x5a002800) {
				// 010110100000DDDDEE101iiissssdddd | RD = #n1 ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = #-1 ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x55002800) {
				// 01010101SSSSDDDDEE101iiissssdddd | RD = sxtb(RS) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x54002800) {
				// 01010100SSSSDDDDEE101iiissssdddd | RD = sxth(RS) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = sxth(%s) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x50002800) {
				// 01010000SSSSDDDDEE101iiissssdddd | RD = RS ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = %s ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x57002800) {
				// 01010111SSSSDDDDEE101iiissssdddd | RD = and(RS,#255) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x56002800) {
				// 01010110SSSSDDDDEE101iiissssdddd | RD = zxth(RS) ; Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // RD16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rd16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				sprintf(hi->mnem, "%s %s = zxth(%s) ; %s = memuh(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003f40) {
				// 01000iiiiiiixxxxEE11111101000000 | Rx = add(Rxin,#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003f40) {
				// 01011000ssssxxxxEE11111101000000 | Rx = add(Rxin,Rs) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003f40) {
				// 010011iiiiiiddddEE11111101000000 | Rd = add(r29,#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003f40) {
				// 01010010ssssddddEE11111101000000 | Rd = and(Rs,#1) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703f40) {
				// 010110100111ddddEE11111101000000 | if (!p0) Rd = #0 ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503f40) {
				// 010110100101ddddEE11111101000000 | if (!p0.new) Rd = #0 ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603f40) {
				// 010110100110ddddEE11111101000000 | if (p0) Rd = #0 ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403f40) {
				// 010110100100ddddEE11111101000000 | if (p0.new) Rd = #0 ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003f40) {
				// 01011001ssss00iiEE11111101000000 | p0 = cmp.eq(Rs,#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003f40) {
				// 010111000ii00dddEE11111101000000 | Rdd = combine(#0,#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083f40) {
				// 010111000ii01dddEE11111101000000 | Rdd = combine(#1,#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103f40) {
				// 010111000ii10dddEE11111101000000 | Rdd = combine(#2,#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183f40) {
				// 010111000ii11dddEE11111101000000 | Rdd = combine(#3,#Ii) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083f40) {
				// 01011101ssss1dddEE11111101000000 | Rdd = combine(Rs,#0) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003f40) {
				// 01011101ssss0dddEE11111101000000 | Rdd = combine(#0,Rs) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003f40) {
				// 01010011ssssddddEE11111101000000 | Rd = add(Rs,#n1) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003f40) {
				// 01010001ssssddddEE11111101000000 | Rd = add(Rs,#1) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003f40) {
				// 010010iiiiiiddddEE11111101000000 | Rd = #Ii ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003f40) {
				// 010110100000ddddEE11111101000000 | Rd = #n1 ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003f40) {
				// 01010101ssssddddEE11111101000000 | Rd = sxtb(Rs) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003f40) {
				// 01010100ssssddddEE11111101000000 | Rd = sxth(Rs) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003f40) {
				// 01010000ssssddddEE11111101000000 | Rd = Rs ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003f40) {
				// 01010111ssssddddEE11111101000000 | Rd = and(Rs,#255) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003f40) {
				// 01010110ssssddddEE11111101000000 | Rd = zxth(Rs) ; dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003f45) {
				// 01000iiiiiiixxxxEE11111101000101 | Rx = add(Rxin,#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003f45) {
				// 01011000ssssxxxxEE11111101000101 | Rx = add(Rxin,Rs) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003f45) {
				// 010011iiiiiiddddEE11111101000101 | Rd = add(r29,#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003f45) {
				// 01010010ssssddddEE11111101000101 | Rd = and(Rs,#1) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703f45) {
				// 010110100111ddddEE11111101000101 | if (!p0) Rd = #0 ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503f45) {
				// 010110100101ddddEE11111101000101 | if (!p0.new) Rd = #0 ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603f45) {
				// 010110100110ddddEE11111101000101 | if (p0) Rd = #0 ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403f45) {
				// 010110100100ddddEE11111101000101 | if (p0.new) Rd = #0 ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003f45) {
				// 01011001ssss00iiEE11111101000101 | p0 = cmp.eq(Rs,#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003f45) {
				// 010111000ii00dddEE11111101000101 | Rdd = combine(#0,#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083f45) {
				// 010111000ii01dddEE11111101000101 | Rdd = combine(#1,#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103f45) {
				// 010111000ii10dddEE11111101000101 | Rdd = combine(#2,#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183f45) {
				// 010111000ii11dddEE11111101000101 | Rdd = combine(#3,#Ii) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083f45) {
				// 01011101ssss1dddEE11111101000101 | Rdd = combine(Rs,#0) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003f45) {
				// 01011101ssss0dddEE11111101000101 | Rdd = combine(#0,Rs) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003f45) {
				// 01010011ssssddddEE11111101000101 | Rd = add(Rs,#n1) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003f45) {
				// 01010001ssssddddEE11111101000101 | Rd = add(Rs,#1) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003f45) {
				// 010010iiiiiiddddEE11111101000101 | Rd = #Ii ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003f45) {
				// 010110100000ddddEE11111101000101 | Rd = #n1 ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003f45) {
				// 01010101ssssddddEE11111101000101 | Rd = sxtb(Rs) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003f45) {
				// 01010100ssssddddEE11111101000101 | Rd = sxth(Rs) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003f45) {
				// 01010000ssssddddEE11111101000101 | Rd = Rs ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003f45) {
				// 01010111ssssddddEE11111101000101 | Rd = and(Rs,#255) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003f45) {
				// 01010110ssssddddEE11111101000101 | Rd = zxth(Rs) ; if (!p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (!P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003f47) {
				// 01000iiiiiiixxxxEE11111101000111 | Rx = add(Rxin,#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003f47) {
				// 01011000ssssxxxxEE11111101000111 | Rx = add(Rxin,Rs) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003f47) {
				// 010011iiiiiiddddEE11111101000111 | Rd = add(r29,#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003f47) {
				// 01010010ssssddddEE11111101000111 | Rd = and(Rs,#1) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703f47) {
				// 010110100111ddddEE11111101000111 | if (!p0) Rd = #0 ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503f47) {
				// 010110100101ddddEE11111101000111 | if (!p0.new) Rd = #0 ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603f47) {
				// 010110100110ddddEE11111101000111 | if (p0) Rd = #0 ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403f47) {
				// 010110100100ddddEE11111101000111 | if (p0.new) Rd = #0 ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003f47) {
				// 01011001ssss00iiEE11111101000111 | p0 = cmp.eq(Rs,#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003f47) {
				// 010111000ii00dddEE11111101000111 | Rdd = combine(#0,#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083f47) {
				// 010111000ii01dddEE11111101000111 | Rdd = combine(#1,#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103f47) {
				// 010111000ii10dddEE11111101000111 | Rdd = combine(#2,#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183f47) {
				// 010111000ii11dddEE11111101000111 | Rdd = combine(#3,#Ii) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083f47) {
				// 01011101ssss1dddEE11111101000111 | Rdd = combine(Rs,#0) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003f47) {
				// 01011101ssss0dddEE11111101000111 | Rdd = combine(#0,Rs) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003f47) {
				// 01010011ssssddddEE11111101000111 | Rd = add(Rs,#n1) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003f47) {
				// 01010001ssssddddEE11111101000111 | Rd = add(Rs,#1) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003f47) {
				// 010010iiiiiiddddEE11111101000111 | Rd = #Ii ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003f47) {
				// 010110100000ddddEE11111101000111 | Rd = #n1 ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003f47) {
				// 01010101ssssddddEE11111101000111 | Rd = sxtb(Rs) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003f47) {
				// 01010100ssssddddEE11111101000111 | Rd = sxth(Rs) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003f47) {
				// 01010000ssssddddEE11111101000111 | Rd = Rs ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003f47) {
				// 01010111ssssddddEE11111101000111 | Rd = and(Rs,#255) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003f47) {
				// 01010110ssssddddEE11111101000111 | Rd = zxth(Rs) ; if (!p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_RETURN_FNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (!P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003f44) {
				// 01000iiiiiiixxxxEE11111101000100 | Rx = add(Rxin,#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003f44) {
				// 01011000ssssxxxxEE11111101000100 | Rx = add(Rxin,Rs) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003f44) {
				// 010011iiiiiiddddEE11111101000100 | Rd = add(r29,#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003f44) {
				// 01010010ssssddddEE11111101000100 | Rd = and(Rs,#1) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703f44) {
				// 010110100111ddddEE11111101000100 | if (!p0) Rd = #0 ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503f44) {
				// 010110100101ddddEE11111101000100 | if (!p0.new) Rd = #0 ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603f44) {
				// 010110100110ddddEE11111101000100 | if (p0) Rd = #0 ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403f44) {
				// 010110100100ddddEE11111101000100 | if (p0.new) Rd = #0 ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003f44) {
				// 01011001ssss00iiEE11111101000100 | p0 = cmp.eq(Rs,#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003f44) {
				// 010111000ii00dddEE11111101000100 | Rdd = combine(#0,#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083f44) {
				// 010111000ii01dddEE11111101000100 | Rdd = combine(#1,#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103f44) {
				// 010111000ii10dddEE11111101000100 | Rdd = combine(#2,#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183f44) {
				// 010111000ii11dddEE11111101000100 | Rdd = combine(#3,#Ii) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083f44) {
				// 01011101ssss1dddEE11111101000100 | Rdd = combine(Rs,#0) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003f44) {
				// 01011101ssss0dddEE11111101000100 | Rdd = combine(#0,Rs) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003f44) {
				// 01010011ssssddddEE11111101000100 | Rd = add(Rs,#n1) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003f44) {
				// 01010001ssssddddEE11111101000100 | Rd = add(Rs,#1) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003f44) {
				// 010010iiiiiiddddEE11111101000100 | Rd = #Ii ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003f44) {
				// 010110100000ddddEE11111101000100 | Rd = #n1 ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003f44) {
				// 01010101ssssddddEE11111101000100 | Rd = sxtb(Rs) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003f44) {
				// 01010100ssssddddEE11111101000100 | Rd = sxth(Rs) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003f44) {
				// 01010000ssssddddEE11111101000100 | Rd = Rs ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003f44) {
				// 01010111ssssddddEE11111101000100 | Rd = and(Rs,#255) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003f44) {
				// 01010110ssssddddEE11111101000100 | Rd = zxth(Rs) ; if (p0) dealloc_return
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (P0) dealloc_return %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ffff) == 0x40003f46) {
				// 01000iiiiiiixxxxEE11111101000110 | Rx = add(Rxin,#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // Ii
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x58003f46) {
				// 01011000ssssxxxxEE11111101000110 | Rx = add(Rxin,Rs) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x4c003f46) {
				// 010011iiiiiiddddEE11111101000110 | Rd = add(r29,#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x52003f46) {
				// 01010010ssssddddEE11111101000110 | Rd = and(Rs,#1) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a703f46) {
				// 010110100111ddddEE11111101000110 | if (!p0) Rd = #0 ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a503f46) {
				// 010110100101ddddEE11111101000110 | if (!p0.new) Rd = #0 ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a603f46) {
				// 010110100110ddddEE11111101000110 | if (p0) Rd = #0 ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a403f46) {
				// 010110100100ddddEE11111101000110 | if (p0.new) Rd = #0 ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cffff) == 0x59003f46) {
				// 01011001ssss00iiEE11111101000110 | p0 = cmp.eq(Rs,#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c003f46) {
				// 010111000ii00dddEE11111101000110 | Rdd = combine(#0,#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c083f46) {
				// 010111000ii01dddEE11111101000110 | Rdd = combine(#1,#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c103f46) {
				// 010111000ii10dddEE11111101000110 | Rdd = combine(#2,#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ffff) == 0x5c183f46) {
				// 010111000ii11dddEE11111101000110 | Rdd = combine(#3,#Ii) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d083f46) {
				// 01011101ssss1dddEE11111101000110 | Rdd = combine(Rs,#0) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ffff) == 0x5d003f46) {
				// 01011101ssss0dddEE11111101000110 | Rdd = combine(#0,Rs) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x53003f46) {
				// 01010011ssssddddEE11111101000110 | Rd = add(Rs,#n1) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x51003f46) {
				// 01010001ssssddddEE11111101000110 | Rd = add(Rs,#1) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ffff) == 0x48003f46) {
				// 010010iiiiiiddddEE11111101000110 | Rd = #Ii ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = ##0x%x ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ffff) == 0x5a003f46) {
				// 010110100000ddddEE11111101000110 | Rd = #n1 ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				sprintf(hi->mnem, "%s %s = #-1 ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x55003f46) {
				// 01010101ssssddddEE11111101000110 | Rd = sxtb(Rs) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x54003f46) {
				// 01010100ssssddddEE11111101000110 | Rd = sxth(Rs) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x50003f46) {
				// 01010000ssssddddEE11111101000110 | Rd = Rs ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = %s ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x57003f46) {
				// 01010111ssssddddEE11111101000110 | Rd = and(Rs,#255) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ffff) == 0x56003f46) {
				// 01010110ssssddddEE11111101000110 | Rd = zxth(Rs) ; if (p0.new) dealloc_return:nt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SL2_RETURN_TNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; if (P0.new) dealloc_return:nt %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x6:
			if ((hi_u32 & 0xf800f000) == 0x60001000) {
				// 01100IIIIIIIxxxxEE01iiiisssstttt | Rx = add(Rxin,#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x78001000) {
				// 01111000SSSSxxxxEE01iiiisssstttt | Rx = add(Rxin,RS) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f000) == 0x6c001000) {
				// 011011IIIIIIddddEE01iiiisssstttt | Rd = add(r29,#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x72001000) {
				// 01110010SSSSddddEE01iiiisssstttt | Rd = and(RS,#1) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a701000) {
				// 011110100111ddddEE01iiiisssstttt | if (!p0) Rd = #0 ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a501000) {
				// 011110100101ddddEE01iiiisssstttt | if (!p0.new) Rd = #0 ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a601000) {
				// 011110100110ddddEE01iiiisssstttt | if (p0) Rd = #0 ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a401000) {
				// 011110100100ddddEE01iiiisssstttt | if (p0.new) Rd = #0 ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cf000) == 0x79001000) {
				// 01111001SSSS00IIEE01iiiisssstttt | p0 = cmp.eq(RS,#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x7c001000) {
				// 011111000II00dddEE01iiiisssstttt | Rdd = combine(#0,#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x7c081000) {
				// 011111000II01dddEE01iiiisssstttt | Rdd = combine(#1,#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x7c101000) {
				// 011111000II10dddEE01iiiisssstttt | Rdd = combine(#2,#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x7c181000) {
				// 011111000II11dddEE01iiiisssstttt | Rdd = combine(#3,#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f000) == 0x7d081000) {
				// 01111101SSSS1dddEE01iiiisssstttt | Rdd = combine(RS,#0) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f000) == 0x7d001000) {
				// 01111101SSSS0dddEE01iiiisssstttt | Rdd = combine(#0,RS) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x73001000) {
				// 01110011SSSSddddEE01iiiisssstttt | Rd = add(RS,#n1) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x71001000) {
				// 01110001SSSSddddEE01iiiisssstttt | Rd = add(RS,#1) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f000) == 0x68001000) {
				// 011010IIIIIIddddEE01iiiisssstttt | Rd = #II ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = ##0x%x ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a001000) {
				// 011110100000ddddEE01iiiisssstttt | Rd = #n1 ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = #-1 ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x75001000) {
				// 01110101SSSSddddEE01iiiisssstttt | Rd = sxtb(RS) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x74001000) {
				// 01110100SSSSddddEE01iiiisssstttt | Rd = sxth(RS) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x70001000) {
				// 01110000SSSSddddEE01iiiisssstttt | Rd = RS ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = %s ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x77001000) {
				// 01110111SSSSddddEE01iiiisssstttt | Rd = and(RS,#255) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x76001000) {
				// 01110110SSSSddddEE01iiiisssstttt | Rd = zxth(RS) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f000) == 0x60000000) {
				// 01100IIIIIIIxxxxEE00iiiisssstttt | Rx = add(Rxin,#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x78000000) {
				// 01111000SSSSxxxxEE00iiiisssstttt | Rx = add(Rxin,RS) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f000) == 0x6c000000) {
				// 011011IIIIIIddddEE00iiiisssstttt | Rd = add(r29,#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x72000000) {
				// 01110010SSSSddddEE00iiiisssstttt | Rd = and(RS,#1) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a700000) {
				// 011110100111ddddEE00iiiisssstttt | if (!p0) Rd = #0 ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a500000) {
				// 011110100101ddddEE00iiiisssstttt | if (!p0.new) Rd = #0 ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a600000) {
				// 011110100110ddddEE00iiiisssstttt | if (p0) Rd = #0 ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a400000) {
				// 011110100100ddddEE00iiiisssstttt | if (p0.new) Rd = #0 ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cf000) == 0x79000000) {
				// 01111001SSSS00IIEE00iiiisssstttt | p0 = cmp.eq(RS,#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x7c000000) {
				// 011111000II00dddEE00iiiisssstttt | Rdd = combine(#0,#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x7c080000) {
				// 011111000II01dddEE00iiiisssstttt | Rdd = combine(#1,#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x7c100000) {
				// 011111000II10dddEE00iiiisssstttt | Rdd = combine(#2,#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f000) == 0x7c180000) {
				// 011111000II11dddEE00iiiisssstttt | Rdd = combine(#3,#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f000) == 0x7d080000) {
				// 01111101SSSS1dddEE00iiiisssstttt | Rdd = combine(RS,#0) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f000) == 0x7d000000) {
				// 01111101SSSS0dddEE00iiiisssstttt | Rdd = combine(#0,RS) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x73000000) {
				// 01110011SSSSddddEE00iiiisssstttt | Rd = add(RS,#n1) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x71000000) {
				// 01110001SSSSddddEE00iiiisssstttt | Rd = add(RS,#1) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f000) == 0x68000000) {
				// 011010IIIIIIddddEE00iiiisssstttt | Rd = #II ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = ##0x%x ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f000) == 0x7a000000) {
				// 011110100000ddddEE00iiiisssstttt | Rd = #n1 ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = #-1 ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x75000000) {
				// 01110101SSSSddddEE00iiiisssstttt | Rd = sxtb(RS) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x74000000) {
				// 01110100SSSSddddEE00iiiisssstttt | Rd = sxth(RS) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x70000000) {
				// 01110000SSSSddddEE00iiiisssstttt | Rd = RS ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = %s ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x77000000) {
				// 01110111SSSSddddEE00iiiisssstttt | Rd = and(RS,#255) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x76000000) {
				// 01110110SSSSddddEE00iiiisssstttt | Rd = zxth(RS) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x7:
			if ((hi_u32 & 0xf800fe0f) == 0x60003c00) {
				// 01100IIIIIIIxxxxEE11110iiiii0000 | Rx = add(Rxin,#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x78003c00) {
				// 01111000ssssxxxxEE11110iiiii0000 | Rx = add(Rxin,Rs) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fe0f) == 0x6c003c00) {
				// 011011IIIIIIddddEE11110iiiii0000 | Rd = add(r29,#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x72003c00) {
				// 01110010ssssddddEE11110iiiii0000 | Rd = and(Rs,#1) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe0f) == 0x7a703c00) {
				// 011110100111ddddEE11110iiiii0000 | if (!p0) Rd = #0 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe0f) == 0x7a503c00) {
				// 011110100101ddddEE11110iiiii0000 | if (!p0.new) Rd = #0 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe0f) == 0x7a603c00) {
				// 011110100110ddddEE11110iiiii0000 | if (p0) Rd = #0 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe0f) == 0x7a403c00) {
				// 011110100100ddddEE11110iiiii0000 | if (p0.new) Rd = #0 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfe0f) == 0x79003c00) {
				// 01111001ssss00IIEE11110iiiii0000 | p0 = cmp.eq(Rs,#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe0f) == 0x7c003c00) {
				// 011111000II00dddEE11110iiiii0000 | Rdd = combine(#0,#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe0f) == 0x7c083c00) {
				// 011111000II01dddEE11110iiiii0000 | Rdd = combine(#1,#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe0f) == 0x7c103c00) {
				// 011111000II10dddEE11110iiiii0000 | Rdd = combine(#2,#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe0f) == 0x7c183c00) {
				// 011111000II11dddEE11110iiiii0000 | Rdd = combine(#3,#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08fe0f) == 0x7d083c00) {
				// 01111101ssss1dddEE11110iiiii0000 | Rdd = combine(Rs,#0) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08fe0f) == 0x7d003c00) {
				// 01111101ssss0dddEE11110iiiii0000 | Rdd = combine(#0,Rs) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x73003c00) {
				// 01110011ssssddddEE11110iiiii0000 | Rd = add(Rs,#n1) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x71003c00) {
				// 01110001ssssddddEE11110iiiii0000 | Rd = add(Rs,#1) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fe0f) == 0x68003c00) {
				// 011010IIIIIIddddEE11110iiiii0000 | Rd = #II ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = ##0x%x ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe0f) == 0x7a003c00) {
				// 011110100000ddddEE11110iiiii0000 | Rd = #n1 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = #-1 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x75003c00) {
				// 01110101ssssddddEE11110iiiii0000 | Rd = sxtb(Rs) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x74003c00) {
				// 01110100ssssddddEE11110iiiii0000 | Rd = sxth(Rs) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = sxth(%s) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x70003c00) {
				// 01110000ssssddddEE11110iiiii0000 | Rd = Rs ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = %s ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x77003c00) {
				// 01110111ssssddddEE11110iiiii0000 | Rd = and(Rs,#255) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0x76003c00) {
				// 01110110ssssddddEE11110iiiii0000 | Rd = zxth(Rs) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = zxth(%s) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x60003200) {
				// 01100IIIIIIIxxxxEE110010ssssiiii | Rx = add(Rxin,#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x78003200) {
				// 01111000SSSSxxxxEE110010ssssiiii | Rx = add(Rxin,RS) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x6c003200) {
				// 011011IIIIIIddddEE110010ssssiiii | Rd = add(r29,#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x72003200) {
				// 01110010SSSSddddEE110010ssssiiii | Rd = and(RS,#1) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a703200) {
				// 011110100111ddddEE110010ssssiiii | if (!p0) Rd = #0 ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a503200) {
				// 011110100101ddddEE110010ssssiiii | if (!p0.new) Rd = #0 ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a603200) {
				// 011110100110ddddEE110010ssssiiii | if (p0) Rd = #0 ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a403200) {
				// 011110100100ddddEE110010ssssiiii | if (p0.new) Rd = #0 ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff00) == 0x79003200) {
				// 01111001SSSS00IIEE110010ssssiiii | p0 = cmp.eq(RS,#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c003200) {
				// 011111000II00dddEE110010ssssiiii | Rdd = combine(#0,#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c083200) {
				// 011111000II01dddEE110010ssssiiii | Rdd = combine(#1,#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c103200) {
				// 011111000II10dddEE110010ssssiiii | Rdd = combine(#2,#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c183200) {
				// 011111000II11dddEE110010ssssiiii | Rdd = combine(#3,#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x7d083200) {
				// 01111101SSSS1dddEE110010ssssiiii | Rdd = combine(RS,#0) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x7d003200) {
				// 01111101SSSS0dddEE110010ssssiiii | Rdd = combine(#0,RS) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x73003200) {
				// 01110011SSSSddddEE110010ssssiiii | Rd = add(RS,#n1) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x71003200) {
				// 01110001SSSSddddEE110010ssssiiii | Rd = add(RS,#1) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x68003200) {
				// 011010IIIIIIddddEE110010ssssiiii | Rd = #II ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a003200) {
				// 011110100000ddddEE110010ssssiiii | Rd = #n1 ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = #-1 ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x75003200) {
				// 01110101SSSSddddEE110010ssssiiii | Rd = sxtb(RS) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x74003200) {
				// 01110100SSSSddddEE110010ssssiiii | Rd = sxth(RS) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x70003200) {
				// 01110000SSSSddddEE110010ssssiiii | Rd = RS ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = %s ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x77003200) {
				// 01110111SSSSddddEE110010ssssiiii | Rd = and(RS,#255) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x76003200) {
				// 01110110SSSSddddEE110010ssssiiii | Rd = zxth(RS) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x60003300) {
				// 01100IIIIIIIxxxxEE110011ssssiiii | Rx = add(Rxin,#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x78003300) {
				// 01111000SSSSxxxxEE110011ssssiiii | Rx = add(Rxin,RS) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x6c003300) {
				// 011011IIIIIIddddEE110011ssssiiii | Rd = add(r29,#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x72003300) {
				// 01110010SSSSddddEE110011ssssiiii | Rd = and(RS,#1) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a703300) {
				// 011110100111ddddEE110011ssssiiii | if (!p0) Rd = #0 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a503300) {
				// 011110100101ddddEE110011ssssiiii | if (!p0.new) Rd = #0 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a603300) {
				// 011110100110ddddEE110011ssssiiii | if (p0) Rd = #0 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a403300) {
				// 011110100100ddddEE110011ssssiiii | if (p0.new) Rd = #0 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff00) == 0x79003300) {
				// 01111001SSSS00IIEE110011ssssiiii | p0 = cmp.eq(RS,#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c003300) {
				// 011111000II00dddEE110011ssssiiii | Rdd = combine(#0,#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c083300) {
				// 011111000II01dddEE110011ssssiiii | Rdd = combine(#1,#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c103300) {
				// 011111000II10dddEE110011ssssiiii | Rdd = combine(#2,#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c183300) {
				// 011111000II11dddEE110011ssssiiii | Rdd = combine(#3,#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x7d083300) {
				// 01111101SSSS1dddEE110011ssssiiii | Rdd = combine(RS,#0) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x7d003300) {
				// 01111101SSSS0dddEE110011ssssiiii | Rdd = combine(#0,RS) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x73003300) {
				// 01110011SSSSddddEE110011ssssiiii | Rd = add(RS,#n1) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x71003300) {
				// 01110001SSSSddddEE110011ssssiiii | Rd = add(RS,#1) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x68003300) {
				// 011010IIIIIIddddEE110011ssssiiii | Rd = #II ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = ##0x%x ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a003300) {
				// 011110100000ddddEE110011ssssiiii | Rd = #n1 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = #-1 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x75003300) {
				// 01110101SSSSddddEE110011ssssiiii | Rd = sxtb(RS) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x74003300) {
				// 01110100SSSSddddEE110011ssssiiii | Rd = sxth(RS) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x70003300) {
				// 01110000SSSSddddEE110011ssssiiii | Rd = RS ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = %s ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x77003300) {
				// 01110111SSSSddddEE110011ssssiiii | Rd = and(RS,#255) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x76003300) {
				// 01110110SSSSddddEE110011ssssiiii | Rd = zxth(RS) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0x60002a00) {
				// 01100IIIIIIIxxxxEE10101iiiiiittt | Rx = add(Rxin,#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x78002a00) {
				// 01111000ssssxxxxEE10101iiiiiittt | Rx = add(Rxin,Rs) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fe00) == 0x6c002a00) {
				// 011011IIIIIIddddEE10101iiiiiittt | Rd = add(r29,#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x72002a00) {
				// 01110010ssssddddEE10101iiiiiittt | Rd = and(Rs,#1) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a702a00) {
				// 011110100111ddddEE10101iiiiiittt | if (!p0) Rd = #0 ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				if (hi->ops[1].op.imm & (1 << 8)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a502a00) {
				// 011110100101ddddEE10101iiiiiittt | if (!p0.new) Rd = #0 ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				if (hi->ops[1].op.imm & (1 << 8)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a602a00) {
				// 011110100110ddddEE10101iiiiiittt | if (p0) Rd = #0 ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				if (hi->ops[1].op.imm & (1 << 8)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a402a00) {
				// 011110100100ddddEE10101iiiiiittt | if (p0.new) Rd = #0 ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				if (hi->ops[1].op.imm & (1 << 8)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfe00) == 0x79002a00) {
				// 01111001ssss00IIEE10101iiiiiittt | p0 = cmp.eq(Rs,#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x7c002a00) {
				// 011111000II00dddEE10101iiiiiittt | Rdd = combine(#0,#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x7c082a00) {
				// 011111000II01dddEE10101iiiiiittt | Rdd = combine(#1,#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x7c102a00) {
				// 011111000II10dddEE10101iiiiiittt | Rdd = combine(#2,#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x7c182a00) {
				// 011111000II11dddEE10101iiiiiittt | Rdd = combine(#3,#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08fe00) == 0x7d082a00) {
				// 01111101ssss1dddEE10101iiiiiittt | Rdd = combine(Rs,#0) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08fe00) == 0x7d002a00) {
				// 01111101ssss0dddEE10101iiiiiittt | Rdd = combine(#0,Rs) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x73002a00) {
				// 01110011ssssddddEE10101iiiiiittt | Rd = add(Rs,#n1) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x71002a00) {
				// 01110001ssssddddEE10101iiiiiittt | Rd = add(Rs,#1) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fe00) == 0x68002a00) {
				// 011010IIIIIIddddEE10101iiiiiittt | Rd = #II ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = ##0x%x ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a002a00) {
				// 011110100000ddddEE10101iiiiiittt | Rd = #n1 ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = #-1 ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x75002a00) {
				// 01110101ssssddddEE10101iiiiiittt | Rd = sxtb(Rs) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x74002a00) {
				// 01110100ssssddddEE10101iiiiiittt | Rd = sxth(Rs) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x70002a00) {
				// 01110000ssssddddEE10101iiiiiittt | Rd = Rs ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = %s ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x77002a00) {
				// 01110111ssssddddEE10101iiiiiittt | Rd = and(Rs,#255) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x76002a00) {
				// 01110110ssssddddEE10101iiiiiittt | Rd = zxth(Rs) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0x60002000) {
				// 01100IIIIIIIxxxxEE100iiisssstttt | Rx = add(Rxin,#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x78002000) {
				// 01111000SSSSxxxxEE100iiisssstttt | Rx = add(Rxin,RS) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f800) == 0x6c002000) {
				// 011011IIIIIIddddEE100iiisssstttt | Rd = add(r29,#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x72002000) {
				// 01110010SSSSddddEE100iiisssstttt | Rd = and(RS,#1) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x7a702000) {
				// 011110100111ddddEE100iiisssstttt | if (!p0) Rd = #0 ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x7a502000) {
				// 011110100101ddddEE100iiisssstttt | if (!p0.new) Rd = #0 ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x7a602000) {
				// 011110100110ddddEE100iiisssstttt | if (p0) Rd = #0 ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x7a402000) {
				// 011110100100ddddEE100iiisssstttt | if (p0.new) Rd = #0 ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cf800) == 0x79002000) {
				// 01111001SSSS00IIEE100iiisssstttt | p0 = cmp.eq(RS,#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x7c002000) {
				// 011111000II00dddEE100iiisssstttt | Rdd = combine(#0,#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x7c082000) {
				// 011111000II01dddEE100iiisssstttt | Rdd = combine(#1,#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x7c102000) {
				// 011111000II10dddEE100iiisssstttt | Rdd = combine(#2,#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98f800) == 0x7c182000) {
				// 011111000II11dddEE100iiisssstttt | Rdd = combine(#3,#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f800) == 0x7d082000) {
				// 01111101SSSS1dddEE100iiisssstttt | Rdd = combine(RS,#0) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08f800) == 0x7d002000) {
				// 01111101SSSS0dddEE100iiisssstttt | Rdd = combine(#0,RS) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x73002000) {
				// 01110011SSSSddddEE100iiisssstttt | Rd = add(RS,#n1) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x71002000) {
				// 01110001SSSSddddEE100iiisssstttt | Rd = add(RS,#1) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00f800) == 0x68002000) {
				// 011010IIIIIIddddEE100iiisssstttt | Rd = #II ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = ##0x%x ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0f800) == 0x7a002000) {
				// 011110100000ddddEE100iiisssstttt | Rd = #n1 ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = #-1 ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x75002000) {
				// 01110101SSSSddddEE100iiisssstttt | Rd = sxtb(RS) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x74002000) {
				// 01110100SSSSddddEE100iiisssstttt | Rd = sxth(RS) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x70002000) {
				// 01110000SSSSddddEE100iiisssstttt | Rd = RS ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = %s ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x77002000) {
				// 01110111SSSSddddEE100iiisssstttt | Rd = and(RS,#255) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0x76002000) {
				// 01110110SSSSddddEE100iiisssstttt | Rd = zxth(RS) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0x60002800) {
				// 01100IIIIIIIxxxxEE10100iiiiitttt | Rx = add(Rxin,#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x78002800) {
				// 01111000ssssxxxxEE10100iiiiitttt | Rx = add(Rxin,Rs) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fe00) == 0x6c002800) {
				// 011011IIIIIIddddEE10100iiiiitttt | Rd = add(r29,#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x72002800) {
				// 01110010ssssddddEE10100iiiiitttt | Rd = and(Rs,#1) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a702800) {
				// 011110100111ddddEE10100iiiiitttt | if (!p0) Rd = #0 ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a502800) {
				// 011110100101ddddEE10100iiiiitttt | if (!p0.new) Rd = #0 ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a602800) {
				// 011110100110ddddEE10100iiiiitttt | if (p0) Rd = #0 ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a402800) {
				// 011110100100ddddEE10100iiiiitttt | if (p0.new) Rd = #0 ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cfe00) == 0x79002800) {
				// 01111001ssss00IIEE10100iiiiitttt | p0 = cmp.eq(Rs,#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x7c002800) {
				// 011111000II00dddEE10100iiiiitttt | Rdd = combine(#0,#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x7c082800) {
				// 011111000II01dddEE10100iiiiitttt | Rdd = combine(#1,#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x7c102800) {
				// 011111000II10dddEE10100iiiiitttt | Rdd = combine(#2,#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98fe00) == 0x7c182800) {
				// 011111000II11dddEE10100iiiiitttt | Rdd = combine(#3,#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08fe00) == 0x7d082800) {
				// 01111101ssss1dddEE10100iiiiitttt | Rdd = combine(Rs,#0) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08fe00) == 0x7d002800) {
				// 01111101ssss0dddEE10100iiiiitttt | Rdd = combine(#0,Rs) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x73002800) {
				// 01110011ssssddddEE10100iiiiitttt | Rd = add(Rs,#n1) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x71002800) {
				// 01110001ssssddddEE10100iiiiitttt | Rd = add(Rs,#1) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00fe00) == 0x68002800) {
				// 011010IIIIIIddddEE10100iiiiitttt | Rd = #II ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = ##0x%x ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0fe00) == 0x7a002800) {
				// 011110100000ddddEE10100iiiiitttt | Rd = #n1 ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = #-1 ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x75002800) {
				// 01110101ssssddddEE10100iiiiitttt | Rd = sxtb(Rs) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x74002800) {
				// 01110100ssssddddEE10100iiiiitttt | Rd = sxth(Rs) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x70002800) {
				// 01110000ssssddddEE10100iiiiitttt | Rd = Rs ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = %s ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x77002800) {
				// 01110111ssssddddEE10100iiiiitttt | Rd = and(Rs,#255) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0x76002800) {
				// 01110110ssssddddEE10100iiiiitttt | Rd = zxth(Rs) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x60003000) {
				// 01100IIIIIIIxxxxEE110000ssssiiii | Rx = add(Rxin,#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x78003000) {
				// 01111000SSSSxxxxEE110000ssssiiii | Rx = add(Rxin,RS) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x6c003000) {
				// 011011IIIIIIddddEE110000ssssiiii | Rd = add(r29,#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x72003000) {
				// 01110010SSSSddddEE110000ssssiiii | Rd = and(RS,#1) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a703000) {
				// 011110100111ddddEE110000ssssiiii | if (!p0) Rd = #0 ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a503000) {
				// 011110100101ddddEE110000ssssiiii | if (!p0.new) Rd = #0 ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a603000) {
				// 011110100110ddddEE110000ssssiiii | if (p0) Rd = #0 ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a403000) {
				// 011110100100ddddEE110000ssssiiii | if (p0.new) Rd = #0 ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff00) == 0x79003000) {
				// 01111001SSSS00IIEE110000ssssiiii | p0 = cmp.eq(RS,#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c003000) {
				// 011111000II00dddEE110000ssssiiii | Rdd = combine(#0,#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c083000) {
				// 011111000II01dddEE110000ssssiiii | Rdd = combine(#1,#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c103000) {
				// 011111000II10dddEE110000ssssiiii | Rdd = combine(#2,#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c183000) {
				// 011111000II11dddEE110000ssssiiii | Rdd = combine(#3,#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x7d083000) {
				// 01111101SSSS1dddEE110000ssssiiii | Rdd = combine(RS,#0) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x7d003000) {
				// 01111101SSSS0dddEE110000ssssiiii | Rdd = combine(#0,RS) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x73003000) {
				// 01110011SSSSddddEE110000ssssiiii | Rd = add(RS,#n1) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x71003000) {
				// 01110001SSSSddddEE110000ssssiiii | Rd = add(RS,#1) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x68003000) {
				// 011010IIIIIIddddEE110000ssssiiii | Rd = #II ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = ##0x%x ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a003000) {
				// 011110100000ddddEE110000ssssiiii | Rd = #n1 ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = #-1 ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x75003000) {
				// 01110101SSSSddddEE110000ssssiiii | Rd = sxtb(RS) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x74003000) {
				// 01110100SSSSddddEE110000ssssiiii | Rd = sxth(RS) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x70003000) {
				// 01110000SSSSddddEE110000ssssiiii | Rd = RS ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = %s ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x77003000) {
				// 01110111SSSSddddEE110000ssssiiii | Rd = and(RS,#255) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x76003000) {
				// 01110110SSSSddddEE110000ssssiiii | Rd = zxth(RS) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0x60003100) {
				// 01100IIIIIIIxxxxEE110001ssssiiii | Rx = add(Rxin,#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDI_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7f00000) >> 20); // II
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x78003100) {
				// 01111000SSSSxxxxEE110001ssssiiii | Rx = add(Rxin,RS) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDRX_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rx16in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%sin,%s) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x6c003100) {
				// 011011IIIIIIddddEE110001ssssiiii | Rd = add(r29,#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ADDSP_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = add(R29,#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x72003100) {
				// 01110010SSSSddddEE110001ssssiiii | Rd = and(RS,#1) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_AND1_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = and(%s,#1) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a703100) {
				// 011110100111ddddEE110001ssssiiii | if (!p0) Rd = #0 ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRF_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (!P0) %s = #0 ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a503100) {
				// 011110100101ddddEE110001ssssiiii | if (!p0.new) Rd = #0 ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRFNEW_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (!P0.new) %s = #0 ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a603100) {
				// 011110100110ddddEE110001ssssiiii | if (p0) Rd = #0 ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRT_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (P0) %s = #0 ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a403100) {
				// 011110100100ddddEE110001ssssiiii | if (p0.new) Rd = #0 ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CLRTNEW_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				sprintf(hi->mnem, "%s if (P0.new) %s = #0 ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0cff00) == 0x79003100) {
				// 01111001SSSS00IIEE110001ssssiiii | p0 = cmp.eq(RS,#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_CMPEQI_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x30000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c003100) {
				// 011111000II00dddEE110001ssssiiii | Rdd = combine(#0,#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE0I_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#0,#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c083100) {
				// 011111000II01dddEE110001ssssiiii | Rdd = combine(#1,#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE1I_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#1,#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c103100) {
				// 011111000II10dddEE110001ssssiiii | Rdd = combine(#2,#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE2I_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#2,#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff98ff00) == 0x7c183100) {
				// 011111000II11dddEE110001ssssiiii | Rdd = combine(#3,#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINE3I_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x600000) >> 21); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#3,#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x7d083100) {
				// 01111101SSSS1dddEE110001ssssiiii | Rdd = combine(RS,#0) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINERZ_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(%s,#0) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff08ff00) == 0x7d003100) {
				// 01111101SSSS0dddEE110001ssssiiii | Rdd = combine(#0,RS) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_COMBINEZR_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = combine(#0,%s) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x73003100) {
				// 01110011SSSSddddEE110001ssssiiii | Rd = add(RS,#n1) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_DEC_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%s,#-1) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x71003100) {
				// 01110001SSSSddddEE110001ssssiiii | Rd = add(RS,#1) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_INC_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = add(%s,#1) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfc00ff00) == 0x68003100) {
				// 011010IIIIIIddddEE110001ssssiiii | Rd = #II ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETI_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00000) >> 20); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = ##0x%x ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff0ff00) == 0x7a003100) {
				// 011110100000ddddEE110001ssssiiii | Rd = #n1 ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SETIN1_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = #-1 ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x75003100) {
				// 01110101SSSSddddEE110001ssssiiii | Rd = sxtb(RS) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTB_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = sxtb(%s) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x74003100) {
				// 01110100SSSSddddEE110001ssssiiii | Rd = sxth(RS) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_SXTH_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = sxth(%s) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x70003100) {
				// 01110000SSSSddddEE110001ssssiiii | Rd = RS ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_TFR_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = %s ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x77003100) {
				// 01110111SSSSddddEE110001ssssiiii | Rd = and(RS,#255) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTB_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = and(%s,#255) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0x76003100) {
				// 01110110SSSSddddEE110001ssssiiii | Rd = zxth(RS) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SA1_ZXTH_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = zxth(%s) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x8:
			if ((hi_u32 & 0xf000f000) == 0x80001000) {
				// 1000IIIISSSSddddEE01iiiisssstttt | Rd = memw(RS+#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f000) == 0x90001000) {
				// 1001IIIISSSSddddEE01iiiisssstttt | Rd = memub(RS+#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f000) == 0x80000000) {
				// 1000IIIISSSSddddEE00iiiisssstttt | Rd = memw(RS+#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f000) == 0x90000000) {
				// 1001IIIISSSSddddEE00iiiisssstttt | Rd = memub(RS+#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x9:
			if ((hi_u32 & 0xfffff000) == 0x9f003000) {
				// 1001111100000000EE11iiiisssstttt | deallocframe ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s deallocframe ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f000) == 0x90003000) {
				// 10010IIISSSSddddEE11iiiisssstttt | Rd = memb(RS+#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x9e003000) {
				// 10011110IIIIIdddEE11iiiisssstttt | Rdd = memd(r29+#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f000) == 0x80003000) {
				// 10000IIISSSSddddEE11iiiisssstttt | Rd = memh(RS+#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00f000) == 0x9c003000) {
				// 1001110IIIIIddddEE11iiiisssstttt | Rd = memw(r29+#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f000) == 0x88003000) {
				// 10001IIISSSSddddEE11iiiisssstttt | Rd = memuh(RS+#II) ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f403000) {
				// 1001111101000000EE11iiiisssstttt | dealloc_return ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s dealloc_return ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f453000) {
				// 1001111101000101EE11iiiisssstttt | if (!p0) dealloc_return ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f473000) {
				// 1001111101000111EE11iiiisssstttt | if (!p0.new) dealloc_return:nt ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f443000) {
				// 1001111101000100EE11iiiisssstttt | if (p0) dealloc_return ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f463000) {
				// 1001111101000110EE11iiiisssstttt | if (p0.new) dealloc_return:nt ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f002000) {
				// 1001111100000000EE10iiiisssstttt | deallocframe ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s deallocframe ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f000) == 0x90002000) {
				// 10010IIISSSSddddEE10iiiisssstttt | Rd = memb(RS+#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f000) == 0x9e002000) {
				// 10011110IIIIIdddEE10iiiisssstttt | Rdd = memd(r29+#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f000) == 0x80002000) {
				// 10000IIISSSSddddEE10iiiisssstttt | Rd = memh(RS+#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00f000) == 0x9c002000) {
				// 1001110IIIIIddddEE10iiiisssstttt | Rd = memw(r29+#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f000) == 0x88002000) {
				// 10001IIISSSSddddEE10iiiisssstttt | Rd = memuh(RS+#II) ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f402000) {
				// 1001111101000000EE10iiiisssstttt | dealloc_return ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s dealloc_return ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f452000) {
				// 1001111101000101EE10iiiisssstttt | if (!p0) dealloc_return ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f472000) {
				// 1001111101000111EE10iiiisssstttt | if (!p0.new) dealloc_return:nt ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f442000) {
				// 1001111101000100EE10iiiisssstttt | if (p0) dealloc_return ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff000) == 0x9f462000) {
				// 1001111101000110EE10iiiisssstttt | if (p0.new) dealloc_return:nt ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xa:
			if ((hi_u32 & 0xf000f000) == 0xb0001000) {
				// 1011IIIISSSSTTTTEE01iiiisssstttt | memb(RS+#II) = RT ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f000) == 0xa0001000) {
				// 1010IIIISSSSTTTTEE01iiiisssstttt | memw(RS+#II) = RT ; memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS1_STOREB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f000) == 0xa0000000) {
				// 1010IIIISSSSTTTTEE00iiiisssstttt | memw(RS+#II) = RT ; memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS1_STOREW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf00) >> 8) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xb:
			if ((hi_u32 & 0xf000fe0f) == 0xb0003c00) {
				// 1011IIIIssssttttEE11110iiiii0000 | memb(Rs+#II) = Rt ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe0f) == 0xa0003c00) {
				// 1010IIIIssssttttEE11110iiiii0000 | memw(Rs+#II) = Rt ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xb0003200) {
				// 1011IIIISSSSttttEE110010ssssiiii | memb(RS+#II) = Rt ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xa0003200) {
				// 1010IIIISSSSttttEE110010ssssiiii | memw(RS+#II) = Rt ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xb0003300) {
				// 1011IIIISSSSttttEE110011ssssiiii | memb(RS+#II) = Rt ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xa0003300) {
				// 1010IIIISSSSttttEE110011ssssiiii | memw(RS+#II) = Rt ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0xb0002a00) {
				// 1011IIIIssssTTTTEE10101iiiiiittt | memb(Rs+#II) = RT ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0xa0002a00) {
				// 1010IIIIssssTTTTEE10101iiiiiittt | memw(Rs+#II) = RT ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0xb0002000) {
				// 1011IIIISSSSTTTTEE100iiisssstttt | memb(RS+#II) = RT ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0xa0002000) {
				// 1010IIIISSSSTTTTEE100iiisssstttt | memw(RS+#II) = RT ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0xb0002800) {
				// 1011IIIIssssTTTTEE10100iiiiitttt | memb(Rs+#II) = RT ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0xa0002800) {
				// 1010IIIIssssTTTTEE10100iiiiitttt | memw(Rs+#II) = RT ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xb0003000) {
				// 1011IIIISSSSttttEE110000ssssiiii | memb(RS+#II) = Rt ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xa0003000) {
				// 1010IIIISSSSttttEE110000ssssiiii | memw(RS+#II) = Rt ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xb0003100) {
				// 1011IIIISSSSttttEE110001ssssiiii | memb(RS+#II) = Rt ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREB_IO_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xa0003100) {
				// 1010IIIISSSSttttEE110001ssssiiii | memw(RS+#II) = Rt ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS1_STOREW_IO_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xc:
			if ((hi_u32 & 0xf000fe0f) == 0xc0001c00) {
				// 1100IIIIssssddddEE01110iiiii0000 | Rd = memw(Rs+#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe0f) == 0xd0001c00) {
				// 1101IIIIssssddddEE01110iiiii0000 | Rd = memub(Rs+#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xc0001200) {
				// 1100IIIISSSSddddEE010010ssssiiii | Rd = memw(RS+#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xd0001200) {
				// 1101IIIISSSSddddEE010010ssssiiii | Rd = memub(RS+#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xc0001300) {
				// 1100IIIISSSSddddEE010011ssssiiii | Rd = memw(RS+#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xd0001300) {
				// 1101IIIISSSSddddEE010011ssssiiii | Rd = memub(RS+#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0xc0000a00) {
				// 1100IIIIssssddddEE00101iiiiiittt | Rd = memw(Rs+#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0xd0000a00) {
				// 1101IIIIssssddddEE00101iiiiiittt | Rd = memub(Rs+#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0xc0000000) {
				// 1100IIIISSSSddddEE000iiisssstttt | Rd = memw(RS+#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000f800) == 0xd0000000) {
				// 1101IIIISSSSddddEE000iiisssstttt | Rd = memub(RS+#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0xc0000800) {
				// 1100IIIIssssddddEE00100iiiiitttt | Rd = memw(Rs+#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000fe00) == 0xd0000800) {
				// 1101IIIIssssddddEE00100iiiiitttt | Rd = memub(Rs+#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xc0001000) {
				// 1100IIIISSSSddddEE010000ssssiiii | Rd = memw(RS+#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xd0001000) {
				// 1101IIIISSSSddddEE010000ssssiiii | Rd = memub(RS+#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xc0001100) {
				// 1100IIIISSSSddddEE010001ssssiiii | Rd = memw(RS+#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRI_IO_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24) << 2; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(%s+#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf000ff00) == 0xd0001100) {
				// 1101IIIISSSSddddEE010001ssssiiii | Rd = memub(RS+#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL1_LOADRUB_IO_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memub(%s+#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xd:
			if ((hi_u32 & 0xfffffe0f) == 0xdf003c00) {
				// 1101111100000000EE11110iiiii0000 | deallocframe ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				sprintf(hi->mnem, "%s deallocframe ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe0f) == 0xd0003c00) {
				// 11010IIIssssddddEE11110iiiii0000 | Rd = memb(Rs+#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0xde003c00) {
				// 11011110IIIIIdddEE11110iiiii0000 | Rdd = memd(r29+#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe0f) == 0xc0003c00) {
				// 11000IIIssssddddEE11110iiiii0000 | Rd = memh(Rs+#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe0f) == 0xdc003c00) {
				// 1101110IIIIIddddEE11110iiiii0000 | Rd = memw(r29+#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe0f) == 0xc8003c00) {
				// 11001IIIssssddddEE11110iiiii0000 | Rd = memuh(Rs+#II) ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe0f) == 0xdf403c00) {
				// 1101111101000000EE11110iiiii0000 | dealloc_return ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				sprintf(hi->mnem, "%s dealloc_return ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe0f) == 0xdf453c00) {
				// 1101111101000101EE11110iiiii0000 | if (!p0) dealloc_return ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe0f) == 0xdf473c00) {
				// 1101111101000111EE11110iiiii0000 | if (!p0.new) dealloc_return:nt ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe0f) == 0xdf443c00) {
				// 1101111101000100EE11110iiiii0000 | if (p0) dealloc_return ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe0f) == 0xdf463c00) {
				// 1101111101000110EE11110iiiii0000 | if (p0.new) dealloc_return:nt ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf003200) {
				// 1101111100000000EE110010ssssiiii | deallocframe ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s deallocframe ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xd0003200) {
				// 11010IIISSSSddddEE110010ssssiiii | Rd = memb(RS+#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xde003200) {
				// 11011110IIIIIdddEE110010ssssiiii | Rdd = memd(r29+#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xc0003200) {
				// 11000IIISSSSddddEE110010ssssiiii | Rd = memh(RS+#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xdc003200) {
				// 1101110IIIIIddddEE110010ssssiiii | Rd = memw(r29+#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xc8003200) {
				// 11001IIISSSSddddEE110010ssssiiii | Rd = memuh(RS+#II) ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf403200) {
				// 1101111101000000EE110010ssssiiii | dealloc_return ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s dealloc_return ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf453200) {
				// 1101111101000101EE110010ssssiiii | if (!p0) dealloc_return ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf473200) {
				// 1101111101000111EE110010ssssiiii | if (!p0.new) dealloc_return:nt ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf443200) {
				// 1101111101000100EE110010ssssiiii | if (p0) dealloc_return ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf463200) {
				// 1101111101000110EE110010ssssiiii | if (p0.new) dealloc_return:nt ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf003300) {
				// 1101111100000000EE110011ssssiiii | deallocframe ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s deallocframe ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xd0003300) {
				// 11010IIISSSSddddEE110011ssssiiii | Rd = memb(RS+#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xde003300) {
				// 11011110IIIIIdddEE110011ssssiiii | Rdd = memd(r29+#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xc0003300) {
				// 11000IIISSSSddddEE110011ssssiiii | Rd = memh(RS+#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xdc003300) {
				// 1101110IIIIIddddEE110011ssssiiii | Rd = memw(r29+#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xc8003300) {
				// 11001IIISSSSddddEE110011ssssiiii | Rd = memuh(RS+#II) ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf403300) {
				// 1101111101000000EE110011ssssiiii | dealloc_return ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s dealloc_return ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf453300) {
				// 1101111101000101EE110011ssssiiii | if (!p0) dealloc_return ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf473300) {
				// 1101111101000111EE110011ssssiiii | if (!p0.new) dealloc_return:nt ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf443300) {
				// 1101111101000100EE110011ssssiiii | if (p0) dealloc_return ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf463300) {
				// 1101111101000110EE110011ssssiiii | if (p0.new) dealloc_return:nt ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf002a00) {
				// 1101111100000000EE10101iiiiiittt | deallocframe ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s deallocframe ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0xd0002a00) {
				// 11010IIIssssddddEE10101iiiiiittt | Rd = memb(Rs+#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0xde002a00) {
				// 11011110IIIIIdddEE10101iiiiiittt | Rdd = memd(r29+#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0xc0002a00) {
				// 11000IIIssssddddEE10101iiiiiittt | Rd = memh(Rs+#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe00) == 0xdc002a00) {
				// 1101110IIIIIddddEE10101iiiiiittt | Rd = memw(r29+#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0xc8002a00) {
				// 11001IIIssssddddEE10101iiiiiittt | Rd = memuh(Rs+#II) ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf402a00) {
				// 1101111101000000EE10101iiiiiittt | dealloc_return ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s dealloc_return ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf452a00) {
				// 1101111101000101EE10101iiiiiittt | if (!p0) dealloc_return ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf472a00) {
				// 1101111101000111EE10101iiiiiittt | if (!p0.new) dealloc_return:nt ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf442a00) {
				// 1101111101000100EE10101iiiiiittt | if (p0) dealloc_return ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf462a00) {
				// 1101111101000110EE10101iiiiiittt | if (p0.new) dealloc_return:nt ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff800) == 0xdf002000) {
				// 1101111100000000EE100iiisssstttt | deallocframe ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s deallocframe ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0xd0002000) {
				// 11010IIISSSSddddEE100iiisssstttt | Rd = memb(RS+#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00f800) == 0xde002000) {
				// 11011110IIIIIdddEE100iiisssstttt | Rdd = memd(r29+#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0xc0002000) {
				// 11000IIISSSSddddEE100iiisssstttt | Rd = memh(RS+#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00f800) == 0xdc002000) {
				// 1101110IIIIIddddEE100iiisssstttt | Rd = memw(r29+#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0xc8002000) {
				// 11001IIISSSSddddEE100iiisssstttt | Rd = memuh(RS+#II) ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff800) == 0xdf402000) {
				// 1101111101000000EE100iiisssstttt | dealloc_return ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s dealloc_return ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff800) == 0xdf452000) {
				// 1101111101000101EE100iiisssstttt | if (!p0) dealloc_return ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff800) == 0xdf472000) {
				// 1101111101000111EE100iiisssstttt | if (!p0.new) dealloc_return:nt ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff800) == 0xdf442000) {
				// 1101111101000100EE100iiisssstttt | if (p0) dealloc_return ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffff800) == 0xdf462000) {
				// 1101111101000110EE100iiisssstttt | if (p0.new) dealloc_return:nt ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf002800) {
				// 1101111100000000EE10100iiiiitttt | deallocframe ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s deallocframe ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0xd0002800) {
				// 11010IIIssssddddEE10100iiiiitttt | Rd = memb(Rs+#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe00) == 0xde002800) {
				// 11011110IIIIIdddEE10100iiiiitttt | Rdd = memd(r29+#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0xc0002800) {
				// 11000IIIssssddddEE10100iiiiitttt | Rd = memh(Rs+#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe00) == 0xdc002800) {
				// 1101110IIIIIddddEE10100iiiiitttt | Rd = memw(r29+#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0xc8002800) {
				// 11001IIIssssddddEE10100iiiiitttt | Rd = memuh(Rs+#II) ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf402800) {
				// 1101111101000000EE10100iiiiitttt | dealloc_return ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s dealloc_return ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf452800) {
				// 1101111101000101EE10100iiiiitttt | if (!p0) dealloc_return ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf472800) {
				// 1101111101000111EE10100iiiiitttt | if (!p0.new) dealloc_return:nt ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf442800) {
				// 1101111101000100EE10100iiiiitttt | if (p0) dealloc_return ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffffe00) == 0xdf462800) {
				// 1101111101000110EE10100iiiiitttt | if (p0.new) dealloc_return:nt ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf003000) {
				// 1101111100000000EE110000ssssiiii | deallocframe ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s deallocframe ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xd0003000) {
				// 11010IIISSSSddddEE110000ssssiiii | Rd = memb(RS+#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xde003000) {
				// 11011110IIIIIdddEE110000ssssiiii | Rdd = memd(r29+#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xc0003000) {
				// 11000IIISSSSddddEE110000ssssiiii | Rd = memh(RS+#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xdc003000) {
				// 1101110IIIIIddddEE110000ssssiiii | Rd = memw(r29+#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xc8003000) {
				// 11001IIISSSSddddEE110000ssssiiii | Rd = memuh(RS+#II) ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf403000) {
				// 1101111101000000EE110000ssssiiii | dealloc_return ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s dealloc_return ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf453000) {
				// 1101111101000101EE110000ssssiiii | if (!p0) dealloc_return ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf473000) {
				// 1101111101000111EE110000ssssiiii | if (!p0.new) dealloc_return:nt ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf443000) {
				// 1101111101000100EE110000ssssiiii | if (p0) dealloc_return ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf463000) {
				// 1101111101000110EE110000ssssiiii | if (p0.new) dealloc_return:nt ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf003100) {
				// 1101111100000000EE110001ssssiiii | deallocframe ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_DEALLOCFRAME_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s deallocframe ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xd0003100) {
				// 11010IIISSSSddddEE110001ssssiiii | Rd = memb(RS+#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRB_IO_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24); // II
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memb(%s+#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xde003100) {
				// 11011110IIIIIdddEE110001ssssiiii | Rdd = memd(r29+#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRD_SP_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Rdd8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf80000) >> 19) << 3; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = memd(R29+#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_double_low8_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xc0003100) {
				// 11000IIISSSSddddEE110001ssssiiii | Rd = memh(RS+#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRH_IO_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memh(%s+#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xdc003100) {
				// 1101110IIIIIddddEE110001ssssiiii | Rd = memw(r29+#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRI_SP_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(R29+#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xc8003100) {
				// 11001IIISSSSddddEE110001ssssiiii | Rd = memuh(RS+#II) ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_LOADRUH_IO_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s %s = memuh(%s+#0x%x) ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf403100) {
				// 1101111101000000EE110001ssssiiii | dealloc_return ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s dealloc_return ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf453100) {
				// 1101111101000101EE110001ssssiiii | if (!p0) dealloc_return ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_F_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s if (!P0) dealloc_return ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf473100) {
				// 1101111101000111EE110001ssssiiii | if (!p0.new) dealloc_return:nt ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_FNEW_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s if (!P0.new) dealloc_return:nt ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf443100) {
				// 1101111101000100EE110001ssssiiii | if (p0) dealloc_return ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_T_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s if (P0) dealloc_return ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffffff00) == 0xdf463100) {
				// 1101111101000110EE110001ssssiiii | if (p0.new) dealloc_return:nt ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SL2_RETURN_TNEW_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s if (P0.new) dealloc_return:nt ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xe:
			if ((hi_u32 & 0xff00fe0f) == 0xf2001c00) {
				// 11110010ssssIIIIEE01110iiiii0000 | memb(Rs+#II) = #0 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREBI0_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = #0 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0xf3001c00) {
				// 11110011ssssIIIIEE01110iiiii0000 | memb(Rs+#II) = #1 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREBI1_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = #1 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe0f) == 0xea001c00) {
				// 1110101IIIIIItttEE01110iiiii0000 | memd(r29+#II) = Rtt ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STORED_SP_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f80000) >> 19) << 3; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Rtt8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s memd(R29+%s) = %s ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe0f) == 0xe0001c00) {
				// 11100IIIssssttttEE01110iiiii0000 | memh(Rs+#II) = Rt ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREH_IO_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe0f) == 0xe8001c00) {
				// 1110100IIIIIttttEE01110iiiii0000 | memw(r29+#II) = Rt ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREW_SP_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s memw(R29+#0x%x) = %s ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0xf0001c00) {
				// 11110000ssssIIIIEE01110iiiii0000 | memw(Rs+#II) = #0 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI0_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #0 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00fe0f) == 0xf1001c00) {
				// 11110001ssssIIIIEE01110iiiii0000 | memw(Rs+#II) = #1 ; allocframe(#Ii)
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI1_SS2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #1 ; allocframe(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf2001200) {
				// 11110010SSSSIIIIEE010010ssssiiii | memb(RS+#II) = #0 ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREBI0_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = #0 ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xea001200) {
				// 1110101IIIIIItttEE010010ssssiiii | memd(r29+#II) = Rtt ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STORED_SP_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f80000) >> 19) << 3; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Rtt8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memd(R29+%s) = %s ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xe0001200) {
				// 11100IIISSSSttttEE010010ssssiiii | memh(RS+#II) = Rt ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREH_IO_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xe8001200) {
				// 1110100IIIIIttttEE010010ssssiiii | memw(r29+#II) = Rt ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREW_SP_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memw(R29+#0x%x) = %s ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf0001200) {
				// 11110000SSSSIIIIEE010010ssssiiii | memw(RS+#II) = #0 ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI0_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #0 ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf1001200) {
				// 11110001SSSSIIIIEE010010ssssiiii | memw(RS+#II) = #1 ; memb(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI1_SS2_STOREBI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #1 ; memb(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf2001300) {
				// 11110010SSSSIIIIEE010011ssssiiii | memb(RS+#II) = #0 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREBI0_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = #0 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf3001300) {
				// 11110011SSSSIIIIEE010011ssssiiii | memb(RS+#II) = #1 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREBI1_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16); // II
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = #1 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xea001300) {
				// 1110101IIIIIItttEE010011ssssiiii | memd(r29+#II) = Rtt ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STORED_SP_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f80000) >> 19) << 3; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Rtt8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memd(R29+%s) = %s ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xe0001300) {
				// 11100IIISSSSttttEE010011ssssiiii | memh(RS+#II) = Rt ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREH_IO_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xe8001300) {
				// 1110100IIIIIttttEE010011ssssiiii | memw(r29+#II) = Rt ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREW_SP_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memw(R29+#0x%x) = %s ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf0001300) {
				// 11110000SSSSIIIIEE010011ssssiiii | memw(RS+#II) = #0 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI0_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #0 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf1001300) {
				// 11110001SSSSIIIIEE010011ssssiiii | memw(RS+#II) = #1 ; memb(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI1_SS2_STOREBI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0); // Ii
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #1 ; memb(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe00) == 0xea000a00) {
				// 1110101IIIIIITTTEE00101iiiiiittt | memd(r29+#II) = RTT ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STORED_SP_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f80000) >> 19) << 3; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // RTT8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s memd(R29+%s) = %s ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0xe0000a00) {
				// 11100IIIssssTTTTEE00101iiiiiittt | memh(Rs+#II) = RT ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREH_IO_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 8)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe00) == 0xe8000a00) {
				// 1110100IIIIITTTTEE00101iiiiiittt | memw(r29+#II) = RT ; memd(r29+#Ii) = Rtt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREW_SP_SS2_STORED_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f8) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 8)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Rtt8
				sprintf(hi->mnem, "%s memw(R29+#0x%x) = %s ; memd(R29+%s) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), signed_imm, hex_get_general_double_low8_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800f800) == 0xe0000000) {
				// 11100IIISSSSTTTTEE000iiisssstttt | memh(RS+#II) = RT ; memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREH_IO_SS2_STOREH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 6;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0x700) >> 8) << 1; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 1;
				hi->ops[5].type = HEX_OP_TYPE_REG;
				hi->ops[5].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s ; memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_general_sub_regs(hi->ops[5].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800fe00) == 0xe0000800) {
				// 11100IIIssssTTTTEE00100iiiiitttt | memh(Rs+#II) = RT ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREH_IO_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_general_sub_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00fe00) == 0xe8000800) {
				// 1110100IIIIITTTTEE00100iiiiitttt | memw(r29+#II) = RT ; memw(r29+#Ii) = Rt
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREW_SP_SS2_STOREW_SP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // RT16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f0) >> 4) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf) >> 0); // Rt16
				sprintf(hi->mnem, "%s memw(R29+#0x%x) = %s ; memw(R29+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_general_sub_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xea001000) {
				// 1110101IIIIIItttEE010000ssssiiii | memd(r29+#II) = Rtt ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STORED_SP_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f80000) >> 19) << 3; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Rtt8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s memd(R29+%s) = %s ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xe0001000) {
				// 11100IIISSSSttttEE010000ssssiiii | memh(RS+#II) = Rt ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREH_IO_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xe8001000) {
				// 1110100IIIIIttttEE010000ssssiiii | memw(r29+#II) = Rt ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREW_SP_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s memw(R29+#0x%x) = %s ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf0001000) {
				// 11110000SSSSIIIIEE010000ssssiiii | memw(RS+#II) = #0 ; memw(Rs+#Ii) = #0
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI0_SS2_STOREWI0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #0 ; memw(%s+#0x%x) = #0 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xea001100) {
				// 1110101IIIIIItttEE010001ssssiiii | memd(r29+#II) = Rtt ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STORED_SP_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f80000) >> 19) << 3; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				if (((st32)hi->ops[0].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[0].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[0].op.imm);
				}
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Rtt8
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s memd(R29+%s) = %s ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, signed_imm, hex_get_general_double_low8_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf800ff00) == 0xe0001100) {
				// 11100IIISSSSttttEE010001ssssiiii | memh(RS+#II) = Rt ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREH_IO_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7000000) >> 24) << 1; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[4].attr = HEX_OP_IMM_SCALED;
				hi->ops[4].shift = 2;
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hex_get_general_sub_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe00ff00) == 0xe8001100) {
				// 1110100IIIIIttttEE010001ssssiiii | memw(r29+#II) = Rt ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREW_SP_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x1f00000) >> 20) << 2; // scaled II
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s memw(R29+#0x%x) = %s ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_general_sub_regs(hi->ops[1].op.reg), hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf0001100) {
				// 11110000SSSSIIIIEE010001ssssiiii | memw(RS+#II) = #0 ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI0_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #0 ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff00ff00) == 0xf1001100) {
				// 11110001SSSSIIIIEE010001ssssiiii | memw(RS+#II) = #1 ; memw(Rs+#Ii) = #1
				hi->instruction = HEX_INS_X2_AUTOJOIN_SS2_STOREWI1_SS2_STOREWI1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->duplex = true;
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00000) >> 20); // RS16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0xf0000) >> 16) << 2; // scaled II
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf0) >> 4); // Rs16
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xf) >> 0) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = #1 ; memw(%s+#0x%x) = #1 %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_general_sub_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		}
	} else {
		switch ((hi_u32 >> 28) & 0xF) {
		case 0x0:
			if ((hi_u32 & 0xf0000000) == 0x0) {
				// 0000iiiiiiiiiiiiPPiiiiiiiiiiiiii | immext(#Ii)
				hi->instruction = HEX_INS_A4_EXT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0xfff0000) >> 2) | (((hi_u32)&0x3fff) >> 0)) << 6; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 6;
				sprintf(hi->mnem, "%s immext(##0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				hex_op_extend(&(hi->ops[0]), true);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0x0) {
				// 0000000000000000PP00000000000000 | <invalid>
				hi->instruction = HEX_INS_INVALID_DECODE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s <invalid> %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x1:
			if ((hi_u32 & 0xffc03001) == 0x14400000) {
				// 0001010001iissssPP00ttttiiiiiii0 | p0 = cmp.eq(Rs,Rt); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQ_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,%s); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14402000) {
				// 0001010001iissssPP10ttttiiiiiii0 | p0 = cmp.eq(Rs,Rt); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQ_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,%s); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14401000) {
				// 0001010001iissssPP01ttttiiiiiii0 | p1 = cmp.eq(Rs,Rt); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQ_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,%s); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14403000) {
				// 0001010001iissssPP11ttttiiiiiii0 | p1 = cmp.eq(Rs,Rt); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQ_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,%s); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14000000) {
				// 0001010000iissssPP00ttttiiiiiii0 | p0 = cmp.eq(Rs,Rt); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQ_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,%s); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14002000) {
				// 0001010000iissssPP10ttttiiiiiii0 | p0 = cmp.eq(Rs,Rt); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQ_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,%s); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14001000) {
				// 0001010000iissssPP01ttttiiiiiii0 | p1 = cmp.eq(Rs,Rt); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQ_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,%s); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14003000) {
				// 0001010000iissssPP11ttttiiiiiii0 | p1 = cmp.eq(Rs,Rt); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQ_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,%s); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x10400000) {
				// 0001000001iissssPP0IIIIIiiiiiii0 | p0 = cmp.eq(Rs,#II); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQI_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x10402000) {
				// 0001000001iissssPP1IIIIIiiiiiii0 | p0 = cmp.eq(Rs,#II); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQI_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x12400000) {
				// 0001001001iissssPP0IIIIIiiiiiii0 | p1 = cmp.eq(Rs,#II); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQI_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,#0x%x); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x12402000) {
				// 0001001001iissssPP1IIIIIiiiiiii0 | p1 = cmp.eq(Rs,#II); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQI_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,#0x%x); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x10000000) {
				// 0001000000iissssPP0IIIIIiiiiiii0 | p0 = cmp.eq(Rs,#II); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQI_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x10002000) {
				// 0001000000iissssPP1IIIIIiiiiiii0 | p0 = cmp.eq(Rs,#II); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQI_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#0x%x); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x12000000) {
				// 0001001000iissssPP0IIIIIiiiiiii0 | p1 = cmp.eq(Rs,#II); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQI_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,#0x%x); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x12002000) {
				// 0001001000iissssPP1IIIIIiiiiiii0 | p1 = cmp.eq(Rs,#II); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQI_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,#0x%x); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11c00000) {
				// 0001000111iissssPP000000iiiiiii0 | p0 = cmp.eq(Rs,#n1); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#-1); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11c02000) {
				// 0001000111iissssPP100000iiiiiii0 | p0 = cmp.eq(Rs,#n1); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#-1); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13c00000) {
				// 0001001111iissssPP000000iiiiiii0 | p1 = cmp.eq(Rs,#n1); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,#-1); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13c02000) {
				// 0001001111iissssPP100000iiiiiii0 | p1 = cmp.eq(Rs,#n1); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,#-1); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11800000) {
				// 0001000110iissssPP000000iiiiiii0 | p0 = cmp.eq(Rs,#n1); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#-1); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11802000) {
				// 0001000110iissssPP100000iiiiiii0 | p0 = cmp.eq(Rs,#n1); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.eq(%s,#-1); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13800000) {
				// 0001001110iissssPP000000iiiiiii0 | p1 = cmp.eq(Rs,#n1); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,#-1); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13802000) {
				// 0001001110iissssPP100000iiiiiii0 | p1 = cmp.eq(Rs,#n1); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.eq(%s,#-1); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14c00000) {
				// 0001010011iissssPP00ttttiiiiiii0 | p0 = cmp.gt(Rs,Rt); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGT_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,%s); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14c02000) {
				// 0001010011iissssPP10ttttiiiiiii0 | p0 = cmp.gt(Rs,Rt); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGT_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,%s); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14c01000) {
				// 0001010011iissssPP01ttttiiiiiii0 | p1 = cmp.gt(Rs,Rt); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGT_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,%s); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14c03000) {
				// 0001010011iissssPP11ttttiiiiiii0 | p1 = cmp.gt(Rs,Rt); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGT_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,%s); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14800000) {
				// 0001010010iissssPP00ttttiiiiiii0 | p0 = cmp.gt(Rs,Rt); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGT_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,%s); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14802000) {
				// 0001010010iissssPP10ttttiiiiiii0 | p0 = cmp.gt(Rs,Rt); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGT_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,%s); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14801000) {
				// 0001010010iissssPP01ttttiiiiiii0 | p1 = cmp.gt(Rs,Rt); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGT_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,%s); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x14803000) {
				// 0001010010iissssPP11ttttiiiiiii0 | p1 = cmp.gt(Rs,Rt); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGT_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,%s); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x10c00000) {
				// 0001000011iissssPP0IIIIIiiiiiii0 | p0 = cmp.gt(Rs,#II); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTI_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,#0x%x); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x10c02000) {
				// 0001000011iissssPP1IIIIIiiiiiii0 | p0 = cmp.gt(Rs,#II); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTI_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,#0x%x); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x12c00000) {
				// 0001001011iissssPP0IIIIIiiiiiii0 | p1 = cmp.gt(Rs,#II); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTI_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,#0x%x); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x12c02000) {
				// 0001001011iissssPP1IIIIIiiiiiii0 | p1 = cmp.gt(Rs,#II); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTI_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,#0x%x); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x10800000) {
				// 0001000010iissssPP0IIIIIiiiiiii0 | p0 = cmp.gt(Rs,#II); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTI_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,#0x%x); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x10802000) {
				// 0001000010iissssPP1IIIIIiiiiiii0 | p0 = cmp.gt(Rs,#II); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTI_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,#0x%x); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x12800000) {
				// 0001001010iissssPP0IIIIIiiiiiii0 | p1 = cmp.gt(Rs,#II); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTI_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,#0x%x); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x12802000) {
				// 0001001010iissssPP1IIIIIiiiiiii0 | p1 = cmp.gt(Rs,#II); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTI_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,#0x%x); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11c00100) {
				// 0001000111iissssPP000001iiiiiii0 | p0 = cmp.gt(Rs,#n1); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,#-1); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11c02100) {
				// 0001000111iissssPP100001iiiiiii0 | p0 = cmp.gt(Rs,#n1); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,#-1); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13c00100) {
				// 0001001111iissssPP000001iiiiiii0 | p1 = cmp.gt(Rs,#n1); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,#-1); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13c02100) {
				// 0001001111iissssPP100001iiiiiii0 | p1 = cmp.gt(Rs,#n1); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,#-1); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11800100) {
				// 0001000110iissssPP000001iiiiiii0 | p0 = cmp.gt(Rs,#n1); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,#-1); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11802100) {
				// 0001000110iissssPP100001iiiiiii0 | p0 = cmp.gt(Rs,#n1); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gt(%s,#-1); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13800100) {
				// 0001001110iissssPP000001iiiiiii0 | p1 = cmp.gt(Rs,#n1); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,#-1); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13802100) {
				// 0001001110iissssPP100001iiiiiii0 | p1 = cmp.gt(Rs,#n1); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gt(%s,#-1); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x15400000) {
				// 0001010101iissssPP00ttttiiiiiii0 | p0 = cmp.gtu(Rs,Rt); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTU_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gtu(%s,%s); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x15402000) {
				// 0001010101iissssPP10ttttiiiiiii0 | p0 = cmp.gtu(Rs,Rt); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTU_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gtu(%s,%s); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x15401000) {
				// 0001010101iissssPP01ttttiiiiiii0 | p1 = cmp.gtu(Rs,Rt); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTU_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gtu(%s,%s); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x15403000) {
				// 0001010101iissssPP11ttttiiiiiii0 | p1 = cmp.gtu(Rs,Rt); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTU_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gtu(%s,%s); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x15000000) {
				// 0001010100iissssPP00ttttiiiiiii0 | p0 = cmp.gtu(Rs,Rt); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTU_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gtu(%s,%s); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x15002000) {
				// 0001010100iissssPP10ttttiiiiiii0 | p0 = cmp.gtu(Rs,Rt); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTU_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gtu(%s,%s); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x15001000) {
				// 0001010100iissssPP01ttttiiiiiii0 | p1 = cmp.gtu(Rs,Rt); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTU_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gtu(%s,%s); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x15003000) {
				// 0001010100iissssPP11ttttiiiiiii0 | p1 = cmp.gtu(Rs,Rt); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTU_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf00) >> 8); // Rt16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gtu(%s,%s); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x11400000) {
				// 0001000101iissssPP0IIIIIiiiiiii0 | p0 = cmp.gtu(Rs,#II); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gtu(%s,#0x%x); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x11402000) {
				// 0001000101iissssPP1IIIIIiiiiiii0 | p0 = cmp.gtu(Rs,#II); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gtu(%s,#0x%x); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x13400000) {
				// 0001001101iissssPP0IIIIIiiiiiii0 | p1 = cmp.gtu(Rs,#II); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gtu(%s,#0x%x); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x13402000) {
				// 0001001101iissssPP1IIIIIiiiiiii0 | p1 = cmp.gtu(Rs,#II); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gtu(%s,#0x%x); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x11000000) {
				// 0001000100iissssPP0IIIIIiiiiiii0 | p0 = cmp.gtu(Rs,#II); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gtu(%s,#0x%x); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x11002000) {
				// 0001000100iissssPP1IIIIIiiiiiii0 | p0 = cmp.gtu(Rs,#II); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = cmp.gtu(%s,#0x%x); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x13000000) {
				// 0001001100iissssPP0IIIIIiiiiiii0 | p1 = cmp.gtu(Rs,#II); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gtu(%s,#0x%x); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc02001) == 0x13002000) {
				// 0001001100iissssPP1IIIIIiiiiiii0 | p1 = cmp.gtu(Rs,#II); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = cmp.gtu(%s,#0x%x); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00001) == 0x16000000) {
				// 0001011000iiddddPPIIIIIIiiiiiii0 | Rd = #II ; jump Ii
				hi->instruction = HEX_INS_J4_JUMPSETI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = #0x%x ; jump 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03001) == 0x17000000) {
				// 0001011100iissssPP00ddddiiiiiii0 | Rd = Rs ; jump Ii
				hi->instruction = HEX_INS_J4_JUMPSETR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf00) >> 8); // Rd16
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = %s ; jump 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), hex_get_general_sub_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11c00300) {
				// 0001000111iissssPP000011iiiiiii0 | p0 = tstbit(Rs,#0); if (!p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_FP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = tstbit(%s,#0); if (!P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11c02300) {
				// 0001000111iissssPP100011iiiiiii0 | p0 = tstbit(Rs,#0); if (!p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_FP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = tstbit(%s,#0); if (!P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13c00300) {
				// 0001001111iissssPP000011iiiiiii0 | p1 = tstbit(Rs,#0); if (!p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_FP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = tstbit(%s,#0); if (!P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13c02300) {
				// 0001001111iissssPP100011iiiiiii0 | p1 = tstbit(Rs,#0); if (!p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_FP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = tstbit(%s,#0); if (!P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11800300) {
				// 0001000110iissssPP000011iiiiiii0 | p0 = tstbit(Rs,#0); if (p0.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_TP0_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = tstbit(%s,#0); if (P0.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x11802300) {
				// 0001000110iissssPP100011iiiiiii0 | p0 = tstbit(Rs,#0); if (p0.new) jump:t Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_TP0_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s P0 = tstbit(%s,#0); if (P0.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13800300) {
				// 0001001110iissssPP000011iiiiiii0 | p1 = tstbit(Rs,#0); if (p1.new) jump:nt Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_TP1_JUMP_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = tstbit(%s,#0); if (P1.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc03f01) == 0x13802300) {
				// 0001001110iissssPP100011iiiiiii0 | p1 = tstbit(Rs,#0); if (p1.new) jump:t Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_TP1_JUMP_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xf0000) >> 16); // Rs16
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s P1 = tstbit(%s,#0); if (P1.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_general_sub_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x19c00040) {
				// 00011001110tttttPP000000010ddddd | Vd.b = vsplat(Rt)
				hi->instruction = HEX_INS_V6_LVSPLATB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.b = vsplat(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x19c00020) {
				// 00011001110tttttPP000000001ddddd | Vd.h = vsplat(Rt)
				hi->instruction = HEX_INS_V6_LVSPLATH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vsplat(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x19a00020) {
				// 00011001101tttttPP000000001ddddd | Vd = vsplat(Rt)
				hi->instruction = HEX_INS_V6_LVSPLATW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s = vsplat(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3cfc) == 0x1e030000) {
				// 00011110tt000011PP0000ss000000dd | Qd = and(Qs,Qt)
				hi->instruction = HEX_INS_V6_PRED_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qs4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xc00000) >> 22); // Qt4
				sprintf(hi->mnem, "%s %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3cfc) == 0x1e030014) {
				// 00011110tt000011PP0000ss000101dd | Qd = and(Qs,!Qt)
				hi->instruction = HEX_INS_V6_PRED_AND_N;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qs4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xc00000) >> 22); // Qt4
				sprintf(hi->mnem, "%s %s = and(%s,!%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3cfc) == 0x1e030008) {
				// 0001111000000011PP0000ss000010dd | Qd = not(Qs)
				hi->instruction = HEX_INS_V6_PRED_NOT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qs4
				sprintf(hi->mnem, "%s %s = not(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3cfc) == 0x1e030004) {
				// 00011110tt000011PP0000ss000001dd | Qd = or(Qs,Qt)
				hi->instruction = HEX_INS_V6_PRED_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qs4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xc00000) >> 22); // Qt4
				sprintf(hi->mnem, "%s %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3cfc) == 0x1e030010) {
				// 00011110tt000011PP0000ss000100dd | Qd = or(Qs,!Qt)
				hi->instruction = HEX_INS_V6_PRED_OR_N;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qs4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xc00000) >> 22); // Qt4
				sprintf(hi->mnem, "%s %s = or(%s,!%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ffc) == 0x19a00044) {
				// 00011001101tttttPP000000010001dd | Qd = vsetq(Rt)
				hi->instruction = HEX_INS_V6_PRED_SCALAR2;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s = vsetq(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ffc) == 0x19a0004c) {
				// 00011001101tttttPP000000010011dd | Qd = vsetq2(Rt)
				hi->instruction = HEX_INS_V6_PRED_SCALAR2V2;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s = vsetq2(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3cfc) == 0x1e03000c) {
				// 00011110tt000011PP0000ss000011dd | Qd = xor(Qs,Qt)
				hi->instruction = HEX_INS_V6_PRED_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qs4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xc00000) >> 22); // Qt4
				sprintf(hi->mnem, "%s %s = xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3cfc) == 0x1e030018) {
				// 00011110tt000011PP0000ss000110dd | Qd.b = vshuffe(Qs.h,Qt.h)
				hi->instruction = HEX_INS_V6_SHUFFEQH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qs4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xc00000) >> 22); // Qt4
				sprintf(hi->mnem, "%s %s.b = vshuffe(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3cfc) == 0x1e03001c) {
				// 00011110tt000011PP0000ss000111dd | Qd.h = vshuffe(Qs.w,Qt.w)
				hi->instruction = HEX_INS_V6_SHUFFEQW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qs4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xc00000) >> 22); // Qt4
				sprintf(hi->mnem, "%s %s.h = vshuffe(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1f402080) {
				// 00011111010vvvvvPP1uuuuu1iiddddd | Vdd.w = v6mpy(Vuu.ub,Vvv.b,#Ii):h
				hi->instruction = HEX_INS_V6_V6MPYHUBS10;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.w = V6mpy(%s.ub,%s.b,#0x%x):h %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1f202080) {
				// 00011111001vvvvvPP1uuuuu1iixxxxx | Vxx.w += v6mpy(Vuu.ub,Vvv.b,#Ii):h
				hi->instruction = HEX_INS_V6_V6MPYHUBS10_VXX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.w += V6mpy(%s.ub,%s.b,#0x%x):h %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1f402000) {
				// 00011111010vvvvvPP1uuuuu0iiddddd | Vdd.w = v6mpy(Vuu.ub,Vvv.b,#Ii):v
				hi->instruction = HEX_INS_V6_V6MPYVUBS10;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.w = V6mpy(%s.ub,%s.b,#0x%x):v %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1f202000) {
				// 00011111001vvvvvPP1uuuuu0iixxxxx | Vxx.w += v6mpy(Vuu.ub,Vvv.b,#Ii):v
				hi->instruction = HEX_INS_V6_V6MPYVUBS10_VXX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x60) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.w += V6mpy(%s.ub,%s.b,#0x%x):v %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e010080) {
				// 0001111000000001PP0uuuuu100ddddd | Vd.b = vabs(Vu.b)
				hi->instruction = HEX_INS_V6_VABSB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.b = vabs(%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0100a0) {
				// 0001111000000001PP0uuuuu101ddddd | Vd.b = vabs(Vu.b):sat
				hi->instruction = HEX_INS_V6_VABSB_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.b = vabs(%s.b):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1cc00020) {
				// 00011100110vvvvvPP0uuuuu001ddddd | Vd.uh = vabsdiff(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VABSDIFFH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vabsdiff(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1cc00000) {
				// 00011100110vvvvvPP0uuuuu000ddddd | Vd.ub = vabsdiff(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VABSDIFFUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vabsdiff(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1cc00040) {
				// 00011100110vvvvvPP0uuuuu010ddddd | Vd.uh = vabsdiff(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VABSDIFFUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vabsdiff(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1cc00060) {
				// 00011100110vvvvvPP0uuuuu011ddddd | Vd.uw = vabsdiff(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VABSDIFFW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw = vabsdiff(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e000000) {
				// 0001111000000000PP0uuuuu000ddddd | Vd.h = vabs(Vu.h)
				hi->instruction = HEX_INS_V6_VABSH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h = vabs(%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e000020) {
				// 0001111000000000PP0uuuuu001ddddd | Vd.h = vabs(Vu.h):sat
				hi->instruction = HEX_INS_V6_VABSH_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h = vabs(%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e000040) {
				// 0001111000000000PP0uuuuu010ddddd | Vd.w = vabs(Vu.w)
				hi->instruction = HEX_INS_V6_VABSW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vabs(%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e000060) {
				// 0001111000000000PP0uuuuu011ddddd | Vd.w = vabs(Vu.w):sat
				hi->instruction = HEX_INS_V6_VABSW_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vabs(%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fa000c0) {
				// 00011111101vvvvvPP0uuuuu110ddddd | Vd.b = vadd(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VADDB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vadd(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c600080) {
				// 00011100011vvvvvPP0uuuuu100ddddd | Vdd.b = vadd(Vuu.b,Vvv.b)
				hi->instruction = HEX_INS_V6_VADDB_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.b = vadd(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e012060) {
				// 00011110vv000001PP1uuuuu011xxxxx | if (!Qv) Vx.b += Vu.b
				hi->instruction = HEX_INS_V6_VADDBNQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (!%s) %s.b += %s.b %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e012000) {
				// 00011110vv000001PP1uuuuu000xxxxx | if (Qv) Vx.b += Vu.b
				hi->instruction = HEX_INS_V6_VADDBQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (%s) %s.b += %s.b %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f000000) {
				// 00011111000vvvvvPP0uuuuu000ddddd | Vd.b = vadd(Vu.b,Vv.b):sat
				hi->instruction = HEX_INS_V6_VADDBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vadd(%s.b,%s.b):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ea00000) {
				// 00011110101vvvvvPP0uuuuu000ddddd | Vdd.b = vadd(Vuu.b,Vvv.b):sat
				hi->instruction = HEX_INS_V6_VADDBSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.b = vadd(%s.b,%s.b):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1ca02000) {
				// 00011100101vvvvvPP1uuuuu0xxddddd | Vd.w = vadd(Vu.w,Vv.w,Qx):carry
				hi->instruction = HEX_INS_V6_VADDCARRY;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x60) >> 5); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vadd(%s.w,%s.w,%s):carry %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[3].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1da02000) {
				// 00011101101vvvvvPP1uuuuu0eeddddd | Vd.w,Qe = vadd(Vu.w,Vv.w):carry
				hi->instruction = HEX_INS_V6_VADDCARRYO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Qe4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w,%s = vadd(%s.w,%s.w):carry %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1d802000) {
				// 00011101100vvvvvPP1uuuuu0ssddddd | Vd.w = vadd(Vu.w,Vv.w,Qs):carry:sat
				hi->instruction = HEX_INS_V6_VADDCARRYSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x60) >> 5); // Qs4
				sprintf(hi->mnem, "%s %s.w = vadd(%s.w,%s.w,%s):carry:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_qr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f002000) {
				// 00011111000vvvvvPP1uuuuu000ddddd | Vd.h = vadd(vclb(Vu.h),Vv.h)
				hi->instruction = HEX_INS_V6_VADDCLBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vadd(vclb(%s.h),%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f002020) {
				// 00011111000vvvvvPP1uuuuu001ddddd | Vd.w = vadd(vclb(Vu.w),Vv.w)
				hi->instruction = HEX_INS_V6_VADDCLBW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vadd(vclb(%s.w),%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fa000e0) {
				// 00011111101vvvvvPP0uuuuu111ddddd | Vd.h = vadd(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VADDH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vadd(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c6000a0) {
				// 00011100011vvvvvPP0uuuuu101ddddd | Vdd.h = vadd(Vuu.h,Vvv.h)
				hi->instruction = HEX_INS_V6_VADDH_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.h = vadd(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e012080) {
				// 00011110vv000001PP1uuuuu100xxxxx | if (!Qv) Vx.h += Vu.h
				hi->instruction = HEX_INS_V6_VADDHNQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (!%s) %s.h += %s.h %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e012020) {
				// 00011110vv000001PP1uuuuu001xxxxx | if (Qv) Vx.h += Vu.h
				hi->instruction = HEX_INS_V6_VADDHQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (%s) %s.h += %s.h %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c400060) {
				// 00011100010vvvvvPP0uuuuu011ddddd | Vd.h = vadd(Vu.h,Vv.h):sat
				hi->instruction = HEX_INS_V6_VADDHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vadd(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c800020) {
				// 00011100100vvvvvPP0uuuuu001ddddd | Vdd.h = vadd(Vuu.h,Vvv.h):sat
				hi->instruction = HEX_INS_V6_VADDHSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.h = vadd(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ca00080) {
				// 00011100101vvvvvPP0uuuuu100ddddd | Vdd.w = vadd(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VADDHW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vadd(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c202040) {
				// 00011100001vvvvvPP1uuuuu010xxxxx | Vxx.w += vadd(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VADDHW_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vadd(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ca00040) {
				// 00011100101vvvvvPP0uuuuu010ddddd | Vdd.h = vadd(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VADDUBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vadd(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c4020a0) {
				// 00011100010vvvvvPP1uuuuu101xxxxx | Vxx.h += vadd(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VADDUBH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h += vadd(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c400020) {
				// 00011100010vvvvvPP0uuuuu001ddddd | Vd.ub = vadd(Vu.ub,Vv.ub):sat
				hi->instruction = HEX_INS_V6_VADDUBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vadd(%s.ub,%s.ub):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c6000e0) {
				// 00011100011vvvvvPP0uuuuu111ddddd | Vdd.ub = vadd(Vuu.ub,Vvv.ub):sat
				hi->instruction = HEX_INS_V6_VADDUBSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.ub = vadd(%s.ub,%s.ub):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ea00080) {
				// 00011110101vvvvvPP0uuuuu100ddddd | Vd.ub = vadd(Vu.ub,Vv.b):sat
				hi->instruction = HEX_INS_V6_VADDUBUBB_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vadd(%s.ub,%s.b):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c400040) {
				// 00011100010vvvvvPP0uuuuu010ddddd | Vd.uh = vadd(Vu.uh,Vv.uh):sat
				hi->instruction = HEX_INS_V6_VADDUHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vadd(%s.uh,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c800000) {
				// 00011100100vvvvvPP0uuuuu000ddddd | Vdd.uh = vadd(Vuu.uh,Vvv.uh):sat
				hi->instruction = HEX_INS_V6_VADDUHSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.uh = vadd(%s.uh,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ca00060) {
				// 00011100101vvvvvPP0uuuuu011ddddd | Vdd.w = vadd(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VADDUHW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vadd(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c402080) {
				// 00011100010vvvvvPP1uuuuu100xxxxx | Vxx.w += vadd(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VADDUHW_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vadd(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f600020) {
				// 00011111011vvvvvPP0uuuuu001ddddd | Vd.uw = vadd(Vu.uw,Vv.uw):sat
				hi->instruction = HEX_INS_V6_VADDUWSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw = vadd(%s.uw,%s.uw):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ea00040) {
				// 00011110101vvvvvPP0uuuuu010ddddd | Vdd.uw = vadd(Vuu.uw,Vvv.uw):sat
				hi->instruction = HEX_INS_V6_VADDUWSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.uw = vadd(%s.uw,%s.uw):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c400000) {
				// 00011100010vvvvvPP0uuuuu000ddddd | Vd.w = vadd(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VADDW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vadd(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c6000c0) {
				// 00011100011vvvvvPP0uuuuu110ddddd | Vdd.w = vadd(Vuu.w,Vvv.w)
				hi->instruction = HEX_INS_V6_VADDW_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.w = vadd(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e0120a0) {
				// 00011110vv000001PP1uuuuu101xxxxx | if (!Qv) Vx.w += Vu.w
				hi->instruction = HEX_INS_V6_VADDWNQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (!%s) %s.w += %s.w %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e012040) {
				// 00011110vv000001PP1uuuuu010xxxxx | if (Qv) Vx.w += Vu.w
				hi->instruction = HEX_INS_V6_VADDWQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (%s) %s.w += %s.w %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c400080) {
				// 00011100010vvvvvPP0uuuuu100ddddd | Vd.w = vadd(Vu.w,Vv.w):sat
				hi->instruction = HEX_INS_V6_VADDWSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vadd(%s.w,%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c800040) {
				// 00011100100vvvvvPP0uuuuu010ddddd | Vdd.w = vadd(Vuu.w,Vvv.w):sat
				hi->instruction = HEX_INS_V6_VADDWSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.w = vadd(%s.w,%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b000000) {
				// 00011011vvvvvtttPP0uuuuu000ddddd | Vd = valign(Vu,Vv,Rt)
				hi->instruction = HEX_INS_V6_VALIGNB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s = valign(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x1e202000) {
				// 00011110001vvvvvPP1uuuuuiiiddddd | Vd = valign(Vu,Vv,#Ii)
				hi->instruction = HEX_INS_V6_VALIGNBI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = valign(%s,%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c2000a0) {
				// 00011100001vvvvvPP0uuuuu101ddddd | Vd = vand(Vu,Vv)
				hi->instruction = HEX_INS_V6_VAND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vand(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x19a004a0) {
				// 00011001101tttttPP0001uu101ddddd | Vd = vand(!Qu,Rt)
				hi->instruction = HEX_INS_V6_VANDNQRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s = vand(!%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x19602460) {
				// 00011001011tttttPP1001uu011xxxxx | Vx |= vand(!Qu,Rt)
				hi->instruction = HEX_INS_V6_VANDNQRT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s |= vand(!%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x19a000a0) {
				// 00011001101tttttPP0000uu101ddddd | Vd = vand(Qu,Rt)
				hi->instruction = HEX_INS_V6_VANDQRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s = vand(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x19602060) {
				// 00011001011tttttPP1000uu011xxxxx | Vx |= vand(Qu,Rt)
				hi->instruction = HEX_INS_V6_VANDQRT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Qu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s |= vand(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e032020) {
				// 00011110vv000011PP1uuuuu001ddddd | Vd = vand(!Qv,Vu)
				hi->instruction = HEX_INS_V6_VANDVNQV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s = vand(!%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e032000) {
				// 00011110vv000011PP1uuuuu000ddddd | Vd = vand(Qv,Vu)
				hi->instruction = HEX_INS_V6_VANDVQV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s = vand(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x19a00048) {
				// 00011001101tttttPP0uuuuu010010dd | Qd = vand(Vu,Rt)
				hi->instruction = HEX_INS_V6_VANDVRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s = vand(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x19602080) {
				// 00011001011tttttPP1uuuuu100000xx | Qx |= vand(Vu,Rt)
				hi->instruction = HEX_INS_V6_VANDVRT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s |= vand(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19800000) {
				// 00011001100tttttPP0uuuuu000ddddd | Vd.h = vasl(Vu.h,Rt)
				hi->instruction = HEX_INS_V6_VASLH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vasl(%s.h,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19a020a0) {
				// 00011001101tttttPP1uuuuu101xxxxx | Vx.h += vasl(Vu.h,Rt)
				hi->instruction = HEX_INS_V6_VASLH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += vasl(%s.h,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fa000a0) {
				// 00011111101vvvvvPP0uuuuu101ddddd | Vd.h = vasl(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VASLHV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vasl(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x196000e0) {
				// 00011001011tttttPP0uuuuu111ddddd | Vd.w = vasl(Vu.w,Rt)
				hi->instruction = HEX_INS_V6_VASLW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vasl(%s.w,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19602040) {
				// 00011001011tttttPP1uuuuu010xxxxx | Vx.w += vasl(Vu.w,Rt)
				hi->instruction = HEX_INS_V6_VASLW_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vasl(%s.w,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fa00080) {
				// 00011111101vvvvvPP0uuuuu100ddddd | Vd.w = vasl(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VASLWV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vasl(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1aa020e0) {
				// 00011010101vvvvvPP1uuuuu111xxxxx | Vxx.w = vasrinto(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VASR_INTO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vasrinto(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x196000c0) {
				// 00011001011tttttPP0uuuuu110ddddd | Vd.h = vasr(Vu.h,Rt)
				hi->instruction = HEX_INS_V6_VASRH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vasr(%s.h,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x198020e0) {
				// 00011001100tttttPP1uuuuu111xxxxx | Vx.h += vasr(Vu.h,Rt)
				hi->instruction = HEX_INS_V6_VASRH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += vasr(%s.h,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b002000) {
				// 00011011vvvvvtttPP1uuuuu000ddddd | Vd.b = vasr(Vu.h,Vv.h,Rt):rnd:sat
				hi->instruction = HEX_INS_V6_VASRHBRNDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.b = vasr(%s.h,%s.h,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x18000000) {
				// 00011000vvvvvtttPP0uuuuu000ddddd | Vd.b = vasr(Vu.h,Vv.h,Rt):sat
				hi->instruction = HEX_INS_V6_VASRHBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.b = vasr(%s.h,%s.h,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b0000e0) {
				// 00011011vvvvvtttPP0uuuuu111ddddd | Vd.ub = vasr(Vu.h,Vv.h,Rt):rnd:sat
				hi->instruction = HEX_INS_V6_VASRHUBRNDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.ub = vasr(%s.h,%s.h,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b0000c0) {
				// 00011011vvvvvtttPP0uuuuu110ddddd | Vd.ub = vasr(Vu.h,Vv.h,Rt):sat
				hi->instruction = HEX_INS_V6_VASRHUBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.ub = vasr(%s.h,%s.h,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fa00060) {
				// 00011111101vvvvvPP0uuuuu011ddddd | Vd.h = vasr(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VASRHV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vasr(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x180000e0) {
				// 00011000vvvvvtttPP0uuuuu111ddddd | Vd.ub = vasr(Vu.uh,Vv.uh,Rt):rnd:sat
				hi->instruction = HEX_INS_V6_VASRUHUBRNDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.ub = vasr(%s.uh,%s.uh,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x180020a0) {
				// 00011000vvvvvtttPP1uuuuu101ddddd | Vd.ub = vasr(Vu.uh,Vv.uh,Rt):sat
				hi->instruction = HEX_INS_V6_VASRUHUBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.ub = vasr(%s.uh,%s.uh,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x18000020) {
				// 00011000vvvvvtttPP0uuuuu001ddddd | Vd.uh = vasr(Vu.uw,Vv.uw,Rt):rnd:sat
				hi->instruction = HEX_INS_V6_VASRUWUHRNDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.uh = vasr(%s.uw,%s.uw,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x18002080) {
				// 00011000vvvvvtttPP1uuuuu100ddddd | Vd.uh = vasr(Vu.uw,Vv.uw,Rt):sat
				hi->instruction = HEX_INS_V6_VASRUWUHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.uh = vasr(%s.uw,%s.uw,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x196000a0) {
				// 00011001011tttttPP0uuuuu101ddddd | Vd.w = vasr(Vu.w,Rt)
				hi->instruction = HEX_INS_V6_VASRW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vasr(%s.w,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x196020a0) {
				// 00011001011tttttPP1uuuuu101xxxxx | Vx.w += vasr(Vu.w,Rt)
				hi->instruction = HEX_INS_V6_VASRW_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vasr(%s.w,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b000040) {
				// 00011011vvvvvtttPP0uuuuu010ddddd | Vd.h = vasr(Vu.w,Vv.w,Rt)
				hi->instruction = HEX_INS_V6_VASRWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.h = vasr(%s.w,%s.w,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b000080) {
				// 00011011vvvvvtttPP0uuuuu100ddddd | Vd.h = vasr(Vu.w,Vv.w,Rt):rnd:sat
				hi->instruction = HEX_INS_V6_VASRWHRNDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.h = vasr(%s.w,%s.w,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b000060) {
				// 00011011vvvvvtttPP0uuuuu011ddddd | Vd.h = vasr(Vu.w,Vv.w,Rt):sat
				hi->instruction = HEX_INS_V6_VASRWHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.h = vasr(%s.w,%s.w,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x18000040) {
				// 00011000vvvvvtttPP0uuuuu010ddddd | Vd.uh = vasr(Vu.w,Vv.w,Rt):rnd:sat
				hi->instruction = HEX_INS_V6_VASRWUHRNDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.uh = vasr(%s.w,%s.w,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b0000a0) {
				// 00011011vvvvvtttPP0uuuuu101ddddd | Vd.uh = vasr(Vu.w,Vv.w,Rt):sat
				hi->instruction = HEX_INS_V6_VASRWUHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.uh = vasr(%s.w,%s.w,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fa00000) {
				// 00011111101vvvvvPP0uuuuu000ddddd | Vd.w = vasr(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VASRWV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vasr(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0320e0) {
				// 0001111000000011PP1uuuuu111ddddd | Vd = Vu
				hi->instruction = HEX_INS_V6_VASSIGN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f002080) {
				// 00011111000vvvvvPP1uuuuu100ddddd | Vd.b = vavg(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VAVGB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vavg(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f0020a0) {
				// 00011111000vvvvvPP1uuuuu101ddddd | Vd.b = vavg(Vu.b,Vv.b):rnd
				hi->instruction = HEX_INS_V6_VAVGBRND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vavg(%s.b,%s.b):rnd %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1cc000c0) {
				// 00011100110vvvvvPP0uuuuu110ddddd | Vd.h = vavg(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VAVGH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vavg(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ce000a0) {
				// 00011100111vvvvvPP0uuuuu101ddddd | Vd.h = vavg(Vu.h,Vv.h):rnd
				hi->instruction = HEX_INS_V6_VAVGHRND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vavg(%s.h,%s.h):rnd %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1cc00080) {
				// 00011100110vvvvvPP0uuuuu100ddddd | Vd.ub = vavg(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VAVGUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vavg(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ce00060) {
				// 00011100111vvvvvPP0uuuuu011ddddd | Vd.ub = vavg(Vu.ub,Vv.ub):rnd
				hi->instruction = HEX_INS_V6_VAVGUBRND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vavg(%s.ub,%s.ub):rnd %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1cc000a0) {
				// 00011100110vvvvvPP0uuuuu101ddddd | Vd.uh = vavg(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VAVGUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vavg(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ce00080) {
				// 00011100111vvvvvPP0uuuuu100ddddd | Vd.uh = vavg(Vu.uh,Vv.uh):rnd
				hi->instruction = HEX_INS_V6_VAVGUHRND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vavg(%s.uh,%s.uh):rnd %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f002040) {
				// 00011111000vvvvvPP1uuuuu010ddddd | Vd.uw = vavg(Vu.uw,Vv.uw)
				hi->instruction = HEX_INS_V6_VAVGUW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw = vavg(%s.uw,%s.uw) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f002060) {
				// 00011111000vvvvvPP1uuuuu011ddddd | Vd.uw = vavg(Vu.uw,Vv.uw):rnd
				hi->instruction = HEX_INS_V6_VAVGUWRND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw = vavg(%s.uw,%s.uw):rnd %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1cc000e0) {
				// 00011100110vvvvvPP0uuuuu111ddddd | Vd.w = vavg(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VAVGW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vavg(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ce000c0) {
				// 00011100111vvvvvPP0uuuuu110ddddd | Vd.w = vavg(Vu.w,Vv.w):rnd
				hi->instruction = HEX_INS_V6_VAVGWRND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vavg(%s.w,%s.w):rnd %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1a600000) {
				// 00011010011vvvvvPP0uuuuu0ssddddd | if (Ps) Vdd = vcombine(Vu,Vv)
				hi->instruction = HEX_INS_V6_VCCOMBINE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s if (%s) %s = vcombine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0200e0) {
				// 0001111000000010PP0uuuuu111ddddd | Vd.uh = vcl0(Vu.uh)
				hi->instruction = HEX_INS_V6_VCL0H;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.uh = vcl0(%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0200a0) {
				// 0001111000000010PP0uuuuu101ddddd | Vd.uw = vcl0(Vu.uw)
				hi->instruction = HEX_INS_V6_VCL0W;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.uw = vcl0(%s.uw) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff2080) == 0x1a000000) {
				// 0001101000000000PP0uuuuu0ssddddd | if (Ps) Vd = Vu
				hi->instruction = HEX_INS_V6_VCMOV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (%s) %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f4000e0) {
				// 00011111010vvvvvPP0uuuuu111ddddd | Vdd = vcombine(Vu,Vv)
				hi->instruction = HEX_INS_V6_VCOMBINE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcombine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19e02040) {
				// 00011001111tttttPP1yyyyy010xxxxx | vdeal(Vy,Vx,Rt)
				hi->instruction = HEX_INS_V6_VDEAL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Vy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s vdeal(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0000e0) {
				// 0001111000000000PP0uuuuu111ddddd | Vd.b = vdeal(Vu.b)
				hi->instruction = HEX_INS_V6_VDEALB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.b = vdeal(%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f2000e0) {
				// 00011111001vvvvvPP0uuuuu111ddddd | Vd.b = vdeale(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VDEALB4W;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vdeale(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0000c0) {
				// 0001111000000000PP0uuuuu110ddddd | Vd.h = vdeal(Vu.h)
				hi->instruction = HEX_INS_V6_VDEALH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h = vdeal(%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b002080) {
				// 00011011vvvvvtttPP1uuuuu100ddddd | Vdd = vdeal(Vu,Vv,Rt)
				hi->instruction = HEX_INS_V6_VDEALVDD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s = vdeal(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f200020) {
				// 00011111001vvvvvPP0uuuuu001ddddd | Vd = vdelta(Vu,Vv)
				hi->instruction = HEX_INS_V6_VDELTA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vdelta(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x190000c0) {
				// 00011001000tttttPP0uuuuu110ddddd | Vd.h = vdmpy(Vu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VDMPYBUS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vdmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x190020c0) {
				// 00011001000tttttPP1uuuuu110xxxxx | Vx.h += vdmpy(Vu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VDMPYBUS_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += vdmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x190000e0) {
				// 00011001000tttttPP0uuuuu111ddddd | Vdd.h = vdmpy(Vuu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VDMPYBUS_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vdmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x190020e0) {
				// 00011001000tttttPP1uuuuu111xxxxx | Vxx.h += vdmpy(Vuu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VDMPYBUS_DV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += vdmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19000040) {
				// 00011001000tttttPP0uuuuu010ddddd | Vd.w = vdmpy(Vu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VDMPYHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vdmpy(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19002060) {
				// 00011001000tttttPP1uuuuu011xxxxx | Vx.w += vdmpy(Vu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VDMPYHB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vdmpy(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19200080) {
				// 00011001001tttttPP0uuuuu100ddddd | Vdd.w = vdmpy(Vuu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VDMPYHB_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vdmpy(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19202080) {
				// 00011001001tttttPP1uuuuu100xxxxx | Vxx.w += vdmpy(Vuu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VDMPYHB_DV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vdmpy(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19200060) {
				// 00011001001tttttPP0uuuuu011ddddd | Vd.w = vdmpy(Vuu.h,Rt.h):sat
				hi->instruction = HEX_INS_V6_VDMPYHISAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vdmpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19202040) {
				// 00011001001tttttPP1uuuuu010xxxxx | Vx.w += vdmpy(Vuu.h,Rt.h):sat
				hi->instruction = HEX_INS_V6_VDMPYHISAT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vdmpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19200040) {
				// 00011001001tttttPP0uuuuu010ddddd | Vd.w = vdmpy(Vu.h,Rt.h):sat
				hi->instruction = HEX_INS_V6_VDMPYHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vdmpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19202060) {
				// 00011001001tttttPP1uuuuu011xxxxx | Vx.w += vdmpy(Vu.h,Rt.h):sat
				hi->instruction = HEX_INS_V6_VDMPYHSAT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vdmpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19200020) {
				// 00011001001tttttPP0uuuuu001ddddd | Vd.w = vdmpy(Vuu.h,Rt.uh,#1):sat
				hi->instruction = HEX_INS_V6_VDMPYHSUISAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vdmpy(%s.h,%s.uh,#1):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19202020) {
				// 00011001001tttttPP1uuuuu001xxxxx | Vx.w += vdmpy(Vuu.h,Rt.uh,#1):sat
				hi->instruction = HEX_INS_V6_VDMPYHSUISAT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vdmpy(%s.h,%s.uh,#1):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19200000) {
				// 00011001001tttttPP0uuuuu000ddddd | Vd.w = vdmpy(Vu.h,Rt.uh):sat
				hi->instruction = HEX_INS_V6_VDMPYHSUSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vdmpy(%s.h,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19202000) {
				// 00011001001tttttPP1uuuuu000xxxxx | Vx.w += vdmpy(Vu.h,Rt.uh):sat
				hi->instruction = HEX_INS_V6_VDMPYHSUSAT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vdmpy(%s.h,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c000060) {
				// 00011100000vvvvvPP0uuuuu011ddddd | Vd.w = vdmpy(Vu.h,Vv.h):sat
				hi->instruction = HEX_INS_V6_VDMPYHVSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vdmpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c002060) {
				// 00011100000vvvvvPP1uuuuu011xxxxx | Vx.w += vdmpy(Vu.h,Vv.h):sat
				hi->instruction = HEX_INS_V6_VDMPYHVSAT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vdmpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x190000a0) {
				// 00011001000tttttPP0uuuuu101ddddd | Vdd.uw = vdsad(Vuu.uh,Rt.uh)
				hi->instruction = HEX_INS_V6_VDSADUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw = vdsad(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19602000) {
				// 00011001011tttttPP1uuuuu000xxxxx | Vxx.uw += vdsad(Vuu.uh,Rt.uh)
				hi->instruction = HEX_INS_V6_VDSADUH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw += vdsad(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800000) {
				// 00011111100vvvvvPP0uuuuu000000dd | Qd = vcmp.eq(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VEQB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.eq(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802000) {
				// 00011100100vvvvvPP1uuuuu000000xx | Qx &= vcmp.eq(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VEQB_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.eq(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802040) {
				// 00011100100vvvvvPP1uuuuu010000xx | Qx |= vcmp.eq(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VEQB_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.eq(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802080) {
				// 00011100100vvvvvPP1uuuuu100000xx | Qx ^= vcmp.eq(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VEQB_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.eq(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800004) {
				// 00011111100vvvvvPP0uuuuu000001dd | Qd = vcmp.eq(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VEQH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.eq(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802004) {
				// 00011100100vvvvvPP1uuuuu000001xx | Qx &= vcmp.eq(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VEQH_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.eq(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802044) {
				// 00011100100vvvvvPP1uuuuu010001xx | Qx |= vcmp.eq(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VEQH_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.eq(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802084) {
				// 00011100100vvvvvPP1uuuuu100001xx | Qx ^= vcmp.eq(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VEQH_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.eq(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800008) {
				// 00011111100vvvvvPP0uuuuu000010dd | Qd = vcmp.eq(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VEQW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.eq(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802008) {
				// 00011100100vvvvvPP1uuuuu000010xx | Qx &= vcmp.eq(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VEQW_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.eq(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802048) {
				// 00011100100vvvvvPP1uuuuu010010xx | Qx |= vcmp.eq(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VEQW_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.eq(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802088) {
				// 00011100100vvvvvPP1uuuuu100010xx | Qx ^= vcmp.eq(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VEQW_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.eq(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800010) {
				// 00011111100vvvvvPP0uuuuu000100dd | Qd = vcmp.gt(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VGTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.gt(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802010) {
				// 00011100100vvvvvPP1uuuuu000100xx | Qx &= vcmp.gt(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VGTB_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.gt(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802050) {
				// 00011100100vvvvvPP1uuuuu010100xx | Qx |= vcmp.gt(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VGTB_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.gt(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802090) {
				// 00011100100vvvvvPP1uuuuu100100xx | Qx ^= vcmp.gt(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VGTB_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.gt(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800014) {
				// 00011111100vvvvvPP0uuuuu000101dd | Qd = vcmp.gt(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VGTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.gt(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802014) {
				// 00011100100vvvvvPP1uuuuu000101xx | Qx &= vcmp.gt(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VGTH_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.gt(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802054) {
				// 00011100100vvvvvPP1uuuuu010101xx | Qx |= vcmp.gt(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VGTH_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.gt(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802094) {
				// 00011100100vvvvvPP1uuuuu100101xx | Qx ^= vcmp.gt(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VGTH_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.gt(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800020) {
				// 00011111100vvvvvPP0uuuuu001000dd | Qd = vcmp.gt(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VGTUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.gt(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802020) {
				// 00011100100vvvvvPP1uuuuu001000xx | Qx &= vcmp.gt(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VGTUB_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.gt(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802060) {
				// 00011100100vvvvvPP1uuuuu011000xx | Qx |= vcmp.gt(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VGTUB_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.gt(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c8020a0) {
				// 00011100100vvvvvPP1uuuuu101000xx | Qx ^= vcmp.gt(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VGTUB_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.gt(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800024) {
				// 00011111100vvvvvPP0uuuuu001001dd | Qd = vcmp.gt(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VGTUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.gt(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802024) {
				// 00011100100vvvvvPP1uuuuu001001xx | Qx &= vcmp.gt(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VGTUH_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.gt(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802064) {
				// 00011100100vvvvvPP1uuuuu011001xx | Qx |= vcmp.gt(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VGTUH_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.gt(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c8020a4) {
				// 00011100100vvvvvPP1uuuuu101001xx | Qx ^= vcmp.gt(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VGTUH_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.gt(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800028) {
				// 00011111100vvvvvPP0uuuuu001010dd | Qd = vcmp.gt(Vu.uw,Vv.uw)
				hi->instruction = HEX_INS_V6_VGTUW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.gt(%s.uw,%s.uw) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802028) {
				// 00011100100vvvvvPP1uuuuu001010xx | Qx &= vcmp.gt(Vu.uw,Vv.uw)
				hi->instruction = HEX_INS_V6_VGTUW_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.gt(%s.uw,%s.uw) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802068) {
				// 00011100100vvvvvPP1uuuuu011010xx | Qx |= vcmp.gt(Vu.uw,Vv.uw)
				hi->instruction = HEX_INS_V6_VGTUW_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.gt(%s.uw,%s.uw) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c8020a8) {
				// 00011100100vvvvvPP1uuuuu101010xx | Qx ^= vcmp.gt(Vu.uw,Vv.uw)
				hi->instruction = HEX_INS_V6_VGTUW_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.gt(%s.uw,%s.uw) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1f800018) {
				// 00011111100vvvvvPP0uuuuu000110dd | Qd = vcmp.gt(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VGTW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vcmp.gt(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802018) {
				// 00011100100vvvvvPP1uuuuu000110xx | Qx &= vcmp.gt(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VGTW_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s &= vcmp.gt(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802058) {
				// 00011100100vvvvvPP1uuuuu010110xx | Qx |= vcmp.gt(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VGTW_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s |= vcmp.gt(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x1c802098) {
				// 00011100100vvvvvPP1uuuuu100110xx | Qx ^= vcmp.gt(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VGTW_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s ^= vcmp.gt(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0x1e002080) {
				// 0001111000000000PP10000010000000 | vhist
				hi->instruction = HEX_INS_V6_VHIST;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s vhist %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3fff) == 0x1e022080) {
				// 00011110vv000010PP10000010000000 | vhist(Qv)
				hi->instruction = HEX_INS_V6_VHISTQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				sprintf(hi->mnem, "%s vhist(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x19a02020) {
				// 00011001101tttttPP100000001xxxxx | Vx.w = vinsert(Rt)
				hi->instruction = HEX_INS_V6_VINSERTWR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vinsert(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b000020) {
				// 00011011vvvvvtttPP0uuuuu001ddddd | Vd = vlalign(Vu,Vv,Rt)
				hi->instruction = HEX_INS_V6_VLALIGNB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s = vlalign(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x1e602000) {
				// 00011110011vvvvvPP1uuuuuiiiddddd | Vd = vlalign(Vu,Vv,#Ii)
				hi->instruction = HEX_INS_V6_VLALIGNBI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = vlalign(%s,%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19800060) {
				// 00011001100tttttPP0uuuuu011ddddd | Vd.ub = vlsr(Vu.ub,Rt)
				hi->instruction = HEX_INS_V6_VLSRB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.ub = vlsr(%s.ub,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19800040) {
				// 00011001100tttttPP0uuuuu010ddddd | Vd.uh = vlsr(Vu.uh,Rt)
				hi->instruction = HEX_INS_V6_VLSRH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uh = vlsr(%s.uh,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fa00040) {
				// 00011111101vvvvvPP0uuuuu010ddddd | Vd.h = vlsr(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VLSRHV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vlsr(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19800020) {
				// 00011001100tttttPP0uuuuu001ddddd | Vd.uw = vlsr(Vu.uw,Rt)
				hi->instruction = HEX_INS_V6_VLSRW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw = vlsr(%s.uw,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fa00020) {
				// 00011111101vvvvvPP0uuuuu001ddddd | Vd.w = vlsr(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VLSRWV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vlsr(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19600080) {
				// 00011001011tttttPP0uuuuu100ddddd | Vd.h = vlut4(Vu.uh,Rtt.h)
				hi->instruction = HEX_INS_V6_VLUT4;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rtt32
				sprintf(hi->mnem, "%s %s.h = vlut4(%s.uh,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b002020) {
				// 00011011vvvvvtttPP1uuuuu001ddddd | Vd.b = vlut32(Vu.b,Vv.b,Rt)
				hi->instruction = HEX_INS_V6_VLUTVVB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.b = vlut32(%s.b,%s.b,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x18000060) {
				// 00011000vvvvvtttPP0uuuuu011ddddd | Vd.b = vlut32(Vu.b,Vv.b,Rt):nomatch
				hi->instruction = HEX_INS_V6_VLUTVVB_NM;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.b = vlut32(%s.b,%s.b,%s):nomatch %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b0020a0) {
				// 00011011vvvvvtttPP1uuuuu101xxxxx | Vx.b |= vlut32(Vu.b,Vv.b,Rt)
				hi->instruction = HEX_INS_V6_VLUTVVB_ORACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.b |= vlut32(%s.b,%s.b,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x1cc02000) {
				// 00011100110vvvvvPP1uuuuuiiixxxxx | Vx.b |= vlut32(Vu.b,Vv.b,#Ii)
				hi->instruction = HEX_INS_V6_VLUTVVB_ORACCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.b |= vlut32(%s.b,%s.b,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x1e200000) {
				// 00011110001vvvvvPP0uuuuuiiiddddd | Vd.b = vlut32(Vu.b,Vv.b,#Ii)
				hi->instruction = HEX_INS_V6_VLUTVVBI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.b = vlut32(%s.b,%s.b,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b0020c0) {
				// 00011011vvvvvtttPP1uuuuu110ddddd | Vdd.h = vlut16(Vu.b,Vv.h,Rt)
				hi->instruction = HEX_INS_V6_VLUTVWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.h = vlut16(%s.b,%s.h,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x18000080) {
				// 00011000vvvvvtttPP0uuuuu100ddddd | Vdd.h = vlut16(Vu.b,Vv.h,Rt):nomatch
				hi->instruction = HEX_INS_V6_VLUTVWH_NM;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.h = vlut16(%s.b,%s.h,%s):nomatch %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b0020e0) {
				// 00011011vvvvvtttPP1uuuuu111xxxxx | Vxx.h |= vlut16(Vu.b,Vv.h,Rt)
				hi->instruction = HEX_INS_V6_VLUTVWH_ORACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.h |= vlut16(%s.b,%s.h,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x1ce02000) {
				// 00011100111vvvvvPP1uuuuuiiixxxxx | Vxx.h |= vlut16(Vu.b,Vv.h,#Ii)
				hi->instruction = HEX_INS_V6_VLUTVWH_ORACCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.h |= vlut16(%s.b,%s.h,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x1e600000) {
				// 00011110011vvvvvPP0uuuuuiiiddddd | Vdd.h = vlut16(Vu.b,Vv.h,#Ii)
				hi->instruction = HEX_INS_V6_VLUTVWHI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.h = vlut16(%s.b,%s.h,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f2000a0) {
				// 00011111001vvvvvPP0uuuuu101ddddd | Vd.b = vmax(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VMAXB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vmax(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f0000e0) {
				// 00011111000vvvvvPP0uuuuu111ddddd | Vd.h = vmax(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VMAXH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vmax(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f0000a0) {
				// 00011111000vvvvvPP0uuuuu101ddddd | Vd.ub = vmax(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VMAXUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vmax(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f0000c0) {
				// 00011111000vvvvvPP0uuuuu110ddddd | Vd.uh = vmax(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VMAXUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vmax(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f200000) {
				// 00011111001vvvvvPP0uuuuu000ddddd | Vd.w = vmax(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VMAXW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmax(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f200080) {
				// 00011111001vvvvvPP0uuuuu100ddddd | Vd.b = vmin(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VMINB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vmin(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f000060) {
				// 00011111000vvvvvPP0uuuuu011ddddd | Vd.h = vmin(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VMINH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vmin(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f000020) {
				// 00011111000vvvvvPP0uuuuu001ddddd | Vd.ub = vmin(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VMINUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vmin(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f000040) {
				// 00011111000vvvvvPP0uuuuu010ddddd | Vd.uh = vmin(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VMINUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vmin(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f000080) {
				// 00011111000vvvvvPP0uuuuu100ddddd | Vd.w = vmin(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VMINW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmin(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x192000c0) {
				// 00011001001tttttPP0uuuuu110ddddd | Vdd.h = vmpa(Vuu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VMPABUS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vmpa(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x192020c0) {
				// 00011001001tttttPP1uuuuu110xxxxx | Vxx.h += vmpa(Vuu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VMPABUS_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += vmpa(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c200060) {
				// 00011100001vvvvvPP0uuuuu011ddddd | Vdd.h = vmpa(Vuu.ub,Vvv.b)
				hi->instruction = HEX_INS_V6_VMPABUSV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.h = vmpa(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19600060) {
				// 00011001011tttttPP0uuuuu011ddddd | Vdd.h = vmpa(Vuu.ub,Rt.ub)
				hi->instruction = HEX_INS_V6_VMPABUU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vmpa(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19a02080) {
				// 00011001101tttttPP1uuuuu100xxxxx | Vxx.h += vmpa(Vuu.ub,Rt.ub)
				hi->instruction = HEX_INS_V6_VMPABUU_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += vmpa(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ce000e0) {
				// 00011100111vvvvvPP0uuuuu111ddddd | Vdd.h = vmpa(Vuu.ub,Vvv.ub)
				hi->instruction = HEX_INS_V6_VMPABUUV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.h = vmpa(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x192000e0) {
				// 00011001001tttttPP0uuuuu111ddddd | Vdd.w = vmpa(Vuu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VMPAHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vmpa(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x192020e0) {
				// 00011001001tttttPP1uuuuu111xxxxx | Vxx.w += vmpa(Vuu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VMPAHB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vmpa(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19802080) {
				// 00011001100tttttPP1uuuuu100xxxxx | Vx.h = vmpa(Vxin.h,Vu.h,Rtt.h):sat
				hi->instruction = HEX_INS_V6_VMPAHHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rtt32
				sprintf(hi->mnem, "%s %s.h = vmpa(%sin.h,%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x198000a0) {
				// 00011001100tttttPP0uuuuu101ddddd | Vdd.w = vmpa(Vuu.uh,Rt.b)
				hi->instruction = HEX_INS_V6_VMPAUHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vmpa(%s.uh,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19802040) {
				// 00011001100tttttPP1uuuuu010xxxxx | Vxx.w += vmpa(Vuu.uh,Rt.b)
				hi->instruction = HEX_INS_V6_VMPAUHB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vmpa(%s.uh,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x198020a0) {
				// 00011001100tttttPP1uuuuu101xxxxx | Vx.h = vmpa(Vxin.h,Vu.uh,Rtt.uh):sat
				hi->instruction = HEX_INS_V6_VMPAUHUHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rtt32
				sprintf(hi->mnem, "%s %s.h = vmpa(%sin.h,%s.uh,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x198020c0) {
				// 00011001100tttttPP1uuuuu110xxxxx | Vx.h = vmps(Vxin.h,Vu.uh,Rtt.uh):sat
				hi->instruction = HEX_INS_V6_VMPSUHUHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32in
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rtt32
				sprintf(hi->mnem, "%s %s.h = vmps(%sin.h,%s.uh,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x192000a0) {
				// 00011001001tttttPP0uuuuu101ddddd | Vdd.h = vmpy(Vu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VMPYBUS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x192020a0) {
				// 00011001001tttttPP1uuuuu101xxxxx | Vxx.h += vmpy(Vu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VMPYBUS_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += vmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c0000c0) {
				// 00011100000vvvvvPP0uuuuu110ddddd | Vdd.h = vmpy(Vu.ub,Vv.b)
				hi->instruction = HEX_INS_V6_VMPYBUSV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c0020c0) {
				// 00011100000vvvvvPP1uuuuu110xxxxx | Vxx.h += vmpy(Vu.ub,Vv.b)
				hi->instruction = HEX_INS_V6_VMPYBUSV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h += vmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c000080) {
				// 00011100000vvvvvPP0uuuuu100ddddd | Vdd.h = vmpy(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VMPYBV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vmpy(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c002080) {
				// 00011100000vvvvvPP1uuuuu100xxxxx | Vxx.h += vmpy(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VMPYBV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h += vmpy(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fe000a0) {
				// 00011111111vvvvvPP0uuuuu101ddddd | Vd.w = vmpye(Vu.w,Vv.uh)
				hi->instruction = HEX_INS_V6_VMPYEWUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmpye(%s.w,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ea000c0) {
				// 00011110101vvvvvPP0uuuuu110ddddd | Vdd = vmpye(Vu.w,Vv.uh)
				hi->instruction = HEX_INS_V6_VMPYEWUH_64;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vmpye(%s.w,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19400000) {
				// 00011001010tttttPP0uuuuu000ddddd | Vdd.w = vmpy(Vu.h,Rt.h)
				hi->instruction = HEX_INS_V6_VMPYH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vmpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19a020c0) {
				// 00011001101tttttPP1uuuuu110xxxxx | Vxx.w += vmpy(Vu.h,Rt.h)
				hi->instruction = HEX_INS_V6_VMPYH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vmpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19402000) {
				// 00011001010tttttPP1uuuuu000xxxxx | Vxx.w += vmpy(Vu.h,Rt.h):sat
				hi->instruction = HEX_INS_V6_VMPYHSAT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vmpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19400040) {
				// 00011001010tttttPP0uuuuu010ddddd | Vd.h = vmpy(Vu.h,Rt.h):<<1:rnd:sat
				hi->instruction = HEX_INS_V6_VMPYHSRS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vmpy(%s.h,%s.h):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19400020) {
				// 00011001010tttttPP0uuuuu001ddddd | Vd.h = vmpy(Vu.h,Rt.h):<<1:sat
				hi->instruction = HEX_INS_V6_VMPYHSS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vmpy(%s.h,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c200040) {
				// 00011100001vvvvvPP0uuuuu010ddddd | Vdd.w = vmpy(Vu.h,Vv.uh)
				hi->instruction = HEX_INS_V6_VMPYHUS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmpy(%s.h,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c202020) {
				// 00011100001vvvvvPP1uuuuu001xxxxx | Vxx.w += vmpy(Vu.h,Vv.uh)
				hi->instruction = HEX_INS_V6_VMPYHUS_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vmpy(%s.h,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c0000e0) {
				// 00011100000vvvvvPP0uuuuu111ddddd | Vdd.w = vmpy(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VMPYHV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c0020e0) {
				// 00011100000vvvvvPP1uuuuu111xxxxx | Vxx.w += vmpy(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VMPYHV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vmpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c200020) {
				// 00011100001vvvvvPP0uuuuu001ddddd | Vd.h = vmpy(Vu.h,Vv.h):<<1:rnd:sat
				hi->instruction = HEX_INS_V6_VMPYHVSRS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vmpy(%s.h,%s.h):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f600000) {
				// 00011111011vvvvvPP0uuuuu000ddddd | Vd.w = vmpyieo(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VMPYIEOH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmpyieo(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c402000) {
				// 00011100010vvvvvPP1uuuuu000xxxxx | Vx.w += vmpyie(Vu.w,Vv.h)
				hi->instruction = HEX_INS_V6_VMPYIEWH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vmpyie(%s.w,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fc00000) {
				// 00011111110vvvvvPP0uuuuu000ddddd | Vd.w = vmpyie(Vu.w,Vv.uh)
				hi->instruction = HEX_INS_V6_VMPYIEWUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmpyie(%s.w,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c2020a0) {
				// 00011100001vvvvvPP1uuuuu101xxxxx | Vx.w += vmpyie(Vu.w,Vv.uh)
				hi->instruction = HEX_INS_V6_VMPYIEWUH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vmpyie(%s.w,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c200080) {
				// 00011100001vvvvvPP0uuuuu100ddddd | Vd.h = vmpyi(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VMPYIH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vmpyi(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c202080) {
				// 00011100001vvvvvPP1uuuuu100xxxxx | Vx.h += vmpyi(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VMPYIH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h += vmpyi(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19600000) {
				// 00011001011tttttPP0uuuuu000ddddd | Vd.h = vmpyi(Vu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VMPYIHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = vmpyi(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19602020) {
				// 00011001011tttttPP1uuuuu001xxxxx | Vx.h += vmpyi(Vu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VMPYIHB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += vmpyi(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fc00020) {
				// 00011111110vvvvvPP0uuuuu001ddddd | Vd.w = vmpyio(Vu.w,Vv.h)
				hi->instruction = HEX_INS_V6_VMPYIOWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmpyio(%s.w,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19a00000) {
				// 00011001101tttttPP0uuuuu000ddddd | Vd.w = vmpyi(Vu.w,Rt.b)
				hi->instruction = HEX_INS_V6_VMPYIWB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vmpyi(%s.w,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19402040) {
				// 00011001010tttttPP1uuuuu010xxxxx | Vx.w += vmpyi(Vu.w,Rt.b)
				hi->instruction = HEX_INS_V6_VMPYIWB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vmpyi(%s.w,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x198000e0) {
				// 00011001100tttttPP0uuuuu111ddddd | Vd.w = vmpyi(Vu.w,Rt.h)
				hi->instruction = HEX_INS_V6_VMPYIWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vmpyi(%s.w,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19402060) {
				// 00011001010tttttPP1uuuuu011xxxxx | Vx.w += vmpyi(Vu.w,Rt.h)
				hi->instruction = HEX_INS_V6_VMPYIWH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vmpyi(%s.w,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x198000c0) {
				// 00011001100tttttPP0uuuuu110ddddd | Vd.w = vmpyi(Vu.w,Rt.ub)
				hi->instruction = HEX_INS_V6_VMPYIWUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vmpyi(%s.w,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19802020) {
				// 00011001100tttttPP1uuuuu001xxxxx | Vx.w += vmpyi(Vu.w,Rt.ub)
				hi->instruction = HEX_INS_V6_VMPYIWUB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vmpyi(%s.w,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fe000e0) {
				// 00011111111vvvvvPP0uuuuu111ddddd | Vd.w = vmpyo(Vu.w,Vv.h):<<1:sat
				hi->instruction = HEX_INS_V6_VMPYOWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmpyo(%s.w,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c202060) {
				// 00011100001vvvvvPP1uuuuu011xxxxx | Vxx += vmpyo(Vu.w,Vv.h)
				hi->instruction = HEX_INS_V6_VMPYOWH_64_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s += vmpyo(%s.w,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f400000) {
				// 00011111010vvvvvPP0uuuuu000ddddd | Vd.w = vmpyo(Vu.w,Vv.h):<<1:rnd:sat
				hi->instruction = HEX_INS_V6_VMPYOWH_RND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vmpyo(%s.w,%s.h):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c2020e0) {
				// 00011100001vvvvvPP1uuuuu111xxxxx | Vx.w += vmpyo(Vu.w,Vv.h):<<1:rnd:sat:shift
				hi->instruction = HEX_INS_V6_VMPYOWH_RND_SACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vmpyo(%s.w,%s.h):<<1:rnd:sat:shift %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c2020c0) {
				// 00011100001vvvvvPP1uuuuu110xxxxx | Vx.w += vmpyo(Vu.w,Vv.h):<<1:sat:shift
				hi->instruction = HEX_INS_V6_VMPYOWH_SACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vmpyo(%s.w,%s.h):<<1:sat:shift %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19c00000) {
				// 00011001110tttttPP0uuuuu000ddddd | Vdd.uh = vmpy(Vu.ub,Rt.ub)
				hi->instruction = HEX_INS_V6_VMPYUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uh = vmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19802000) {
				// 00011001100tttttPP1uuuuu000xxxxx | Vxx.uh += vmpy(Vu.ub,Rt.ub)
				hi->instruction = HEX_INS_V6_VMPYUB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uh += vmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c0000a0) {
				// 00011100000vvvvvPP0uuuuu101ddddd | Vdd.uh = vmpy(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VMPYUBV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c0020a0) {
				// 00011100000vvvvvPP1uuuuu101xxxxx | Vxx.uh += vmpy(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VMPYUBV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh += vmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19400060) {
				// 00011001010tttttPP0uuuuu011ddddd | Vdd.uw = vmpy(Vu.uh,Rt.uh)
				hi->instruction = HEX_INS_V6_VMPYUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw = vmpy(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19402020) {
				// 00011001010tttttPP1uuuuu001xxxxx | Vxx.uw += vmpy(Vu.uh,Rt.uh)
				hi->instruction = HEX_INS_V6_VMPYUH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw += vmpy(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19600040) {
				// 00011001011tttttPP0uuuuu010ddddd | Vd.uw = vmpye(Vu.uh,Rt.uh)
				hi->instruction = HEX_INS_V6_VMPYUHE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw = vmpye(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19802060) {
				// 00011001100tttttPP1uuuuu011xxxxx | Vx.uw += vmpye(Vu.uh,Rt.uh)
				hi->instruction = HEX_INS_V6_VMPYUHE_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw += vmpye(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c200000) {
				// 00011100001vvvvvPP0uuuuu000ddddd | Vdd.uw = vmpy(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VMPYUHV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw = vmpy(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c202000) {
				// 00011100001vvvvvPP1uuuuu000xxxxx | Vxx.uw += vmpy(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VMPYUHV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw += vmpy(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1ee02000) {
				// 00011110111vvvvvPP1uuuuu0ttddddd | Vd = vmux(Qt,Vu,Vv)
				hi->instruction = HEX_INS_V6_VMUX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Qt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vmux(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f0020c0) {
				// 00011111000vvvvvPP1uuuuu110ddddd | Vd.b = vnavg(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VNAVGB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vnavg(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ce00020) {
				// 00011100111vvvvvPP0uuuuu001ddddd | Vd.h = vnavg(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VNAVGH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vnavg(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ce00000) {
				// 00011100111vvvvvPP0uuuuu000ddddd | Vd.b = vnavg(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VNAVGUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vnavg(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ce00040) {
				// 00011100111vvvvvPP0uuuuu010ddddd | Vd.w = vnavg(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VNAVGW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vnavg(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1a400000) {
				// 00011010010vvvvvPP0uuuuu0ssddddd | if (!Ps) Vdd = vcombine(Vu,Vv)
				hi->instruction = HEX_INS_V6_VNCCOMBINE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s if (!%s) %s = vcombine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff2080) == 0x1a200000) {
				// 0001101000100000PP0uuuuu0ssddddd | if (!Ps) Vd = Vu
				hi->instruction = HEX_INS_V6_VNCMOV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (!%s) %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0300a0) {
				// 0001111000000011PP0uuuuu101ddddd | Vd.h = vnormamt(Vu.h)
				hi->instruction = HEX_INS_V6_VNORMAMTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h = vnormamt(%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e030080) {
				// 0001111000000011PP0uuuuu100ddddd | Vd.w = vnormamt(Vu.w)
				hi->instruction = HEX_INS_V6_VNORMAMTW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vnormamt(%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e000080) {
				// 0001111000000000PP0uuuuu100ddddd | Vd = vnot(Vu)
				hi->instruction = HEX_INS_V6_VNOT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s = vnot(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c2000c0) {
				// 00011100001vvvvvPP0uuuuu110ddddd | Vd = vor(Vu,Vv)
				hi->instruction = HEX_INS_V6_VOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fc00040) {
				// 00011111110vvvvvPP0uuuuu010ddddd | Vd.b = vpacke(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VPACKEB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vpacke(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fc00060) {
				// 00011111110vvvvvPP0uuuuu011ddddd | Vd.h = vpacke(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VPACKEH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vpacke(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fc000c0) {
				// 00011111110vvvvvPP0uuuuu110ddddd | Vd.b = vpack(Vu.h,Vv.h):sat
				hi->instruction = HEX_INS_V6_VPACKHB_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vpack(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fc000a0) {
				// 00011111110vvvvvPP0uuuuu101ddddd | Vd.ub = vpack(Vu.h,Vv.h):sat
				hi->instruction = HEX_INS_V6_VPACKHUB_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vpack(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fe00020) {
				// 00011111111vvvvvPP0uuuuu001ddddd | Vd.b = vpacko(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VPACKOB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vpacko(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fe00040) {
				// 00011111111vvvvvPP0uuuuu010ddddd | Vd.h = vpacko(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VPACKOH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vpacko(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fe00000) {
				// 00011111111vvvvvPP0uuuuu000ddddd | Vd.h = vpack(Vu.w,Vv.w):sat
				hi->instruction = HEX_INS_V6_VPACKWH_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vpack(%s.w,%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fc000e0) {
				// 00011111110vvvvvPP0uuuuu111ddddd | Vd.uh = vpack(Vu.w,Vv.w):sat
				hi->instruction = HEX_INS_V6_VPACKWUH_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vpack(%s.w,%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0200c0) {
				// 0001111000000010PP0uuuuu110ddddd | Vd.h = vpopcount(Vu.h)
				hi->instruction = HEX_INS_V6_VPOPCOUNTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h = vpopcount(%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3fe0) == 0x1e032040) {
				// 00011110vv000011PP100000010ddddd | Vd.b = prefixsum(Qv)
				hi->instruction = HEX_INS_V6_VPREFIXQB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				sprintf(hi->mnem, "%s %s.b = prefixsum(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3fe0) == 0x1e032140) {
				// 00011110vv000011PP100001010ddddd | Vd.h = prefixsum(Qv)
				hi->instruction = HEX_INS_V6_VPREFIXQH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				sprintf(hi->mnem, "%s %s.h = prefixsum(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3fe0) == 0x1e032240) {
				// 00011110vv000011PP100010010ddddd | Vd.w = prefixsum(Qv)
				hi->instruction = HEX_INS_V6_VPREFIXQW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				sprintf(hi->mnem, "%s %s.w = prefixsum(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f200060) {
				// 00011111001vvvvvPP0uuuuu011ddddd | Vd = vrdelta(Vu,Vv)
				hi->instruction = HEX_INS_V6_VRDELTA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vrdelta(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19c000a0) {
				// 00011001110tttttPP0uuuuu101ddddd | Vdd.w = vrmpy(Vu.b,Rtt.ub)
				hi->instruction = HEX_INS_V6_VRMPYBUB_RTT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rtt32
				sprintf(hi->mnem, "%s %s.w = vrmpy(%s.b,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19a02000) {
				// 00011001101tttttPP1uuuuu000xxxxx | Vxx.w += vrmpy(Vu.b,Rtt.ub)
				hi->instruction = HEX_INS_V6_VRMPYBUB_RTT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rtt32
				sprintf(hi->mnem, "%s %s.w += vrmpy(%s.b,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19000080) {
				// 00011001000tttttPP0uuuuu100ddddd | Vd.w = vrmpy(Vu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYBUS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = vrmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x190020a0) {
				// 00011001000tttttPP1uuuuu101xxxxx | Vx.w += vrmpy(Vu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYBUS_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += vrmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0x19400080) {
				// 00011001010tttttPP0uuuuu10iddddd | Vdd.w = vrmpy(Vuu.ub,Rt.b,#Ii)
				hi->instruction = HEX_INS_V6_VRMPYBUSI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x20) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.w = vrmpy(%s.ub,%s.b,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0x19402080) {
				// 00011001010tttttPP1uuuuu10ixxxxx | Vxx.w += vrmpy(Vuu.ub,Rt.b,#Ii)
				hi->instruction = HEX_INS_V6_VRMPYBUSI_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x20) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.w += vrmpy(%s.ub,%s.b,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c000040) {
				// 00011100000vvvvvPP0uuuuu010ddddd | Vd.w = vrmpy(Vu.ub,Vv.b)
				hi->instruction = HEX_INS_V6_VRMPYBUSV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vrmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c002040) {
				// 00011100000vvvvvPP1uuuuu010xxxxx | Vx.w += vrmpy(Vu.ub,Vv.b)
				hi->instruction = HEX_INS_V6_VRMPYBUSV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vrmpy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c000020) {
				// 00011100000vvvvvPP0uuuuu001ddddd | Vd.w = vrmpy(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VRMPYBV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vrmpy(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c002020) {
				// 00011100000vvvvvPP1uuuuu001xxxxx | Vx.w += vrmpy(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VRMPYBV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w += vrmpy(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19000060) {
				// 00011001000tttttPP0uuuuu011ddddd | Vd.uw = vrmpy(Vu.ub,Rt.ub)
				hi->instruction = HEX_INS_V6_VRMPYUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw = vrmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19002080) {
				// 00011001000tttttPP1uuuuu100xxxxx | Vx.uw += vrmpy(Vu.ub,Rt.ub)
				hi->instruction = HEX_INS_V6_VRMPYUB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.uw += vrmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19c00080) {
				// 00011001110tttttPP0uuuuu100ddddd | Vdd.uw = vrmpy(Vu.ub,Rtt.ub)
				hi->instruction = HEX_INS_V6_VRMPYUB_RTT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rtt32
				sprintf(hi->mnem, "%s %s.uw = vrmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19a020e0) {
				// 00011001101tttttPP1uuuuu111xxxxx | Vxx.uw += vrmpy(Vu.ub,Rtt.ub)
				hi->instruction = HEX_INS_V6_VRMPYUB_RTT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rtt32
				sprintf(hi->mnem, "%s %s.uw += vrmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0x19a000c0) {
				// 00011001101tttttPP0uuuuu11iddddd | Vdd.uw = vrmpy(Vuu.ub,Rt.ub,#Ii)
				hi->instruction = HEX_INS_V6_VRMPYUBI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x20) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.uw = vrmpy(%s.ub,%s.ub,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0x196020c0) {
				// 00011001011tttttPP1uuuuu11ixxxxx | Vxx.uw += vrmpy(Vuu.ub,Rt.ub,#Ii)
				hi->instruction = HEX_INS_V6_VRMPYUBI_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x20) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.uw += vrmpy(%s.ub,%s.ub,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c000000) {
				// 00011100000vvvvvPP0uuuuu000ddddd | Vd.uw = vrmpy(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VRMPYUBV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw = vrmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c002000) {
				// 00011100000vvvvvPP1uuuuu000xxxxx | Vx.uw += vrmpy(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VRMPYUBV_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw += vrmpy(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19e80000) {
				// 0001100111101tttPP0uuuuu000ddddd | Vdddd.w = vrmpyz(Vu.b,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYZBB_RT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w = vrmpyz(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19c02040) {
				// 0001100111000tttPP1uuuuu010yyyyy | Vyyyy.w += vrmpyz(Vu.b,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYZBB_RT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w += vrmpyz(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19e00000) {
				// 0001100111100xxxPP0uuuuu000ddddd | Vdddd.w = vrmpyz(Vu.b,Rx.b++)
				hi->instruction = HEX_INS_V6_VRMPYZBB_RX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vrmpyz(%s.b,%s.b++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19c82040) {
				// 0001100111001xxxPP1uuuuu010yyyyy | Vyyyy.w += vrmpyz(Vu.b,Rx.b++)
				hi->instruction = HEX_INS_V6_VRMPYZBB_RX_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w += vrmpyz(%s.b,%s.b++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19f80040) {
				// 0001100111111tttPP0uuuuu010ddddd | Vdddd.w = vrmpyz(Vu.b,Rt.ub)
				hi->instruction = HEX_INS_V6_VRMPYZBUB_RT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w = vrmpyz(%s.b,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19d02020) {
				// 0001100111010tttPP1uuuuu001yyyyy | Vyyyy.w += vrmpyz(Vu.b,Rt.ub)
				hi->instruction = HEX_INS_V6_VRMPYZBUB_RT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w += vrmpyz(%s.b,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19f00040) {
				// 0001100111110xxxPP0uuuuu010ddddd | Vdddd.w = vrmpyz(Vu.b,Rx.ub++)
				hi->instruction = HEX_INS_V6_VRMPYZBUB_RX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vrmpyz(%s.b,%s.ub++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19d82020) {
				// 0001100111011xxxPP1uuuuu001yyyyy | Vyyyy.w += vrmpyz(Vu.b,Rx.ub++)
				hi->instruction = HEX_INS_V6_VRMPYZBUB_RX_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w += vrmpyz(%s.b,%s.ub++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19e80020) {
				// 0001100111101tttPP0uuuuu001ddddd | Vdddd.w = vr16mpyz(Vu.c,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYZCB_RT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w = vr16mpyz(%s.c,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19c02060) {
				// 0001100111000tttPP1uuuuu011yyyyy | Vyyyy.w += vr16mpyz(Vu.c,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYZCB_RT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w += vr16mpyz(%s.c,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19e00020) {
				// 0001100111100xxxPP0uuuuu001ddddd | Vdddd.w = vr16mpyz(Vu.c,Rx.b++)
				hi->instruction = HEX_INS_V6_VRMPYZCB_RX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vr16mpyz(%s.c,%s.b++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19c82060) {
				// 0001100111001xxxPP1uuuuu011yyyyy | Vyyyy.w += vr16mpyz(Vu.c,Rx.b++)
				hi->instruction = HEX_INS_V6_VRMPYZCB_RX_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w += vr16mpyz(%s.c,%s.b++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19e80040) {
				// 0001100111101tttPP0uuuuu010ddddd | Vdddd.w = vr16mpyzs(Vu.c,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYZCBS_RT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w = vr16mpyzs(%s.c,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19c02020) {
				// 0001100111000tttPP1uuuuu001yyyyy | Vyyyy.w += vr16mpyzs(Vu.c,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYZCBS_RT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w += vr16mpyzs(%s.c,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19e00040) {
				// 0001100111100xxxPP0uuuuu010ddddd | Vdddd.w = vr16mpyzs(Vu.c,Rx.b++)
				hi->instruction = HEX_INS_V6_VRMPYZCBS_RX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vr16mpyzs(%s.c,%s.b++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19c82020) {
				// 0001100111001xxxPP1uuuuu001yyyyy | Vyyyy.w += vr16mpyzs(Vu.c,Rx.b++)
				hi->instruction = HEX_INS_V6_VRMPYZCBS_RX_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w += vr16mpyzs(%s.c,%s.b++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19f80000) {
				// 0001100111111tttPP0uuuuu000ddddd | Vdddd.w = vr8mpyz(Vu.n,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYZNB_RT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w = vr8mpyz(%s.n,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19d02040) {
				// 0001100111010tttPP1uuuuu010yyyyy | Vyyyy.w += vr8mpyz(Vu.n,Rt.b)
				hi->instruction = HEX_INS_V6_VRMPYZNB_RT_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s.w += vr8mpyz(%s.n,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19f00000) {
				// 0001100111110xxxPP0uuuuu000ddddd | Vdddd.w = vr8mpyz(Vu.n,Rx.b++)
				hi->instruction = HEX_INS_V6_VRMPYZNB_RX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdddd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vr8mpyz(%s.n,%s.b++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfff820e0) == 0x19d82040) {
				// 0001100111011xxxPP1uuuuu010yyyyy | Vyyyy.w += vr8mpyz(Vu.n,Rx.b++)
				hi->instruction = HEX_INS_V6_VRMPYZNB_RX_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vyyyy32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x70000) >> 16); // Rx8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w += vr8mpyz(%s.n,%s.b++) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vqr(hi->ops[0].op.reg), hex_get_int_regs_low8(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19600020) {
				// 00011001011tttttPP0uuuuu001ddddd | Vd = vror(Vu,Rt)
				hi->instruction = HEX_INS_V6_VROR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s = vror(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1a8020e0) {
				// 00011010100vvvvvPP1uuuuu111ddddd | Vd.uw = vrotr(Vu.uw,Vv.uw)
				hi->instruction = HEX_INS_V6_VROTR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw = vrotr(%s.uw,%s.uw) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f6000c0) {
				// 00011111011vvvvvPP0uuuuu110ddddd | Vd.b = vround(Vu.h,Vv.h):sat
				hi->instruction = HEX_INS_V6_VROUNDHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vround(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f6000e0) {
				// 00011111011vvvvvPP0uuuuu111ddddd | Vd.ub = vround(Vu.h,Vv.h):sat
				hi->instruction = HEX_INS_V6_VROUNDHUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vround(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fe00060) {
				// 00011111111vvvvvPP0uuuuu011ddddd | Vd.ub = vround(Vu.uh,Vv.uh):sat
				hi->instruction = HEX_INS_V6_VROUNDUHUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vround(%s.uh,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fe00080) {
				// 00011111111vvvvvPP0uuuuu100ddddd | Vd.uh = vround(Vu.uw,Vv.uw):sat
				hi->instruction = HEX_INS_V6_VROUNDUWUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vround(%s.uw,%s.uw):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f600080) {
				// 00011111011vvvvvPP0uuuuu100ddddd | Vd.h = vround(Vu.w,Vv.w):sat
				hi->instruction = HEX_INS_V6_VROUNDWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vround(%s.w,%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f6000a0) {
				// 00011111011vvvvvPP0uuuuu101ddddd | Vd.uh = vround(Vu.w,Vv.w):sat
				hi->instruction = HEX_INS_V6_VROUNDWUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vround(%s.w,%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0x194000c0) {
				// 00011001010tttttPP0uuuuu11iddddd | Vdd.uw = vrsad(Vuu.ub,Rt.ub,#Ii)
				hi->instruction = HEX_INS_V6_VRSADUBI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x20) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.uw = vrsad(%s.ub,%s.ub,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0x194020c0) {
				// 00011001010tttttPP1uuuuu11ixxxxx | Vxx.uw += vrsad(Vuu.ub,Rt.ub,#Ii)
				hi->instruction = HEX_INS_V6_VRSADUBI_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x20) >> 5); // Ii
				sprintf(hi->mnem, "%s %s.uw += vrsad(%s.ub,%s.ub,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1d8020e0) {
				// 00011101100vvvvvPP1uuuuu111ddddd | Vd.w = vsatdw(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VSATDW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vsatdw(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f600040) {
				// 00011111011vvvvvPP0uuuuu010ddddd | Vd.ub = vsat(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VSATHUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vsat(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f2000c0) {
				// 00011111001vvvvvPP0uuuuu110ddddd | Vd.uh = vsat(Vu.uw,Vv.uw)
				hi->instruction = HEX_INS_V6_VSATUWUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vsat(%s.uw,%s.uw) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f600060) {
				// 00011111011vvvvvPP0uuuuu011ddddd | Vd.h = vsat(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VSATWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vsat(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e020060) {
				// 0001111000000010PP0uuuuu011ddddd | Vdd.h = vsxt(Vu.b)
				hi->instruction = HEX_INS_V6_VSB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h = vsxt(%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e020080) {
				// 0001111000000010PP0uuuuu100ddddd | Vdd.w = vsxt(Vu.h)
				hi->instruction = HEX_INS_V6_VSH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vsxt(%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f400060) {
				// 00011111010vvvvvPP0uuuuu011ddddd | Vd.h = vshuffe(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VSHUFEH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vshuffe(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19e02020) {
				// 00011001111tttttPP1yyyyy001xxxxx | vshuff(Vy,Vx,Rt)
				hi->instruction = HEX_INS_V6_VSHUFF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Vy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s vshuff(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e020000) {
				// 0001111000000010PP0uuuuu000ddddd | Vd.b = vshuff(Vu.b)
				hi->instruction = HEX_INS_V6_VSHUFFB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.b = vshuff(%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f400020) {
				// 00011111010vvvvvPP0uuuuu001ddddd | Vd.b = vshuffe(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VSHUFFEB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vshuffe(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e0100e0) {
				// 0001111000000001PP0uuuuu111ddddd | Vd.h = vshuff(Vu.h)
				hi->instruction = HEX_INS_V6_VSHUFFH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h = vshuff(%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f400040) {
				// 00011111010vvvvvPP0uuuuu010ddddd | Vd.b = vshuffo(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VSHUFFOB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vshuffo(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff0020e0) == 0x1b002060) {
				// 00011011vvvvvtttPP1uuuuu011ddddd | Vdd = vshuff(Vu,Vv,Rt)
				hi->instruction = HEX_INS_V6_VSHUFFVDD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0xf80000) >> 19); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x70000) >> 16); // Rt8
				sprintf(hi->mnem, "%s %s = vshuff(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_int_regs_low8(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f4000c0) {
				// 00011111010vvvvvPP0uuuuu110ddddd | Vdd.b = vshuffoe(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VSHUFOEB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vshuffoe(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f4000a0) {
				// 00011111010vvvvvPP0uuuuu101ddddd | Vdd.h = vshuffoe(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VSHUFOEH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vshuffoe(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f400080) {
				// 00011111010vvvvvPP0uuuuu100ddddd | Vd.h = vshuffo(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VSHUFOH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vshuffo(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c4000a0) {
				// 00011100010vvvvvPP0uuuuu101ddddd | Vd.b = vsub(Vu.b,Vv.b)
				hi->instruction = HEX_INS_V6_VSUBB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vsub(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c800060) {
				// 00011100100vvvvvPP0uuuuu011ddddd | Vdd.b = vsub(Vuu.b,Vvv.b)
				hi->instruction = HEX_INS_V6_VSUBB_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.b = vsub(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e022020) {
				// 00011110vv000010PP1uuuuu001xxxxx | if (!Qv) Vx.b -= Vu.b
				hi->instruction = HEX_INS_V6_VSUBBNQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (!%s) %s.b -= %s.b %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e0120c0) {
				// 00011110vv000001PP1uuuuu110xxxxx | if (Qv) Vx.b -= Vu.b
				hi->instruction = HEX_INS_V6_VSUBBQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (%s) %s.b -= %s.b %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1f200040) {
				// 00011111001vvvvvPP0uuuuu010ddddd | Vd.b = vsub(Vu.b,Vv.b):sat
				hi->instruction = HEX_INS_V6_VSUBBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.b = vsub(%s.b,%s.b):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ea00020) {
				// 00011110101vvvvvPP0uuuuu001ddddd | Vdd.b = vsub(Vuu.b,Vvv.b):sat
				hi->instruction = HEX_INS_V6_VSUBBSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.b = vsub(%s.b,%s.b):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1ca02080) {
				// 00011100101vvvvvPP1uuuuu1xxddddd | Vd.w = vsub(Vu.w,Vv.w,Qx):carry
				hi->instruction = HEX_INS_V6_VSUBCARRY;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x60) >> 5); // Qx4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vsub(%s.w,%s.w,%s):carry %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[3].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1da02080) {
				// 00011101101vvvvvPP1uuuuu1eeddddd | Vd.w,Qe = vsub(Vu.w,Vv.w):carry
				hi->instruction = HEX_INS_V6_VSUBCARRYO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Qe4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w,%s = vsub(%s.w,%s.w):carry %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c4000c0) {
				// 00011100010vvvvvPP0uuuuu110ddddd | Vd.h = vsub(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VSUBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vsub(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c800080) {
				// 00011100100vvvvvPP0uuuuu100ddddd | Vdd.h = vsub(Vuu.h,Vvv.h)
				hi->instruction = HEX_INS_V6_VSUBH_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.h = vsub(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e022040) {
				// 00011110vv000010PP1uuuuu010xxxxx | if (!Qv) Vx.h -= Vu.h
				hi->instruction = HEX_INS_V6_VSUBHNQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (!%s) %s.h -= %s.h %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e0120e0) {
				// 00011110vv000001PP1uuuuu111xxxxx | if (Qv) Vx.h -= Vu.h
				hi->instruction = HEX_INS_V6_VSUBHQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (%s) %s.h -= %s.h %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c600040) {
				// 00011100011vvvvvPP0uuuuu010ddddd | Vd.h = vsub(Vu.h,Vv.h):sat
				hi->instruction = HEX_INS_V6_VSUBHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vsub(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ca00000) {
				// 00011100101vvvvvPP0uuuuu000ddddd | Vdd.h = vsub(Vuu.h,Vvv.h):sat
				hi->instruction = HEX_INS_V6_VSUBHSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.h = vsub(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ca000e0) {
				// 00011100101vvvvvPP0uuuuu111ddddd | Vdd.w = vsub(Vu.h,Vv.h)
				hi->instruction = HEX_INS_V6_VSUBHW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vsub(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ca000a0) {
				// 00011100101vvvvvPP0uuuuu101ddddd | Vdd.h = vsub(Vu.ub,Vv.ub)
				hi->instruction = HEX_INS_V6_VSUBUBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.h = vsub(%s.ub,%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c600000) {
				// 00011100011vvvvvPP0uuuuu000ddddd | Vd.ub = vsub(Vu.ub,Vv.ub):sat
				hi->instruction = HEX_INS_V6_VSUBUBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vsub(%s.ub,%s.ub):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c8000c0) {
				// 00011100100vvvvvPP0uuuuu110ddddd | Vdd.ub = vsub(Vuu.ub,Vvv.ub):sat
				hi->instruction = HEX_INS_V6_VSUBUBSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.ub = vsub(%s.ub,%s.ub):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ea000a0) {
				// 00011110101vvvvvPP0uuuuu101ddddd | Vd.ub = vsub(Vu.ub,Vv.b):sat
				hi->instruction = HEX_INS_V6_VSUBUBUBB_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.ub = vsub(%s.ub,%s.b):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c600020) {
				// 00011100011vvvvvPP0uuuuu001ddddd | Vd.uh = vsub(Vu.uh,Vv.uh):sat
				hi->instruction = HEX_INS_V6_VSUBUHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uh = vsub(%s.uh,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c8000e0) {
				// 00011100100vvvvvPP0uuuuu111ddddd | Vdd.uh = vsub(Vuu.uh,Vvv.uh):sat
				hi->instruction = HEX_INS_V6_VSUBUHSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.uh = vsub(%s.uh,%s.uh):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ca000c0) {
				// 00011100101vvvvvPP0uuuuu110ddddd | Vdd.w = vsub(Vu.uh,Vv.uh)
				hi->instruction = HEX_INS_V6_VSUBUHW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vsub(%s.uh,%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1fc00080) {
				// 00011111110vvvvvPP0uuuuu100ddddd | Vd.uw = vsub(Vu.uw,Vv.uw):sat
				hi->instruction = HEX_INS_V6_VSUBUWSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.uw = vsub(%s.uw,%s.uw):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ea00060) {
				// 00011110101vvvvvPP0uuuuu011ddddd | Vdd.uw = vsub(Vuu.uw,Vvv.uw):sat
				hi->instruction = HEX_INS_V6_VSUBUWSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.uw = vsub(%s.uw,%s.uw):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c4000e0) {
				// 00011100010vvvvvPP0uuuuu111ddddd | Vd.w = vsub(Vu.w,Vv.w)
				hi->instruction = HEX_INS_V6_VSUBW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vsub(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c8000a0) {
				// 00011100100vvvvvPP0uuuuu101ddddd | Vdd.w = vsub(Vuu.w,Vvv.w)
				hi->instruction = HEX_INS_V6_VSUBW_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.w = vsub(%s.w,%s.w) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e022060) {
				// 00011110vv000010PP1uuuuu011xxxxx | if (!Qv) Vx.w -= Vu.w
				hi->instruction = HEX_INS_V6_VSUBWNQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (!%s) %s.w -= %s.w %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f20e0) == 0x1e022000) {
				// 00011110vv000010PP1uuuuu000xxxxx | if (Qv) Vx.w -= Vu.w
				hi->instruction = HEX_INS_V6_VSUBWQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s if (%s) %s.w -= %s.w %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c600060) {
				// 00011100011vvvvvPP0uuuuu011ddddd | Vd.w = vsub(Vu.w,Vv.w):sat
				hi->instruction = HEX_INS_V6_VSUBWSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s.w = vsub(%s.w,%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1ca00020) {
				// 00011100101vvvvvPP0uuuuu001ddddd | Vdd.w = vsub(Vuu.w,Vvv.w):sat
				hi->instruction = HEX_INS_V6_VSUBWSAT_DV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vvv32
				sprintf(hi->mnem, "%s %s.w = vsub(%s.w,%s.w):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0x1ea02000) {
				// 00011110101vvvvvPP1uuuuu0ttddddd | Vdd = vswap(Qt,Vu,Vv)
				hi->instruction = HEX_INS_V6_VSWAP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Qt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vswap(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_qr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19000000) {
				// 00011001000tttttPP0uuuuu000ddddd | Vdd.h = vtmpy(Vuu.b,Rt.b)
				hi->instruction = HEX_INS_V6_VTMPYB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = VTMPy(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19002000) {
				// 00011001000tttttPP1uuuuu000xxxxx | Vxx.h += vtmpy(Vuu.b,Rt.b)
				hi->instruction = HEX_INS_V6_VTMPYB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += VTMPy(%s.b,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19000020) {
				// 00011001000tttttPP0uuuuu001ddddd | Vdd.h = vtmpy(Vuu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VTMPYBUS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h = VTMPy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19002020) {
				// 00011001000tttttPP1uuuuu001xxxxx | Vxx.h += vtmpy(Vuu.ub,Rt.b)
				hi->instruction = HEX_INS_V6_VTMPYBUS_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.h += VTMPy(%s.ub,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19a00080) {
				// 00011001101tttttPP0uuuuu100ddddd | Vdd.w = vtmpy(Vuu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VTMPYHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w = VTMPy(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x19002040) {
				// 00011001000tttttPP1uuuuu010xxxxx | Vxx.w += vtmpy(Vuu.h,Rt.b)
				hi->instruction = HEX_INS_V6_VTMPYHB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vuu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s.w += VTMPy(%s.h,%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_wr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e010040) {
				// 0001111000000001PP0uuuuu010ddddd | Vdd.h = vunpack(Vu.b)
				hi->instruction = HEX_INS_V6_VUNPACKB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h = vunpack(%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e010060) {
				// 0001111000000001PP0uuuuu011ddddd | Vdd.w = vunpack(Vu.h)
				hi->instruction = HEX_INS_V6_VUNPACKH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w = vunpack(%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e002000) {
				// 0001111000000000PP1uuuuu000xxxxx | Vxx.h |= vunpacko(Vu.b)
				hi->instruction = HEX_INS_V6_VUNPACKOB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.h |= vunpacko(%s.b) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e002020) {
				// 0001111000000000PP1uuuuu001xxxxx | Vxx.w |= vunpacko(Vu.h)
				hi->instruction = HEX_INS_V6_VUNPACKOH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.w |= vunpacko(%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e010000) {
				// 0001111000000001PP0uuuuu000ddddd | Vdd.uh = vunpack(Vu.ub)
				hi->instruction = HEX_INS_V6_VUNPACKUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.uh = vunpack(%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e010020) {
				// 0001111000000001PP0uuuuu001ddddd | Vdd.uw = vunpack(Vu.uh)
				hi->instruction = HEX_INS_V6_VUNPACKUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.uw = vunpack(%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0x1e002480) {
				// 0001111000000000PP10010010000000 | vwhist128
				hi->instruction = HEX_INS_V6_VWHIST128;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s vwhist128 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3eff) == 0x1e002680) {
				// 0001111000000000PP10011i10000000 | vwhist128(#Ii)
				hi->instruction = HEX_INS_V6_VWHIST128M;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = (((hi_u32)&0x100) >> 8); // Ii
				sprintf(hi->mnem, "%s vwhist128(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3fff) == 0x1e022480) {
				// 00011110vv000010PP10010010000000 | vwhist128(Qv)
				hi->instruction = HEX_INS_V6_VWHIST128Q;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				sprintf(hi->mnem, "%s vwhist128(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3eff) == 0x1e022680) {
				// 00011110vv000010PP10011i10000000 | vwhist128(Qv,#Ii)
				hi->instruction = HEX_INS_V6_VWHIST128QM;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x100) >> 8); // Ii
				sprintf(hi->mnem, "%s vwhist128(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0x1e002280) {
				// 0001111000000000PP10001010000000 | vwhist256
				hi->instruction = HEX_INS_V6_VWHIST256;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s vwhist256 %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0x1e002380) {
				// 0001111000000000PP10001110000000 | vwhist256:sat
				hi->instruction = HEX_INS_V6_VWHIST256_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s vwhist256:sat %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3fff) == 0x1e022280) {
				// 00011110vv000010PP10001010000000 | vwhist256(Qv)
				hi->instruction = HEX_INS_V6_VWHIST256Q;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				sprintf(hi->mnem, "%s vwhist256(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff3f3fff) == 0x1e022380) {
				// 00011110vv000010PP10001110000000 | vwhist256(Qv):sat
				hi->instruction = HEX_INS_V6_VWHIST256Q_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0xc00000) >> 22); // Qv4
				sprintf(hi->mnem, "%s vwhist256(%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x1c2000e0) {
				// 00011100001vvvvvPP0uuuuu111ddddd | Vd = vxor(Vu,Vv)
				hi->instruction = HEX_INS_V6_VXOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Vv32
				sprintf(hi->mnem, "%s %s = vxor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e020020) {
				// 0001111000000010PP0uuuuu001ddddd | Vdd.uh = vzxt(Vu.ub)
				hi->instruction = HEX_INS_V6_VZB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.uh = vzxt(%s.ub) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e0) == 0x1e020040) {
				// 0001111000000010PP0uuuuu010ddddd | Vdd.uw = vzxt(Vu.uh)
				hi->instruction = HEX_INS_V6_VZH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				sprintf(hi->mnem, "%s %s.uw = vzxt(%s.uh) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_wr(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x19a00120) {
				// 00011001101tttttPP000001001ddddd | Vd = zextract(Rt)
				hi->instruction = HEX_INS_V6_ZEXTRACT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				sprintf(hi->mnem, "%s %s = zextract(%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x2:
			if ((hi_u32 & 0xffc82001) == 0x20400000) {
				// 0010000001ii0sssPP0tttttiiiiiii0 | if (!cmp.eq(Ns.new,Rt)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQ_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.eq(%s.new,%s)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x20402000) {
				// 0010000001ii0sssPP1tttttiiiiiii0 | if (!cmp.eq(Ns.new,Rt)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQ_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.eq(%s.new,%s)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x20000000) {
				// 0010000000ii0sssPP0tttttiiiiiii0 | if (cmp.eq(Ns.new,Rt)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQ_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.eq(%s.new,%s)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x20002000) {
				// 0010000000ii0sssPP1tttttiiiiiii0 | if (cmp.eq(Ns.new,Rt)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQ_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.eq(%s.new,%s)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x24400000) {
				// 0010010001ii0sssPP0IIIIIiiiiiii0 | if (!cmp.eq(Ns.new,#II)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQI_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.eq(%s.new,#0x%x)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x24402000) {
				// 0010010001ii0sssPP1IIIIIiiiiiii0 | if (!cmp.eq(Ns.new,#II)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQI_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.eq(%s.new,#0x%x)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x24000000) {
				// 0010010000ii0sssPP0IIIIIiiiiiii0 | if (cmp.eq(Ns.new,#II)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQI_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.eq(%s.new,#0x%x)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x24002000) {
				// 0010010000ii0sssPP1IIIIIiiiiiii0 | if (cmp.eq(Ns.new,#II)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQI_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.eq(%s.new,#0x%x)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x26400000) {
				// 0010011001ii0sssPP000000iiiiiii0 | if (!cmp.eq(Ns.new,#n1)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.eq(%s.new,#-1)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x26402000) {
				// 0010011001ii0sssPP100000iiiiiii0 | if (!cmp.eq(Ns.new,#n1)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.eq(%s.new,#-1)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x26000000) {
				// 0010011000ii0sssPP000000iiiiiii0 | if (cmp.eq(Ns.new,#n1)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.eq(%s.new,#-1)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x26002000) {
				// 0010011000ii0sssPP100000iiiiiii0 | if (cmp.eq(Ns.new,#n1)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPEQN1_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.eq(%s.new,#-1)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x20c00000) {
				// 0010000011ii0sssPP0tttttiiiiiii0 | if (!cmp.gt(Ns.new,Rt)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGT_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gt(%s.new,%s)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x20c02000) {
				// 0010000011ii0sssPP1tttttiiiiiii0 | if (!cmp.gt(Ns.new,Rt)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGT_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gt(%s.new,%s)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x20800000) {
				// 0010000010ii0sssPP0tttttiiiiiii0 | if (cmp.gt(Ns.new,Rt)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGT_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gt(%s.new,%s)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x20802000) {
				// 0010000010ii0sssPP1tttttiiiiiii0 | if (cmp.gt(Ns.new,Rt)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGT_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gt(%s.new,%s)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x24c00000) {
				// 0010010011ii0sssPP0IIIIIiiiiiii0 | if (!cmp.gt(Ns.new,#II)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTI_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gt(%s.new,#0x%x)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x24c02000) {
				// 0010010011ii0sssPP1IIIIIiiiiiii0 | if (!cmp.gt(Ns.new,#II)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTI_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gt(%s.new,#0x%x)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x24800000) {
				// 0010010010ii0sssPP0IIIIIiiiiiii0 | if (cmp.gt(Ns.new,#II)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTI_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gt(%s.new,#0x%x)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x24802000) {
				// 0010010010ii0sssPP1IIIIIiiiiiii0 | if (cmp.gt(Ns.new,#II)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTI_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gt(%s.new,#0x%x)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x26c00000) {
				// 0010011011ii0sssPP000000iiiiiii0 | if (!cmp.gt(Ns.new,#n1)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gt(%s.new,#-1)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x26c02000) {
				// 0010011011ii0sssPP100000iiiiiii0 | if (!cmp.gt(Ns.new,#n1)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gt(%s.new,#-1)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x26800000) {
				// 0010011010ii0sssPP000000iiiiiii0 | if (cmp.gt(Ns.new,#n1)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gt(%s.new,#-1)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x26802000) {
				// 0010011010ii0sssPP100000iiiiiii0 | if (cmp.gt(Ns.new,#n1)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTN1_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gt(%s.new,#-1)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x21400000) {
				// 0010000101ii0sssPP0tttttiiiiiii0 | if (!cmp.gtu(Ns.new,Rt)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTU_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gtu(%s.new,%s)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x21402000) {
				// 0010000101ii0sssPP1tttttiiiiiii0 | if (!cmp.gtu(Ns.new,Rt)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTU_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gtu(%s.new,%s)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x21000000) {
				// 0010000100ii0sssPP0tttttiiiiiii0 | if (cmp.gtu(Ns.new,Rt)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTU_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gtu(%s.new,%s)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x21002000) {
				// 0010000100ii0sssPP1tttttiiiiiii0 | if (cmp.gtu(Ns.new,Rt)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTU_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gtu(%s.new,%s)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x25400000) {
				// 0010010101ii0sssPP0IIIIIiiiiiii0 | if (!cmp.gtu(Ns.new,#II)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gtu(%s.new,#0x%x)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x25402000) {
				// 0010010101ii0sssPP1IIIIIiiiiiii0 | if (!cmp.gtu(Ns.new,#II)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gtu(%s.new,#0x%x)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x25000000) {
				// 0010010100ii0sssPP0IIIIIiiiiiii0 | if (cmp.gtu(Ns.new,#II)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gtu(%s.new,#0x%x)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x25002000) {
				// 0010010100ii0sssPP1IIIIIiiiiiii0 | if (cmp.gtu(Ns.new,#II)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPGTUI_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gtu(%s.new,#0x%x)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x21c00000) {
				// 0010000111ii0sssPP0tttttiiiiiii0 | if (!cmp.gt(Rt,Ns.new)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPLT_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gt(%s,%s.new)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x21c02000) {
				// 0010000111ii0sssPP1tttttiiiiiii0 | if (!cmp.gt(Rt,Ns.new)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPLT_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gt(%s,%s.new)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x21800000) {
				// 0010000110ii0sssPP0tttttiiiiiii0 | if (cmp.gt(Rt,Ns.new)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPLT_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gt(%s,%s.new)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x21802000) {
				// 0010000110ii0sssPP1tttttiiiiiii0 | if (cmp.gt(Rt,Ns.new)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPLT_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gt(%s,%s.new)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x22400000) {
				// 0010001001ii0sssPP0tttttiiiiiii0 | if (!cmp.gtu(Rt,Ns.new)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPLTU_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gtu(%s,%s.new)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x22402000) {
				// 0010001001ii0sssPP1tttttiiiiiii0 | if (!cmp.gtu(Rt,Ns.new)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPLTU_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!cmp.gtu(%s,%s.new)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x22000000) {
				// 0010001000ii0sssPP0tttttiiiiiii0 | if (cmp.gtu(Rt,Ns.new)) jump:nt Ii
				hi->instruction = HEX_INS_J4_CMPLTU_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gtu(%s,%s.new)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc82001) == 0x22002000) {
				// 0010001000ii0sssPP1tttttiiiiiii0 | if (cmp.gtu(Rt,Ns.new)) jump:t Ii
				hi->instruction = HEX_INS_J4_CMPLTU_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (cmp.gtu(%s,%s.new)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), addr + (st32)hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x25c00000) {
				// 0010010111ii0sssPP000000iiiiiii0 | if (!tstbit(Ns.new,#0)) jump:nt Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_F_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!tstbit(%s.new,#0)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x25c02000) {
				// 0010010111ii0sssPP100000iiiiiii0 | if (!tstbit(Ns.new,#0)) jump:t Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_F_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!tstbit(%s.new,#0)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x25800000) {
				// 0010010110ii0sssPP000000iiiiiii0 | if (tstbit(Ns.new,#0)) jump:nt Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_T_JUMPNV_NT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (tstbit(%s.new,#0)) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc83f01) == 0x25802000) {
				// 0010010110ii0sssPP100000iiiiiii0 | if (tstbit(Ns.new,#0)) jump:t Ii
				hi->instruction = HEX_INS_J4_TSTBIT0_T_JUMPNV_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x70000) >> 16); // Ns8
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x300000) >> 13) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (tstbit(%s.new,#0)) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x280000e0) {
				// 00101000000tttttPPi00iii111ddddd | Vd = vmemu(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32UB_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vmemu(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x290000e0) {
				// 00101001000xxxxxPP000iii111ddddd | Vd = vmemu(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32UB_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vmemu(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b0000e0) {
				// 00101011000xxxxxPPu00000111ddddd | Vd = vmemu(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32UB_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = vmemu(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x28000000) {
				// 00101000000tttttPPi00iii000ddddd | Vd = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x28000020) {
				// 00101000000tttttPPi00iii001ddddd | Vd.cur = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_CUR_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s.cur = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x288000a0) {
				// 00101000100tttttPPivviii101ddddd | if (!Pv) Vd.cur = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_CUR_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s.cur = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x298000a0) {
				// 00101001100xxxxxPP0vviii101ddddd | if (!Pv) Vd.cur = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_CUR_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s.cur = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2b8000a0) {
				// 00101011100xxxxxPPuvv000101ddddd | if (!Pv) Vd.cur = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_CUR_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (!%s) %s.cur = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x29000020) {
				// 00101001000xxxxxPP000iii001ddddd | Vd.cur = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_CUR_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s.cur = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b000020) {
				// 00101011000xxxxxPPu00000001ddddd | Vd.cur = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_CUR_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s.cur = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28800080) {
				// 00101000100tttttPPivviii100ddddd | if (Pv) Vd.cur = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_CUR_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s.cur = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29800080) {
				// 00101001100xxxxxPP0vviii100ddddd | if (Pv) Vd.cur = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_CUR_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s.cur = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2b800080) {
				// 00101011100xxxxxPPuvv000100ddddd | if (Pv) Vd.cur = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_CUR_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (%s) %s.cur = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28800060) {
				// 00101000100tttttPPivviii011ddddd | if (!Pv) Vd = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29800060) {
				// 00101001100xxxxxPP0vviii011ddddd | if (!Pv) Vd = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2b800060) {
				// 00101011100xxxxxPPuvv000011ddddd | if (!Pv) Vd = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (!%s) %s = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x28400000) {
				// 00101000010tttttPPi00iii000ddddd | Vd = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x28400020) {
				// 00101000010tttttPPi00iii001ddddd | Vd.cur = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s.cur = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28c000a0) {
				// 00101000110tttttPPivviii101ddddd | if (!Pv) Vd.cur = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s.cur = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29c000a0) {
				// 00101001110xxxxxPP0vviii101ddddd | if (!Pv) Vd.cur = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s.cur = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2bc000a0) {
				// 00101011110xxxxxPPuvv000101ddddd | if (!Pv) Vd.cur = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (!%s) %s.cur = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x29400020) {
				// 00101001010xxxxxPP000iii001ddddd | Vd.cur = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s.cur = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b400020) {
				// 00101011010xxxxxPPu00000001ddddd | Vd.cur = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s.cur = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28c00080) {
				// 00101000110tttttPPivviii100ddddd | if (Pv) Vd.cur = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s.cur = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29c00080) {
				// 00101001110xxxxxPP0vviii100ddddd | if (Pv) Vd.cur = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s.cur = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2bc00080) {
				// 00101011110xxxxxPPuvv000100ddddd | if (Pv) Vd.cur = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_CUR_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (%s) %s.cur = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28c00060) {
				// 00101000110tttttPPivviii011ddddd | if (!Pv) Vd = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29c00060) {
				// 00101001110xxxxxPP0vviii011ddddd | if (!Pv) Vd = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2bc00060) {
				// 00101011110xxxxxPPuvv000011ddddd | if (!Pv) Vd = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (!%s) %s = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x29400000) {
				// 00101001010xxxxxPP000iii000ddddd | Vd = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b400000) {
				// 00101011010xxxxxPPu00000000ddddd | Vd = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28c00040) {
				// 00101000110tttttPPivviii010ddddd | if (Pv) Vd = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29c00040) {
				// 00101001110xxxxxPP0vviii010ddddd | if (Pv) Vd = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2bc00040) {
				// 00101011110xxxxxPPuvv000010ddddd | if (Pv) Vd = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (%s) %s = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x28400040) {
				// 00101000010tttttPPi00iii010ddddd | Vd.tmp = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s.tmp = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28c000e0) {
				// 00101000110tttttPPivviii111ddddd | if (!Pv) Vd.tmp = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s.tmp = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29c000e0) {
				// 00101001110xxxxxPP0vviii111ddddd | if (!Pv) Vd.tmp = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s.tmp = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2bc000e0) {
				// 00101011110xxxxxPPuvv000111ddddd | if (!Pv) Vd.tmp = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (!%s) %s.tmp = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x29400040) {
				// 00101001010xxxxxPP000iii010ddddd | Vd.tmp = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s.tmp = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b400040) {
				// 00101011010xxxxxPPu00000010ddddd | Vd.tmp = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s.tmp = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28c000c0) {
				// 00101000110tttttPPivviii110ddddd | if (Pv) Vd.tmp = vmem(Rt+#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s.tmp = vmem(%s+%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29c000c0) {
				// 00101001110xxxxxPP0vviii110ddddd | if (Pv) Vd.tmp = vmem(Rx++#Ii):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s.tmp = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2bc000c0) {
				// 00101011110xxxxxPPuvv000110ddddd | if (Pv) Vd.tmp = vmem(Rx++Mu):nt
				hi->instruction = HEX_INS_V6_VL32B_NT_TMP_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (%s) %s.tmp = vmem(%s++%s):nt %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x29000000) {
				// 00101001000xxxxxPP000iii000ddddd | Vd = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b000000) {
				// 00101011000xxxxxPPu00000000ddddd | Vd = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28800040) {
				// 00101000100tttttPPivviii010ddddd | if (Pv) Vd = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29800040) {
				// 00101001100xxxxxPP0vviii010ddddd | if (Pv) Vd = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2b800040) {
				// 00101011100xxxxxPPuvv000010ddddd | if (Pv) Vd = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (%s) %s = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x28000040) {
				// 00101000000tttttPPi00iii010ddddd | Vd.tmp = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_TMP_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s.tmp = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x288000e0) {
				// 00101000100tttttPPivviii111ddddd | if (!Pv) Vd.tmp = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_TMP_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s.tmp = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x298000e0) {
				// 00101001100xxxxxPP0vviii111ddddd | if (!Pv) Vd.tmp = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_TMP_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s.tmp = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2b8000e0) {
				// 00101011100xxxxxPPuvv000111ddddd | if (!Pv) Vd.tmp = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_TMP_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (!%s) %s.tmp = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x29000040) {
				// 00101001000xxxxxPP000iii010ddddd | Vd.tmp = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_TMP_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s.tmp = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b000040) {
				// 00101011000xxxxxPPu00000010ddddd | Vd.tmp = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_TMP_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s.tmp = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x288000c0) {
				// 00101000100tttttPPivviii110ddddd | if (Pv) Vd.tmp = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_VL32B_TMP_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s.tmp = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x298000c0) {
				// 00101001100xxxxxPP0vviii110ddddd | if (Pv) Vd.tmp = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_VL32B_TMP_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[3].op.imm & (1 << 2)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s.tmp = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2b8000c0) {
				// 00101011100xxxxxPPuvv000110ddddd | if (Pv) Vd.tmp = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_VL32B_TMP_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Vd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (%s) %s.tmp = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x282000e0) {
				// 00101000001tttttPPi00iii111sssss | vmemu(Rt+#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmemu(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28a000e0) {
				// 00101000101tttttPPivviii111sssss | if (!Pv) vmemu(Rt+#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmemu(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29a000e0) {
				// 00101001101xxxxxPP0vviii111sssss | if (!Pv) vmemu(Rx++#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmemu(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2ba000e0) {
				// 00101011101xxxxxPPuvv000111sssss | if (!Pv) vmemu(Rx++Mu) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmemu(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x292000e0) {
				// 00101001001xxxxxPP000iii111sssss | vmemu(Rx++#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[1].op.imm & (1 << 2)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmemu(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b2000e0) {
				// 00101011001xxxxxPPu00000111sssss | vmemu(Rx++Mu) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmemu(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28a000c0) {
				// 00101000101tttttPPivviii110sssss | if (Pv) vmemu(Rt+#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmemu(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29a000c0) {
				// 00101001101xxxxxPP0vviii110sssss | if (Pv) vmemu(Rx++#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmemu(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2ba000c0) {
				// 00101011101xxxxxPPuvv000110sssss | if (Pv) vmemu(Rx++Mu) = Vs
				hi->instruction = HEX_INS_V6_VS32UB_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmemu(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x28200000) {
				// 00101000001tttttPPi00iii000sssss | vmem(Rt+#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmem(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018f8) == 0x28200020) {
				// 00101000001tttttPPi00iii00100sss | vmem(Rt+#Ii) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s vmem(%s+%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000f8) == 0x28a00068) {
				// 00101000101tttttPPivviii01101sss | if (!Pv) vmem(Rt+#Ii) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (!%s) vmem(%s+%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020f8) == 0x29a00068) {
				// 00101001101xxxxxPP0vviii01101sss | if (!Pv) vmem(Rx++#Ii) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007f8) == 0x2ba00068) {
				// 00101011101xxxxxPPuvv00001101sss | if (!Pv) vmem(Rx++Mu) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038f8) == 0x29200020) {
				// 00101001001xxxxxPP000iii00100sss | vmem(Rx++#Ii) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[1].op.imm & (1 << 2)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s vmem(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01ff8) == 0x2b200020) {
				// 00101011001xxxxxPPu0000000100sss | vmem(Rx++Mu) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s vmem(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000f8) == 0x28a00040) {
				// 00101000101tttttPPivviii01000sss | if (Pv) vmem(Rt+#Ii) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (%s) vmem(%s+%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020f8) == 0x29a00040) {
				// 00101001101xxxxxPP0vviii01000sss | if (Pv) vmem(Rx++#Ii) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007f8) == 0x2ba00040) {
				// 00101011101xxxxxPPuvv00001000sss | if (Pv) vmem(Rx++Mu) = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NEW_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28a00020) {
				// 00101000101tttttPPivviii001sssss | if (!Pv) vmem(Rt+#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29a00020) {
				// 00101001101xxxxxPP0vviii001sssss | if (!Pv) vmem(Rx++#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2ba00020) {
				// 00101011101xxxxxPPuvv000001sssss | if (!Pv) vmem(Rx++Mu) = Vs
				hi->instruction = HEX_INS_V6_VS32B_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28800020) {
				// 00101000100tttttPPivviii001sssss | if (!Qv) vmem(Rt+#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_NQPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29800020) {
				// 00101001100xxxxxPP0vviii001sssss | if (!Qv) vmem(Rx++#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_NQPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2b800020) {
				// 00101011100xxxxxPPuvv000001sssss | if (!Qv) vmem(Rx++Mu) = Vs
				hi->instruction = HEX_INS_V6_VS32B_NQPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018e0) == 0x28600000) {
				// 00101000011tttttPPi00iii000sssss | vmem(Rt+#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmem(%s+%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018f8) == 0x28600020) {
				// 00101000011tttttPPi00iii00100sss | vmem(Rt+#Ii):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s vmem(%s+%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000f8) == 0x28e00078) {
				// 00101000111tttttPPivviii01111sss | if (!Pv) vmem(Rt+#Ii):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (!%s) vmem(%s+%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020f8) == 0x29e00078) {
				// 00101001111xxxxxPP0vviii01111sss | if (!Pv) vmem(Rx++#Ii):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007f8) == 0x2be00078) {
				// 00101011111xxxxxPPuvv00001111sss | if (!Pv) vmem(Rx++Mu):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038f8) == 0x29600020) {
				// 00101001011xxxxxPP000iii00100sss | vmem(Rx++#Ii):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[1].op.imm & (1 << 2)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s vmem(%s++%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01ff8) == 0x2b600020) {
				// 00101011011xxxxxPPu0000000100sss | vmem(Rx++Mu):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s vmem(%s++%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000f8) == 0x28e00050) {
				// 00101000111tttttPPivviii01010sss | if (Pv) vmem(Rt+#Ii):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (%s) vmem(%s+%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020f8) == 0x29e00050) {
				// 00101001111xxxxxPP0vviii01010sss | if (Pv) vmem(Rx++#Ii):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007f8) == 0x2be00050) {
				// 00101011111xxxxxPPuvv00001010sss | if (Pv) vmem(Rx++Mu):nt = Os.new
				hi->instruction = HEX_INS_V6_VS32B_NT_NEW_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Os8
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s):nt = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28e00020) {
				// 00101000111tttttPPivviii001sssss | if (!Pv) vmem(Rt+#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_NPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s+%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29e00020) {
				// 00101001111xxxxxPP0vviii001sssss | if (!Pv) vmem(Rx++#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_NPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2be00020) {
				// 00101011111xxxxxPPuvv000001sssss | if (!Pv) vmem(Rx++Mu):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_NPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28c00020) {
				// 00101000110tttttPPivviii001sssss | if (!Qv) vmem(Rt+#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_NQPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s+%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29c00020) {
				// 00101001110xxxxxPP0vviii001sssss | if (!Qv) vmem(Rx++#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_NQPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2bc00020) {
				// 00101011110xxxxxPPuvv000001sssss | if (!Qv) vmem(Rx++Mu):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_NQPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (!%s) vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x29600000) {
				// 00101001011xxxxxPP000iii000sssss | vmem(Rx++#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[1].op.imm & (1 << 2)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b600000) {
				// 00101011011xxxxxPPu00000000sssss | vmem(Rx++Mu):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28e00000) {
				// 00101000111tttttPPivviii000sssss | if (Pv) vmem(Rt+#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s+%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29e00000) {
				// 00101001111xxxxxPP0vviii000sssss | if (Pv) vmem(Rx++#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2be00000) {
				// 00101011111xxxxxPPuvv000000sssss | if (Pv) vmem(Rx++Mu):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28c00000) {
				// 00101000110tttttPPivviii000sssss | if (Qv) vmem(Rt+#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_QPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s+%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29c00000) {
				// 00101001110xxxxxPP0vviii000sssss | if (Qv) vmem(Rx++#Ii):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_QPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2bc00000) {
				// 00101011110xxxxxPPuvv000000sssss | if (Qv) vmem(Rx++Mu):nt = Vs
				hi->instruction = HEX_INS_V6_VS32B_NT_QPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s):nt = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x29200000) {
				// 00101001001xxxxxPP000iii000sssss | vmem(Rx++#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[1].op.imm & (1 << 2)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2b200000) {
				// 00101011001xxxxxPPu00000000sssss | vmem(Rx++Mu) = Vs
				hi->instruction = HEX_INS_V6_VS32B_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28a00000) {
				// 00101000101tttttPPivviii000sssss | if (Pv) vmem(Rt+#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29a00000) {
				// 00101001101xxxxxPP0vviii000sssss | if (Pv) vmem(Rx++#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2ba00000) {
				// 00101011101xxxxxPPuvv000000sssss | if (Pv) vmem(Rx++Mu) = Vs
				hi->instruction = HEX_INS_V6_VS32B_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x28800000) {
				// 00101000100tttttPPivviii000sssss | if (Qv) vmem(Rt+#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_QPRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x29800000) {
				// 00101001100xxxxxPP0vviii000sssss | if (Qv) vmem(Rx++#Ii) = Vs
				hi->instruction = HEX_INS_V6_VS32B_QPRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), signed_imm, hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007e0) == 0x2b800000) {
				// 00101011100xxxxxPPuvv000000sssss | if (Qv) vmem(Rx++Mu) = Vs
				hi->instruction = HEX_INS_V6_VS32B_QPRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Qv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vs32
				sprintf(hi->mnem, "%s if (%s) vmem(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0x28200028) {
				// 00101000001tttttPPi00iii00101000 | vmem(Rt+#Ii):scatter_release
				hi->instruction = HEX_INS_V6_VS32B_SRLS_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				sprintf(hi->mnem, "%s vmem(%s+%s):scatter_release %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038ff) == 0x29200028) {
				// 00101001001xxxxxPP000iii00101000 | vmem(Rx++#Ii):scatter_release
				hi->instruction = HEX_INS_V6_VS32B_SRLS_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[1].op.imm & (1 << 2)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				sprintf(hi->mnem, "%s vmem(%s++%s):scatter_release %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fff) == 0x2b200028) {
				// 00101011001xxxxxPPu0000000101000 | vmem(Rx++Mu):scatter_release
				hi->instruction = HEX_INS_V6_VS32B_SRLS_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s vmem(%s++%s):scatter_release %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2f000100) {
				// 00101111000tttttPPu00001000vvvvv | vtmp.h = vgather(Rt,Mu,Vv.h).h
				hi->instruction = HEX_INS_V6_VGATHERMH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vv32
				sprintf(hi->mnem, "%s VTMP.h = vgather(%s,%s,%s.h).h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01f80) == 0x2f000500) {
				// 00101111000tttttPPu001010ssvvvvv | if (Qs) vtmp.h = vgather(Rt,Mu,Vv.h).h
				hi->instruction = HEX_INS_V6_VGATHERMHQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Qs4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vv32
				sprintf(hi->mnem, "%s if (%s) VTMP.h = vgather(%s,%s,%s.h).h %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2f000200) {
				// 00101111000tttttPPu00010000vvvvv | vtmp.h = vgather(Rt,Mu,Vvv.w).h
				hi->instruction = HEX_INS_V6_VGATHERMHW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vvv32
				sprintf(hi->mnem, "%s VTMP.h = vgather(%s,%s,%s.w).h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01f80) == 0x2f000600) {
				// 00101111000tttttPPu001100ssvvvvv | if (Qs) vtmp.h = vgather(Rt,Mu,Vvv.w).h
				hi->instruction = HEX_INS_V6_VGATHERMHWQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Qs4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vvv32
				sprintf(hi->mnem, "%s if (%s) VTMP.h = vgather(%s,%s,%s.w).h %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_wr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x2f000000) {
				// 00101111000tttttPPu00000000vvvvv | vtmp.w = vgather(Rt,Mu,Vv.w).w
				hi->instruction = HEX_INS_V6_VGATHERMW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Vv32
				sprintf(hi->mnem, "%s VTMP.w = vgather(%s,%s,%s.w).w %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01f80) == 0x2f000400) {
				// 00101111000tttttPPu001000ssvvvvv | if (Qs) vtmp.w = vgather(Rt,Mu,Vv.w).w
				hi->instruction = HEX_INS_V6_VGATHERMWQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Qs4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vv32
				sprintf(hi->mnem, "%s if (%s) VTMP.w = vgather(%s,%s,%s.w).w %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x2f200020) {
				// 00101111001tttttPPuvvvvv001wwwww | vscatter(Rt,Mu,Vv.h).h = Vw
				hi->instruction = HEX_INS_V6_VSCATTERMH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s vscatter(%s,%s,%s.h).h = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x2f2000a0) {
				// 00101111001tttttPPuvvvvv101wwwww | vscatter(Rt,Mu,Vv.h).h += Vw
				hi->instruction = HEX_INS_V6_VSCATTERMH_ADD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s vscatter(%s,%s,%s.h).h += %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00080) == 0x2f800080) {
				// 00101111100tttttPPuvvvvv1sswwwww | if (Qs) vscatter(Rt,Mu,Vv.h).h = Vw
				hi->instruction = HEX_INS_V6_VSCATTERMHQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Qs4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Vv32
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s if (%s) vscatter(%s,%s,%s.h).h = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hex_get_hvx_vr(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x2f200040) {
				// 00101111001tttttPPuvvvvv010wwwww | vscatter(Rt,Mu,Vvv.w).h = Vw
				hi->instruction = HEX_INS_V6_VSCATTERMHW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vvv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s vscatter(%s,%s,%s.w).h = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x2f2000c0) {
				// 00101111001tttttPPuvvvvv110wwwww | vscatter(Rt,Mu,Vvv.w).h += Vw
				hi->instruction = HEX_INS_V6_VSCATTERMHW_ADD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vvv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s vscatter(%s,%s,%s.w).h += %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_wr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00080) == 0x2fa00000) {
				// 00101111101tttttPPuvvvvv0sswwwww | if (Qs) vscatter(Rt,Mu,Vvv.w).h = Vw
				hi->instruction = HEX_INS_V6_VSCATTERMHWQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Qs4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Vvv32
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s if (%s) vscatter(%s,%s,%s.w).h = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_wr(hi->ops[3].op.reg), hex_get_hvx_vr(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x2f200000) {
				// 00101111001tttttPPuvvvvv000wwwww | vscatter(Rt,Mu,Vv.w).w = Vw
				hi->instruction = HEX_INS_V6_VSCATTERMW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s vscatter(%s,%s,%s.w).w = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x2f200080) {
				// 00101111001tttttPPuvvvvv100wwwww | vscatter(Rt,Mu,Vv.w).w += Vw
				hi->instruction = HEX_INS_V6_VSCATTERMW_ADD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Vv32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s vscatter(%s,%s,%s.w).w += %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_hvx_vr(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00080) == 0x2f800000) {
				// 00101111100tttttPPuvvvvv0sswwwww | if (Qs) vscatter(Rt,Mu,Vv.w).w = Vw
				hi->instruction = HEX_INS_V6_VSCATTERMWQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Qs4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Vv32
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Vw32
				sprintf(hi->mnem, "%s if (%s) vscatter(%s,%s,%s.w).w = %s %s", hi->pkt_info.syntax_prefix, hex_get_hvx_qr(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hex_get_hvx_vr(hi->ops[3].op.reg), hex_get_hvx_vr(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0x2c000000) {
				// 00101100000tttttPPi00iii00000000 | z = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_ZLD_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				sprintf(hi->mnem, "%s z = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038ff) == 0x2d000000) {
				// 00101101000xxxxxPP000iii00000000 | z = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_ZLD_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[1].op.imm & (1 << 2)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				sprintf(hi->mnem, "%s z = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fff) == 0x2d000001) {
				// 00101101000xxxxxPPu0000000000001 | z = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_ZLD_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s z = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0x2c800000) {
				// 00101100100tttttPPivviii00000000 | if (Pv) z = vmem(Rt+#Ii)
				hi->instruction = HEX_INS_V6_ZLD_PRED_AI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 10) | (((hi_u32)&0x700) >> 8)); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) z = vmem(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020ff) == 0x2d800000) {
				// 00101101100xxxxxPP0vviii00000000 | if (Pv) z = vmem(Rx++#Ii)
				hi->instruction = HEX_INS_V6_ZLD_PRED_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x700) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 2)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 2);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) z = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe007ff) == 0x2d800001) {
				// 00101101100xxxxxPPuvv00000000001 | if (Pv) z = vmem(Rx++Mu)
				hi->instruction = HEX_INS_V6_ZLD_PRED_PPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s if (%s) z = vmem(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x3:
			if ((hi_u32 & 0xffe02060) == 0x3e000000) {
				// 00111110000sssssPP0iiiiii00ttttt | memb(Rs+#Ii) += Rt
				hi->instruction = HEX_INS_L4_ADD_MEMOPB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memb(%s+##0x%x) += %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e200000) {
				// 00111110001sssssPP0iiiiii00ttttt | memh(Rs+#Ii) += Rt
				hi->instruction = HEX_INS_L4_ADD_MEMOPH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memh(%s+##0x%x) += %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e400000) {
				// 00111110010sssssPP0iiiiii00ttttt | memw(Rs+#Ii) += Rt
				hi->instruction = HEX_INS_L4_ADD_MEMOPW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memw(%s+##0x%x) += %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e000040) {
				// 00111110000sssssPP0iiiiii10ttttt | memb(Rs+#Ii) &= Rt
				hi->instruction = HEX_INS_L4_AND_MEMOPB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memb(%s+##0x%x) &= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e200040) {
				// 00111110001sssssPP0iiiiii10ttttt | memh(Rs+#Ii) &= Rt
				hi->instruction = HEX_INS_L4_AND_MEMOPH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memh(%s+##0x%x) &= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e400040) {
				// 00111110010sssssPP0iiiiii10ttttt | memw(Rs+#Ii) &= Rt
				hi->instruction = HEX_INS_L4_AND_MEMOPW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memw(%s+##0x%x) &= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f000000) {
				// 00111111000sssssPP0iiiiii00IIIII | memb(Rs+#Ii) += #II
				hi->instruction = HEX_INS_L4_IADD_MEMOPB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memb(%s+##0x%x) += #0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f200000) {
				// 00111111001sssssPP0iiiiii00IIIII | memh(Rs+#Ii) += #II
				hi->instruction = HEX_INS_L4_IADD_MEMOPH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memh(%s+##0x%x) += #0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f400000) {
				// 00111111010sssssPP0iiiiii00IIIII | memw(Rs+#Ii) += #II
				hi->instruction = HEX_INS_L4_IADD_MEMOPW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memw(%s+##0x%x) += #0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f000040) {
				// 00111111000sssssPP0iiiiii10IIIII | memb(Rs+#Ii) = clrbit(#II)
				hi->instruction = HEX_INS_L4_IAND_MEMOPB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memb(%s+##0x%x) = clrbit(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f200040) {
				// 00111111001sssssPP0iiiiii10IIIII | memh(Rs+#Ii) = clrbit(#II)
				hi->instruction = HEX_INS_L4_IAND_MEMOPH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memh(%s+##0x%x) = clrbit(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f400040) {
				// 00111111010sssssPP0iiiiii10IIIII | memw(Rs+#Ii) = clrbit(#II)
				hi->instruction = HEX_INS_L4_IAND_MEMOPW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memw(%s+##0x%x) = clrbit(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f000060) {
				// 00111111000sssssPP0iiiiii11IIIII | memb(Rs+#Ii) = setbit(#II)
				hi->instruction = HEX_INS_L4_IOR_MEMOPB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memb(%s+##0x%x) = setbit(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f200060) {
				// 00111111001sssssPP0iiiiii11IIIII | memh(Rs+#Ii) = setbit(#II)
				hi->instruction = HEX_INS_L4_IOR_MEMOPH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memh(%s+##0x%x) = setbit(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f400060) {
				// 00111111010sssssPP0iiiiii11IIIII | memw(Rs+#Ii) = setbit(#II)
				hi->instruction = HEX_INS_L4_IOR_MEMOPW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memw(%s+##0x%x) = setbit(#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f000020) {
				// 00111111000sssssPP0iiiiii01IIIII | memb(Rs+#Ii) -= #II
				hi->instruction = HEX_INS_L4_ISUB_MEMOPB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memb(%s+##0x%x) -= #0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f200020) {
				// 00111111001sssssPP0iiiiii01IIIII | memh(Rs+#Ii) -= #II
				hi->instruction = HEX_INS_L4_ISUB_MEMOPH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memh(%s+##0x%x) -= #0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3f400020) {
				// 00111111010sssssPP0iiiiii01IIIII | memw(Rs+#Ii) -= #II
				hi->instruction = HEX_INS_L4_ISUB_MEMOPW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f) >> 0); // II
				sprintf(hi->mnem, "%s memw(%s+##0x%x) -= #0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3a000000) {
				// 00111010000sssssPPittttti00ddddd | Rd = memb(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_LOADRB_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s %s = memb(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3ac00000) {
				// 00111010110sssssPPittttti00ddddd | Rdd = memd(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_LOADRD_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s %s = memd(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3a400000) {
				// 00111010010sssssPPittttti00ddddd | Rd = memh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_LOADRH_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s %s = memh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3a800000) {
				// 00111010100sssssPPittttti00ddddd | Rd = memw(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_LOADRI_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s %s = memw(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3a200000) {
				// 00111010001sssssPPittttti00ddddd | Rd = memub(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_LOADRUB_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s %s = memub(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3a600000) {
				// 00111010011sssssPPittttti00ddddd | Rd = memuh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_LOADRUH_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s %s = memuh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e000060) {
				// 00111110000sssssPP0iiiiii11ttttt | memb(Rs+#Ii) |= Rt
				hi->instruction = HEX_INS_L4_OR_MEMOPB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memb(%s+##0x%x) |= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e200060) {
				// 00111110001sssssPP0iiiiii11ttttt | memh(Rs+#Ii) |= Rt
				hi->instruction = HEX_INS_L4_OR_MEMOPH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memh(%s+##0x%x) |= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e400060) {
				// 00111110010sssssPP0iiiiii11ttttt | memw(Rs+#Ii) |= Rt
				hi->instruction = HEX_INS_L4_OR_MEMOPW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memw(%s+##0x%x) |= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x31000000) {
				// 00110001000sssssPPitttttivvddddd | if (!Pv) Rd = memb(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRBF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s) %s = memb(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x33000000) {
				// 00110011000sssssPPitttttivvddddd | if (!Pv.new) Rd = memb(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRBFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s.new) %s = memb(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x30000000) {
				// 00110000000sssssPPitttttivvddddd | if (Pv) Rd = memb(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRBT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s) %s = memb(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x32000000) {
				// 00110010000sssssPPitttttivvddddd | if (Pv.new) Rd = memb(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRBTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s.new) %s = memb(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x31c00000) {
				// 00110001110sssssPPitttttivvddddd | if (!Pv) Rdd = memd(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRDF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s) %s = memd(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x33c00000) {
				// 00110011110sssssPPitttttivvddddd | if (!Pv.new) Rdd = memd(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRDFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s.new) %s = memd(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x30c00000) {
				// 00110000110sssssPPitttttivvddddd | if (Pv) Rdd = memd(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRDT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s) %s = memd(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x32c00000) {
				// 00110010110sssssPPitttttivvddddd | if (Pv.new) Rdd = memd(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRDTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s.new) %s = memd(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x31400000) {
				// 00110001010sssssPPitttttivvddddd | if (!Pv) Rd = memh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRHF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s) %s = memh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x33400000) {
				// 00110011010sssssPPitttttivvddddd | if (!Pv.new) Rd = memh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRHFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s.new) %s = memh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x30400000) {
				// 00110000010sssssPPitttttivvddddd | if (Pv) Rd = memh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRHT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s) %s = memh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x32400000) {
				// 00110010010sssssPPitttttivvddddd | if (Pv.new) Rd = memh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRHTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s.new) %s = memh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x31800000) {
				// 00110001100sssssPPitttttivvddddd | if (!Pv) Rd = memw(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRIF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s) %s = memw(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x33800000) {
				// 00110011100sssssPPitttttivvddddd | if (!Pv.new) Rd = memw(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRIFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s.new) %s = memw(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x30800000) {
				// 00110000100sssssPPitttttivvddddd | if (Pv) Rd = memw(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRIT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s) %s = memw(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x32800000) {
				// 00110010100sssssPPitttttivvddddd | if (Pv.new) Rd = memw(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRITNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s.new) %s = memw(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x31200000) {
				// 00110001001sssssPPitttttivvddddd | if (!Pv) Rd = memub(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUBF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s) %s = memub(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x33200000) {
				// 00110011001sssssPPitttttivvddddd | if (!Pv.new) Rd = memub(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUBFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s.new) %s = memub(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x30200000) {
				// 00110000001sssssPPitttttivvddddd | if (Pv) Rd = memub(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUBT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s) %s = memub(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x32200000) {
				// 00110010001sssssPPitttttivvddddd | if (Pv.new) Rd = memub(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUBTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s.new) %s = memub(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x31600000) {
				// 00110001011sssssPPitttttivvddddd | if (!Pv) Rd = memuh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUHF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s) %s = memuh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x33600000) {
				// 00110011011sssssPPitttttivvddddd | if (!Pv.new) Rd = memuh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUHFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (!%s.new) %s = memuh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x30600000) {
				// 00110000011sssssPPitttttivvddddd | if (Pv) Rd = memuh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUHT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s) %s = memuh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x32600000) {
				// 00110010011sssssPPitttttivvddddd | if (Pv.new) Rd = memuh(Rs+Rt<<#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUHTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[4].type = HEX_OP_TYPE_IMM;
				hi->ops[4].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				sprintf(hi->mnem, "%s if (%s.new) %s = memuh(%s+%s<<#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->ops[4].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e000020) {
				// 00111110000sssssPP0iiiiii01ttttt | memb(Rs+#Ii) -= Rt
				hi->instruction = HEX_INS_L4_SUB_MEMOPB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memb(%s+##0x%x) -= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e200020) {
				// 00111110001sssssPP0iiiiii01ttttt | memh(Rs+#Ii) -= Rt
				hi->instruction = HEX_INS_L4_SUB_MEMOPH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memh(%s+##0x%x) -= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02060) == 0x3e400020) {
				// 00111110010sssssPP0iiiiii01ttttt | memw(Rs+#Ii) -= Rt
				hi->instruction = HEX_INS_L4_SUB_MEMOPW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memw(%s+##0x%x) -= %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x35000000) {
				// 00110101000sssssPPiuuuuuivvttttt | if (!Pv) memb(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memb(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x37000000) {
				// 00110111000sssssPPiuuuuuivvttttt | if (!Pv.new) memb(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memb(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x35a00000) {
				// 00110101101sssssPPiuuuuuivv00ttt | if (!Pv) memb(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memb(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x37a00000) {
				// 00110111101sssssPPiuuuuuivv00ttt | if (!Pv.new) memb(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memb(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x34a00000) {
				// 00110100101sssssPPiuuuuuivv00ttt | if (Pv) memb(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (%s) memb(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x36a00000) {
				// 00110110101sssssPPiuuuuuivv00ttt | if (Pv.new) memb(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memb(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x34000000) {
				// 00110100000sssssPPiuuuuuivvttttt | if (Pv) memb(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (%s) memb(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x36000000) {
				// 00110110000sssssPPiuuuuuivvttttt | if (Pv.new) memb(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memb(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x35c00000) {
				// 00110101110sssssPPiuuuuuivvttttt | if (!Pv) memd(Rs+Ru<<#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rtt32
				sprintf(hi->mnem, "%s if (!%s) memd(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_double_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x37c00000) {
				// 00110111110sssssPPiuuuuuivvttttt | if (!Pv.new) memd(Rs+Ru<<#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rtt32
				sprintf(hi->mnem, "%s if (!%s.new) memd(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_double_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x34c00000) {
				// 00110100110sssssPPiuuuuuivvttttt | if (Pv) memd(Rs+Ru<<#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rtt32
				sprintf(hi->mnem, "%s if (%s) memd(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_double_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x36c00000) {
				// 00110110110sssssPPiuuuuuivvttttt | if (Pv.new) memd(Rs+Ru<<#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rtt32
				sprintf(hi->mnem, "%s if (%s.new) memd(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_double_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x35600000) {
				// 00110101011sssssPPiuuuuuivvttttt | if (!Pv) memh(Rs+Ru<<#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memh(%s+%s<<#0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x37600000) {
				// 00110111011sssssPPiuuuuuivvttttt | if (!Pv.new) memh(Rs+Ru<<#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s+%s<<#0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x34600000) {
				// 00110100011sssssPPiuuuuuivvttttt | if (Pv) memh(Rs+Ru<<#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (%s) memh(%s+%s<<#0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x36600000) {
				// 00110110011sssssPPiuuuuuivvttttt | if (Pv.new) memh(Rs+Ru<<#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memh(%s+%s<<#0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x35400000) {
				// 00110101010sssssPPiuuuuuivvttttt | if (!Pv) memh(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memh(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x37400000) {
				// 00110111010sssssPPiuuuuuivvttttt | if (!Pv.new) memh(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x35a00008) {
				// 00110101101sssssPPiuuuuuivv01ttt | if (!Pv) memh(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memh(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x37a00008) {
				// 00110111101sssssPPiuuuuuivv01ttt | if (!Pv.new) memh(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x34a00008) {
				// 00110100101sssssPPiuuuuuivv01ttt | if (Pv) memh(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (%s) memh(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x36a00008) {
				// 00110110101sssssPPiuuuuuivv01ttt | if (Pv.new) memh(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memh(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x34400000) {
				// 00110100010sssssPPiuuuuuivvttttt | if (Pv) memh(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (%s) memh(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x36400000) {
				// 00110110010sssssPPiuuuuuivvttttt | if (Pv.new) memh(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memh(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x35800000) {
				// 00110101100sssssPPiuuuuuivvttttt | if (!Pv) memw(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERIF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memw(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x37800000) {
				// 00110111100sssssPPiuuuuuivvttttt | if (!Pv.new) memw(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERIFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memw(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x35a00010) {
				// 00110101101sssssPPiuuuuuivv10ttt | if (!Pv) memw(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memw(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x37a00010) {
				// 00110111101sssssPPiuuuuuivv10ttt | if (!Pv.new) memw(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWFNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memw(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x34a00010) {
				// 00110100101sssssPPiuuuuuivv10ttt | if (Pv) memw(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (%s) memw(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00018) == 0x36a00010) {
				// 00110110101sssssPPiuuuuuivv10ttt | if (Pv.new) memw(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWTNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memw(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x34800000) {
				// 00110100100sssssPPiuuuuuivvttttt | if (Pv) memw(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERIT_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (%s) memw(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x36800000) {
				// 00110110100sssssPPiuuuuuivvttttt | if (Pv.new) memw(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERITNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 5;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[4].type = HEX_OP_TYPE_REG;
				hi->ops[4].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memw(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_int_regs(hi->ops[4].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x3c000000) {
				// 00111100000sssssPPIiiiiiiIIIIIII | memb(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 6) | (((hi_u32)&0x7f) >> 0)); // II
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x38800000) {
				// 00111000100sssssPPIiiiiiivvIIIII | if (!Pv) memb(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRBF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x39800000) {
				// 00111001100sssssPPIiiiiiivvIIIII | if (!Pv.new) memb(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRBFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x38000000) {
				// 00111000000sssssPPIiiiiiivvIIIII | if (Pv) memb(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRBT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x39000000) {
				// 00111001000sssssPPIiiiiiivvIIIII | if (Pv.new) memb(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRBTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) memb(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x3c200000) {
				// 00111100001sssssPPIiiiiiiIIIIIII | memh(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 6) | (((hi_u32)&0x7f) >> 0)); // II
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x38a00000) {
				// 00111000101sssssPPIiiiiiivvIIIII | if (!Pv) memh(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRHF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x39a00000) {
				// 00111001101sssssPPIiiiiiivvIIIII | if (!Pv.new) memh(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRHFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x38200000) {
				// 00111000001sssssPPIiiiiiivvIIIII | if (Pv) memh(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRHT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x39200000) {
				// 00111001001sssssPPIiiiiiivvIIIII | if (Pv.new) memh(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRHTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) memh(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x3c400000) {
				// 00111100010sssssPPIiiiiiiIIIIIII | memw(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 6) | (((hi_u32)&0x7f) >> 0)); // II
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x38c00000) {
				// 00111000110sssssPPIiiiiiivvIIIII | if (!Pv) memw(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRIF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x39c00000) {
				// 00111001110sssssPPIiiiiiivvIIIII | if (!Pv.new) memw(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRIFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x38400000) {
				// 00111000010sssssPPIiiiiiivvIIIII | if (Pv) memw(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRIT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x39400000) {
				// 00111001010sssssPPIiiiiiivvIIIII | if (Pv.new) memw(Rs+#Ii) = #II
				hi->instruction = HEX_INS_S4_STOREIRITNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f80) >> 7) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0x1f) >> 0)); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) memw(%s+#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3b000000) {
				// 00111011000sssssPPiuuuuui00ttttt | memb(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_STORERB_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memb(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00078) == 0x3ba00000) {
				// 00111011101sssssPPiuuuuui0000ttt | memb(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_STORERBNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s memb(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3bc00000) {
				// 00111011110sssssPPiuuuuui00ttttt | memd(Rs+Ru<<#Ii) = Rtt
				hi->instruction = HEX_INS_S4_STORERD_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Rtt32
				sprintf(hi->mnem, "%s memd(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3b600000) {
				// 00111011011sssssPPiuuuuui00ttttt | memh(Rs+Ru<<#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_STORERF_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memh(%s+%s<<#0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3b400000) {
				// 00111011010sssssPPiuuuuui00ttttt | memh(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_STORERH_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memh(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00078) == 0x3ba00008) {
				// 00111011101sssssPPiuuuuui0001ttt | memh(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_STORERHNEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s memh(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00060) == 0x3b800000) {
				// 00111011100sssssPPiuuuuui00ttttt | memw(Rs+Ru<<#Ii) = Rt
				hi->instruction = HEX_INS_S4_STORERI_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Rt32
				sprintf(hi->mnem, "%s memw(%s+%s<<#0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00078) == 0x3ba00010) {
				// 00111011101sssssPPiuuuuui0010ttt | memw(Rs+Ru<<#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_STORERINEW_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x7) >> 0); // Nt8
				sprintf(hi->mnem, "%s memw(%s+%s<<#0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x4:
			if ((hi_u32 & 0xf9e00000) == 0x49000000) {
				// 01001ii1000iiiiiPPiiiiiiiiiddddd | Rd = memb(gp+#Ii)
				hi->instruction = HEX_INS_L2_LOADRBGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = memb(GP+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49c00000) {
				// 01001ii1110iiiiiPPiiiiiiiiiddddd | Rdd = memd(gp+#Ii)
				hi->instruction = HEX_INS_L2_LOADRDGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(GP+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49400000) {
				// 01001ii1010iiiiiPPiiiiiiiiiddddd | Rd = memh(gp+#Ii)
				hi->instruction = HEX_INS_L2_LOADRHGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(GP+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49800000) {
				// 01001ii1100iiiiiPPiiiiiiiiiddddd | Rd = memw(gp+#Ii)
				hi->instruction = HEX_INS_L2_LOADRIGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(GP+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49200000) {
				// 01001ii1001iiiiiPPiiiiiiiiiddddd | Rd = memub(gp+#Ii)
				hi->instruction = HEX_INS_L2_LOADRUBGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = memub(GP+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49600000) {
				// 01001ii1011iiiiiPPiiiiiiiiiddddd | Rd = memuh(gp+#Ii)
				hi->instruction = HEX_INS_L2_LOADRUHGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(GP+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x45000000) {
				// 01000101000sssssPP0ttiiiiiiddddd | if (!Pt) Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRBF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memb(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x47000000) {
				// 01000111000sssssPP0ttiiiiiiddddd | if (!Pt.new) Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRBFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memb(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x41000000) {
				// 01000001000sssssPP0ttiiiiiiddddd | if (Pt) Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRBT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memb(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x43000000) {
				// 01000011000sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRBTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memb(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x45c00000) {
				// 01000101110sssssPP0ttiiiiiiddddd | if (!Pt) Rdd = memd(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRDF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memd(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x47c00000) {
				// 01000111110sssssPP0ttiiiiiiddddd | if (!Pt.new) Rdd = memd(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRDFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memd(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x41c00000) {
				// 01000001110sssssPP0ttiiiiiiddddd | if (Pt) Rdd = memd(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRDT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memd(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x43c00000) {
				// 01000011110sssssPP0ttiiiiiiddddd | if (Pt.new) Rdd = memd(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRDTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memd(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x45400000) {
				// 01000101010sssssPP0ttiiiiiiddddd | if (!Pt) Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRHF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memh(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x47400000) {
				// 01000111010sssssPP0ttiiiiiiddddd | if (!Pt.new) Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRHFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memh(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x41400000) {
				// 01000001010sssssPP0ttiiiiiiddddd | if (Pt) Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRHT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memh(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x43400000) {
				// 01000011010sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRHTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memh(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x45800000) {
				// 01000101100sssssPP0ttiiiiiiddddd | if (!Pt) Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRIF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memw(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x47800000) {
				// 01000111100sssssPP0ttiiiiiiddddd | if (!Pt.new) Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRIFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memw(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x41800000) {
				// 01000001100sssssPP0ttiiiiiiddddd | if (Pt) Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRIT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memw(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x43800000) {
				// 01000011100sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRITNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memw(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x45200000) {
				// 01000101001sssssPP0ttiiiiiiddddd | if (!Pt) Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUBF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memub(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x47200000) {
				// 01000111001sssssPP0ttiiiiiiddddd | if (!Pt.new) Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUBFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memub(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x41200000) {
				// 01000001001sssssPP0ttiiiiiiddddd | if (Pt) Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUBT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memub(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x43200000) {
				// 01000011001sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUBTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memub(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x45600000) {
				// 01000101011sssssPP0ttiiiiiiddddd | if (!Pt) Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUHF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memuh(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x47600000) {
				// 01000111011sssssPP0ttiiiiiiddddd | if (!Pt.new) Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUHFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memuh(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x41600000) {
				// 01000001011sssssPP0ttiiiiiiddddd | if (Pt) Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUHT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memuh(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x43600000) {
				// 01000011011sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUHTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1800) >> 11); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x7e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memuh(%s+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49000000) {
				// 01001ii1000iiiiiPPiiiiiiiiiddddd | Rd = memb(#Ii)
				hi->instruction = HEX_INS_PS_LOADRBABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = memb(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49c00000) {
				// 01001ii1110iiiiiPPiiiiiiiiiddddd | Rdd = memd(#Ii)
				hi->instruction = HEX_INS_PS_LOADRDABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s %s = memd(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49400000) {
				// 01001ii1010iiiiiPPiiiiiiiiiddddd | Rd = memh(#Ii)
				hi->instruction = HEX_INS_PS_LOADRHABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				sprintf(hi->mnem, "%s %s = memh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49800000) {
				// 01001ii1100iiiiiPPiiiiiiiiiddddd | Rd = memw(#Ii)
				hi->instruction = HEX_INS_PS_LOADRIABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				sprintf(hi->mnem, "%s %s = memw(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49200000) {
				// 01001ii1001iiiiiPPiiiiiiiiiddddd | Rd = memub(#Ii)
				hi->instruction = HEX_INS_PS_LOADRUBABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = memub(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x49600000) {
				// 01001ii1011iiiiiPPiiiiiiiiiddddd | Rd = memuh(#Ii)
				hi->instruction = HEX_INS_PS_LOADRUHABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				sprintf(hi->mnem, "%s %s = memuh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48000000) {
				// 01001ii0000iiiiiPPitttttiiiiiiii | memb(#Ii) = Rt
				hi->instruction = HEX_INS_PS_STORERBABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)); // Ii
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0x48a00000) {
				// 01001ii0101iiiiiPPi00tttiiiiiiii | memb(#Ii) = Nt.new
				hi->instruction = HEX_INS_PS_STORERBNEWABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)); // Ii
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48c00000) {
				// 01001ii0110iiiiiPPitttttiiiiiiii | memd(#Ii) = Rtt
				hi->instruction = HEX_INS_PS_STORERDABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48600000) {
				// 01001ii0011iiiiiPPitttttiiiiiiii | memh(#Ii) = Rt.h
				hi->instruction = HEX_INS_PS_STORERFABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 1;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48400000) {
				// 01001ii0010iiiiiPPitttttiiiiiiii | memh(#Ii) = Rt
				hi->instruction = HEX_INS_PS_STORERHABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 1;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0x48a00800) {
				// 01001ii0101iiiiiPPi01tttiiiiiiii | memh(#Ii) = Nt.new
				hi->instruction = HEX_INS_PS_STORERHNEWABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 1;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48800000) {
				// 01001ii0100iiiiiPPitttttiiiiiiii | memw(#Ii) = Rt
				hi->instruction = HEX_INS_PS_STORERIABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0x48a01000) {
				// 01001ii0101iiiiiPPi10tttiiiiiiii | memw(#Ii) = Nt.new
				hi->instruction = HEX_INS_PS_STORERINEWABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x44000000) {
				// 01000100000sssssPPitttttiiiii0vv | if (!Pv) memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERBF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memb(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x44a00000) {
				// 01000100101sssssPPi00tttiiiii0vv | if (!Pv) memb(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERBNEWF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memb(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x40a00000) {
				// 01000000101sssssPPi00tttiiiii0vv | if (Pv) memb(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERBNEWT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memb(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x40000000) {
				// 01000000000sssssPPitttttiiiii0vv | if (Pv) memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERBT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memb(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x44c00000) {
				// 01000100110sssssPPitttttiiiii0vv | if (!Pv) memd(Rs+#Ii) = Rtt
				hi->instruction = HEX_INS_S2_PSTORERDF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (!%s) memd(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x40c00000) {
				// 01000000110sssssPPitttttiiiii0vv | if (Pv) memd(Rs+#Ii) = Rtt
				hi->instruction = HEX_INS_S2_PSTORERDT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (%s) memd(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x44600000) {
				// 01000100011sssssPPitttttiiiii0vv | if (!Pv) memh(Rs+#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_PSTORERFF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memh(%s+##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x40600000) {
				// 01000000011sssssPPitttttiiiii0vv | if (Pv) memh(Rs+#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_PSTORERFT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memh(%s+##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x44400000) {
				// 01000100010sssssPPitttttiiiii0vv | if (!Pv) memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERHF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memh(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x44a00800) {
				// 01000100101sssssPPi01tttiiiii0vv | if (!Pv) memh(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERHNEWF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memh(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x40a00800) {
				// 01000000101sssssPPi01tttiiiii0vv | if (Pv) memh(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERHNEWT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memh(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x40400000) {
				// 01000000010sssssPPitttttiiiii0vv | if (Pv) memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERHT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memh(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x44800000) {
				// 01000100100sssssPPitttttiiiii0vv | if (!Pv) memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERIF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memw(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x44a01000) {
				// 01000100101sssssPPi10tttiiiii0vv | if (!Pv) memw(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERINEWF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memw(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x40a01000) {
				// 01000000101sssssPPi10tttiiiii0vv | if (Pv) memw(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERINEWT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memw(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x40800000) {
				// 01000000100sssssPPitttttiiiii0vv | if (Pv) memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERIT_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memw(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48000000) {
				// 01001ii0000iiiiiPPitttttiiiiiiii | memb(gp+#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERBGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)); // Ii
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(GP+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0x48a00000) {
				// 01001ii0101iiiiiPPi00tttiiiiiiii | memb(gp+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERBNEWGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)); // Ii
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(GP+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48c00000) {
				// 01001ii0110iiiiiPPitttttiiiiiiii | memd(gp+#Ii) = Rtt
				hi->instruction = HEX_INS_S2_STORERDGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 3; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(GP+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48600000) {
				// 01001ii0011iiiiiPPitttttiiiiiiii | memh(gp+#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_STORERFGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 1;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(GP+##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48400000) {
				// 01001ii0010iiiiiPPitttttiiiiiiii | memh(gp+#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERHGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 1;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(GP+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0x48a00800) {
				// 01001ii0101iiiiiPPi01tttiiiiiiii | memh(gp+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERHNEWGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 1;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(GP+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x48800000) {
				// 01001ii0100iiiiiPPitttttiiiiiiii | memw(gp+#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERIGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(GP+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0x48a01000) {
				// 01001ii0101iiiiiPPi10tttiiiiiiii | memw(gp+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERINEWGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x6000000) >> 11) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(GP+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x46000000) {
				// 01000110000sssssPPitttttiiiii0vv | if (!Pv.new) memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memb(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x46a00000) {
				// 01000110101sssssPPi00tttiiiii0vv | if (!Pv.new) memb(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memb(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x42a00000) {
				// 01000010101sssssPPi00tttiiiii0vv | if (Pv.new) memb(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memb(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x42000000) {
				// 01000010000sssssPPitttttiiiii0vv | if (Pv.new) memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memb(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x46c00000) {
				// 01000110110sssssPPitttttiiiii0vv | if (!Pv.new) memd(Rs+#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (!%s.new) memd(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x42c00000) {
				// 01000010110sssssPPitttttiiiii0vv | if (Pv.new) memd(Rs+#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (%s.new) memd(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x46600000) {
				// 01000110011sssssPPitttttiiiii0vv | if (!Pv.new) memh(Rs+#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s+##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x42600000) {
				// 01000010011sssssPPitttttiiiii0vv | if (Pv.new) memh(Rs+#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memh(%s+##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x46400000) {
				// 01000110010sssssPPitttttiiiii0vv | if (!Pv.new) memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x46a00800) {
				// 01000110101sssssPPi01tttiiiii0vv | if (!Pv.new) memh(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x42a00800) {
				// 01000010101sssssPPi01tttiiiii0vv | if (Pv.new) memh(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memh(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x42400000) {
				// 01000010010sssssPPitttttiiiii0vv | if (Pv.new) memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memh(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x46800000) {
				// 01000110100sssssPPitttttiiiii0vv | if (!Pv.new) memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERIFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memw(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x46a01000) {
				// 01000110101sssssPPi10tttiiiii0vv | if (!Pv.new) memw(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWFNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memw(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01804) == 0x42a01000) {
				// 01000010101sssssPPi10tttiiiii0vv | if (Pv.new) memw(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWTNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memw(%s+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00004) == 0x42800000) {
				// 01000010100sssssPPitttttiiiii0vv | if (Pv.new) memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERITNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 8) | (((hi_u32)&0xf8) >> 3)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memw(%s+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x5:
			if ((hi_u32 & 0xfe000001) == 0x5a000000) {
				// 0101101iiiiiiiiiPPiiiiiiiiiiiii0 | call Ii
				hi->instruction = HEX_INS_J2_CALL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1ff0000) >> 3) | (((hi_u32)&0x3ffe) >> 1)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 23)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 23);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				sprintf(hi->mnem, "%s call 0x%x %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5d200000) {
				// 01011101ii1iiiiiPPi000uuiiiiiii0 | if (!Pu) call Ii
				hi->instruction = HEX_INS_J2_CALLF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) call 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0x50a00000) {
				// 01010000101sssssPP00000000000000 | callr Rs
				hi->instruction = HEX_INS_J2_CALLR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s callr %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x51200000) {
				// 01010001001sssssPP0000uu00000000 | if (!Pu) callr Rs
				hi->instruction = HEX_INS_J2_CALLRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) callr %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x51000000) {
				// 01010001000sssssPP0000uu00000000 | if (Pu) callr Rs
				hi->instruction = HEX_INS_J2_CALLRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) callr %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5d000000) {
				// 01011101ii0iiiiiPPi000uuiiiiiii0 | if (Pu) call Ii
				hi->instruction = HEX_INS_J2_CALLT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) call 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe000001) == 0x58000000) {
				// 0101100iiiiiiiiiPPiiiiiiiiiiiii0 | jump Ii
				hi->instruction = HEX_INS_J2_JUMP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1ff0000) >> 3) | (((hi_u32)&0x3ffe) >> 1)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 23)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 23);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				sprintf(hi->mnem, "%s jump 0x%x %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5c200000) {
				// 01011100ii1iiiiiPPi000uuiiiiiii0 | if (!Pu) jump:nt Ii
				hi->instruction = HEX_INS_J2_JUMPF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5c200800) {
				// 01011100ii1iiiiiPPi010uuiiiiiii0 | if (!Pu.new) jump:nt Ii
				hi->instruction = HEX_INS_J2_JUMPFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5c201800) {
				// 01011100ii1iiiiiPPi110uuiiiiiii0 | if (!Pu.new) jump:t Ii
				hi->instruction = HEX_INS_J2_JUMPFNEWPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5c201000) {
				// 01011100ii1iiiiiPPi100uuiiiiiii0 | if (!Pu) jump:t Ii
				hi->instruction = HEX_INS_J2_JUMPFPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0x52800000) {
				// 01010010100sssssPP00000000000000 | jumpr Rs
				hi->instruction = HEX_INS_J2_JUMPR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s jumpr %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x53600000) {
				// 01010011011sssssPP0000uu00000000 | if (!Pu) jumpr:nt Rs
				hi->instruction = HEX_INS_J2_JUMPRF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) jumpr:nt %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x53600800) {
				// 01010011011sssssPP0010uu00000000 | if (!Pu.new) jumpr:nt Rs
				hi->instruction = HEX_INS_J2_JUMPRFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) jumpr:nt %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x53601800) {
				// 01010011011sssssPP0110uu00000000 | if (!Pu.new) jumpr:t Rs
				hi->instruction = HEX_INS_J2_JUMPRFNEWPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) jumpr:t %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x53601000) {
				// 01010011011sssssPP0100uu00000000 | if (!Pu) jumpr:t Rs
				hi->instruction = HEX_INS_J2_JUMPRFPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) jumpr:t %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x53400000) {
				// 01010011010sssssPP0000uu00000000 | if (Pu) jumpr:nt Rs
				hi->instruction = HEX_INS_J2_JUMPRT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) jumpr:nt %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x53400800) {
				// 01010011010sssssPP0010uu00000000 | if (Pu.new) jumpr:nt Rs
				hi->instruction = HEX_INS_J2_JUMPRTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) jumpr:nt %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x53401800) {
				// 01010011010sssssPP0110uu00000000 | if (Pu.new) jumpr:t Rs
				hi->instruction = HEX_INS_J2_JUMPRTNEWPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) jumpr:t %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03cff) == 0x53401000) {
				// 01010011010sssssPP0100uu00000000 | if (Pu) jumpr:t Rs
				hi->instruction = HEX_INS_J2_JUMPRTPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) jumpr:t %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5c000000) {
				// 01011100ii0iiiiiPPi000uuiiiiiii0 | if (Pu) jump:nt Ii
				hi->instruction = HEX_INS_J2_JUMPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5c000800) {
				// 01011100ii0iiiiiPPi010uuiiiiiii0 | if (Pu.new) jump:nt Ii
				hi->instruction = HEX_INS_J2_JUMPTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5c001800) {
				// 01011100ii0iiiiiPPi110uuiiiiiii0 | if (Pu.new) jump:t Ii
				hi->instruction = HEX_INS_J2_JUMPTNEWPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff201c01) == 0x5c001000) {
				// 01011100ii0iiiiiPPi100uuiiiiiii0 | if (Pu) jump:t Ii
				hi->instruction = HEX_INS_J2_JUMPTPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 9) | (((hi_u32)&0x1f0000) >> 8) | (((hi_u32)&0x2000) >> 6) | (((hi_u32)&0xfe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 16)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 16);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e3) == 0x54400000) {
				// 0101010001000000PP0iiiii000iii00 | pause(#Ii)
				hi->instruction = HEX_INS_J2_PAUSE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 5) | (((hi_u32)&0x1c) >> 2)); // Ii
				sprintf(hi->mnem, "%s pause(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e3) == 0x54000000) {
				// 0101010000000000PP0iiiii000iii00 | trap0(#Ii)
				hi->instruction = HEX_INS_J2_TRAP0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 5) | (((hi_u32)&0x1c) >> 2)); // Ii
				sprintf(hi->mnem, "%s trap0(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e3) == 0x54800000) {
				// 01010100100xxxxxPP0iiiii000iii00 | trap1(Rx,#Ii)
				hi->instruction = HEX_INS_J2_TRAP1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x1f00) >> 5) | (((hi_u32)&0x1c) >> 2)); // Ii
				sprintf(hi->mnem, "%s trap1(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0x52a00000) {
				// 01010010101sssssPP00000000000000 | hintjr(Rs)
				hi->instruction = HEX_INS_J4_HINTJUMPR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s hintjr(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff20e3) == 0x54800000) {
				// 0101010010000000PP0iiiii000iii00 | trap1(#Ii)
				hi->instruction = HEX_INS_PS_TRAP1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 5) | (((hi_u32)&0x1c) >> 2)); // Ii
				sprintf(hi->mnem, "%s trap1(#0x%x) %s", hi->pkt_info.syntax_prefix, hi->ops[0].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0x56c00000) {
				// 01010110110sssssPP00000000000000 | icinva(Rs)
				hi->instruction = HEX_INS_Y2_ICINVA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s icinva(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0x57c00002) {
				// 0101011111000000PP00000000000010 | isync
				hi->instruction = HEX_INS_Y2_ISYNC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s isync %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x6:
			if ((hi_u32 & 0xffe03fe0) == 0x6a000000) {
				// 01101010000sssssPP000000000ddddd | Rd = Cs
				hi->instruction = HEX_INS_A2_TFRCRR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Cs32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_ctr_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x62200000) {
				// 01100010001sssssPP000000000ddddd | Cd = Rs
				hi->instruction = HEX_INS_A2_TFRRCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Cd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_ctr_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x68000000) {
				// 01101000000sssssPP000000000ddddd | Rdd = Css
				hi->instruction = HEX_INS_A4_TFRCPP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Css32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_ctr_regs64(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x63200000) {
				// 01100011001sssssPP000000000ddddd | Cdd = Rss
				hi->instruction = HEX_INS_A4_TFRPCP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Cdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_ctr_regs64(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3ffc) == 0x6ba00000) {
				// 01101011101000ssPP000000000000dd | Pd = all8(Ps)
				hi->instruction = HEX_INS_C2_ALL8;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				sprintf(hi->mnem, "%s %s = all8(%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3cfc) == 0x6b000000) {
				// 01101011000000ssPP0000tt000000dd | Pd = and(Pt,Ps)
				hi->instruction = HEX_INS_C2_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				sprintf(hi->mnem, "%s %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3cfc) == 0x6b600000) {
				// 01101011011000ssPP0000tt000000dd | Pd = and(Pt,!Ps)
				hi->instruction = HEX_INS_C2_ANDN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				sprintf(hi->mnem, "%s %s = and(%s,!%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3ffc) == 0x6b800000) {
				// 01101011100000ssPP000000000000dd | Pd = any8(Ps)
				hi->instruction = HEX_INS_C2_ANY8;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				sprintf(hi->mnem, "%s %s = any8(%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3ffc) == 0x6bc00000) {
				// 01101011110000ssPP000000000000dd | Pd = not(Ps)
				hi->instruction = HEX_INS_C2_NOT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				sprintf(hi->mnem, "%s %s = not(%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3cfc) == 0x6b200000) {
				// 01101011001000ssPP0000tt000000dd | Pd = or(Pt,Ps)
				hi->instruction = HEX_INS_C2_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				sprintf(hi->mnem, "%s %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3cfc) == 0x6be00000) {
				// 01101011111000ssPP0000tt000000dd | Pd = or(Pt,!Ps)
				hi->instruction = HEX_INS_C2_ORN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				sprintf(hi->mnem, "%s %s = or(%s,!%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3cfc) == 0x6b400000) {
				// 01101011010000ssPP0000tt000000dd | Pd = xor(Ps,Pt)
				hi->instruction = HEX_INS_C2_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				sprintf(hi->mnem, "%s %s = xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff2060) == 0x6a490000) {
				// 0110101001001001PP0iiiiii00ddddd | Rd = add(pc,#Ii)
				hi->instruction = HEX_INS_C4_ADDIPC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f80) >> 7); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = add(PC,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3c3c) == 0x6b100000) {
				// 01101011000100ssPP0000ttuu0000dd | Pd = and(Ps,and(Pt,Pu))
				hi->instruction = HEX_INS_C4_AND_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xc0) >> 6); // Pu4
				sprintf(hi->mnem, "%s %s = and(%s,and(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3c3c) == 0x6b900000) {
				// 01101011100100ssPP0000ttuu0000dd | Pd = and(Ps,and(Pt,!Pu))
				hi->instruction = HEX_INS_C4_AND_ANDN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xc0) >> 6); // Pu4
				sprintf(hi->mnem, "%s %s = and(%s,and(%s,!%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3c3c) == 0x6b300000) {
				// 01101011001100ssPP0000ttuu0000dd | Pd = and(Ps,or(Pt,Pu))
				hi->instruction = HEX_INS_C4_AND_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xc0) >> 6); // Pu4
				sprintf(hi->mnem, "%s %s = and(%s,or(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3c3c) == 0x6bb00000) {
				// 01101011101100ssPP0000ttuu0000dd | Pd = and(Ps,or(Pt,!Pu))
				hi->instruction = HEX_INS_C4_AND_ORN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xc0) >> 6); // Pu4
				sprintf(hi->mnem, "%s %s = and(%s,or(%s,!%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3cfc) == 0x6b002090) {
				// 01101011000000ssPP1000tt100100dd | Pd = fastcorner9(Ps,Pt)
				hi->instruction = HEX_INS_C4_FASTCORNER9;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				sprintf(hi->mnem, "%s %s = fastcorner9(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3cfc) == 0x6b102090) {
				// 01101011000100ssPP1000tt100100dd | Pd = !fastcorner9(Ps,Pt)
				hi->instruction = HEX_INS_C4_FASTCORNER9_NOT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				sprintf(hi->mnem, "%s %s = !fastcorner9(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3c3c) == 0x6b500000) {
				// 01101011010100ssPP0000ttuu0000dd | Pd = or(Ps,and(Pt,Pu))
				hi->instruction = HEX_INS_C4_OR_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xc0) >> 6); // Pu4
				sprintf(hi->mnem, "%s %s = or(%s,and(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3c3c) == 0x6bd00000) {
				// 01101011110100ssPP0000ttuu0000dd | Pd = or(Ps,and(Pt,!Pu))
				hi->instruction = HEX_INS_C4_OR_ANDN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xc0) >> 6); // Pu4
				sprintf(hi->mnem, "%s %s = or(%s,and(%s,!%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3c3c) == 0x6b700000) {
				// 01101011011100ssPP0000ttuu0000dd | Pd = or(Ps,or(Pt,Pu))
				hi->instruction = HEX_INS_C4_OR_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xc0) >> 6); // Pu4
				sprintf(hi->mnem, "%s %s = or(%s,or(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3c3c) == 0x6bf00000) {
				// 01101011111100ssPP0000ttuu0000dd | Pd = or(Ps,or(Pt,!Pu))
				hi->instruction = HEX_INS_C4_OR_ORN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0xc0) >> 6); // Pu4
				sprintf(hi->mnem, "%s %s = or(%s,or(%s,!%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x68200000) {
				// 01101000001sssssPP000000000ddddd | Rdd = Gss
				hi->instruction = HEX_INS_G4_TFRGCPP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Gss32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_guest_regs64(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x6a200000) {
				// 01101010001sssssPP000000000ddddd | Rd = Gs
				hi->instruction = HEX_INS_G4_TFRGCRR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Gs32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_guest_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x63000000) {
				// 01100011000sssssPP000000000ddddd | Gdd = Rss
				hi->instruction = HEX_INS_G4_TFRGPCP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Gdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_guest_regs64(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x62000000) {
				// 01100010000sssssPP000000000ddddd | Gd = Rs
				hi->instruction = HEX_INS_G4_TFRGRCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Gd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_guest_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc01001) == 0x61400000) {
				// 0110000101isssssPPi0iiiiiiiiiii0 | if (Rs>=#0) jump:nt Ii
				hi->instruction = HEX_INS_J2_JUMPRGTEZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 9) | (((hi_u32)&0x2000) >> 2) | (((hi_u32)&0xffe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 14)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 14);
				}
				sprintf(hi->mnem, "%s if (%s>=#0) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc01001) == 0x61401000) {
				// 0110000101isssssPPi1iiiiiiiiiii0 | if (Rs>=#0) jump:t Ii
				hi->instruction = HEX_INS_J2_JUMPRGTEZPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 9) | (((hi_u32)&0x2000) >> 2) | (((hi_u32)&0xffe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 14)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 14);
				}
				sprintf(hi->mnem, "%s if (%s>=#0) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc01001) == 0x61c00000) {
				// 0110000111isssssPPi0iiiiiiiiiii0 | if (Rs<=#0) jump:nt Ii
				hi->instruction = HEX_INS_J2_JUMPRLTEZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 9) | (((hi_u32)&0x2000) >> 2) | (((hi_u32)&0xffe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 14)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 14);
				}
				sprintf(hi->mnem, "%s if (%s<=#0) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc01001) == 0x61c01000) {
				// 0110000111isssssPPi1iiiiiiiiiii0 | if (Rs<=#0) jump:t Ii
				hi->instruction = HEX_INS_J2_JUMPRLTEZPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 9) | (((hi_u32)&0x2000) >> 2) | (((hi_u32)&0xffe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 14)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 14);
				}
				sprintf(hi->mnem, "%s if (%s<=#0) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc01001) == 0x61800000) {
				// 0110000110isssssPPi0iiiiiiiiiii0 | if (Rs==#0) jump:nt Ii
				hi->instruction = HEX_INS_J2_JUMPRNZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 9) | (((hi_u32)&0x2000) >> 2) | (((hi_u32)&0xffe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 14)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 14);
				}
				sprintf(hi->mnem, "%s if (%s==#0) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc01001) == 0x61801000) {
				// 0110000110isssssPPi1iiiiiiiiiii0 | if (Rs==#0) jump:t Ii
				hi->instruction = HEX_INS_J2_JUMPRNZPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 9) | (((hi_u32)&0x2000) >> 2) | (((hi_u32)&0xffe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 14)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 14);
				}
				sprintf(hi->mnem, "%s if (%s==#0) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc01001) == 0x61000000) {
				// 0110000100isssssPPi0iiiiiiiiiii0 | if (Rs!=#0) jump:nt Ii
				hi->instruction = HEX_INS_J2_JUMPRZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 9) | (((hi_u32)&0x2000) >> 2) | (((hi_u32)&0xffe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 14)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 14);
				}
				sprintf(hi->mnem, "%s if (%s!=#0) jump:nt 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc01001) == 0x61001000) {
				// 0110000100isssssPPi1iiiiiiiiiii0 | if (Rs!=#0) jump:t Ii
				hi->instruction = HEX_INS_J2_JUMPRZPT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 9) | (((hi_u32)&0x2000) >> 2) | (((hi_u32)&0xffe) >> 1)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 14)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 14);
				}
				sprintf(hi->mnem, "%s if (%s!=#0) jump:t 0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), addr + (st32)hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02004) == 0x69000000) {
				// 01101001000IIIIIPP0iiiiiIIIii0II | loop0(Ii,#II)
				hi->instruction = HEX_INS_J2_LOOP0I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_0;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x1f0000) >> 11) | (((hi_u32)&0xe0) >> 3) | (((hi_u32)&0x3) >> 0)); // II
				sprintf(hi->mnem, "%s loop0(0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e7) == 0x60000000) {
				// 01100000000sssssPP0iiiii000ii000 | loop0(Ii,Rs)
				hi->instruction = HEX_INS_J2_LOOP0R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_0;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s loop0(0x%x,%s) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02004) == 0x69200000) {
				// 01101001001IIIIIPP0iiiiiIIIii0II | loop1(Ii,#II)
				hi->instruction = HEX_INS_J2_LOOP1I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_1;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x1f0000) >> 11) | (((hi_u32)&0xe0) >> 3) | (((hi_u32)&0x3) >> 0)); // II
				sprintf(hi->mnem, "%s loop1(0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e7) == 0x60200000) {
				// 01100000001sssssPP0iiiii000ii000 | loop1(Ii,Rs)
				hi->instruction = HEX_INS_J2_LOOP1R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_1;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s loop1(0x%x,%s) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02004) == 0x69a00000) {
				// 01101001101IIIIIPP0iiiiiIIIii0II | p3 = sp1loop0(Ii,#II)
				hi->instruction = HEX_INS_J2_PLOOP1SI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_0;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x1f0000) >> 11) | (((hi_u32)&0xe0) >> 3) | (((hi_u32)&0x3) >> 0)); // II
				sprintf(hi->mnem, "%s P3 = sp1loop0(0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e7) == 0x60a00000) {
				// 01100000101sssssPP0iiiii000ii000 | p3 = sp1loop0(Ii,Rs)
				hi->instruction = HEX_INS_J2_PLOOP1SR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_0;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s P3 = sp1loop0(0x%x,%s) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02004) == 0x69c00000) {
				// 01101001110IIIIIPP0iiiiiIIIii0II | p3 = sp2loop0(Ii,#II)
				hi->instruction = HEX_INS_J2_PLOOP2SI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_0;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x1f0000) >> 11) | (((hi_u32)&0xe0) >> 3) | (((hi_u32)&0x3) >> 0)); // II
				sprintf(hi->mnem, "%s P3 = sp2loop0(0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e7) == 0x60c00000) {
				// 01100000110sssssPP0iiiii000ii000 | p3 = sp2loop0(Ii,Rs)
				hi->instruction = HEX_INS_J2_PLOOP2SR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_0;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s P3 = sp2loop0(0x%x,%s) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02004) == 0x69e00000) {
				// 01101001111IIIIIPP0iiiiiIIIii0II | p3 = sp3loop0(Ii,#II)
				hi->instruction = HEX_INS_J2_PLOOP3SI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_0;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x1f0000) >> 11) | (((hi_u32)&0xe0) >> 3) | (((hi_u32)&0x3) >> 0)); // II
				sprintf(hi->mnem, "%s P3 = sP3loop0(0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e7) == 0x60e00000) {
				// 01100000111sssssPP0iiiii000ii000 | p3 = sp3loop0(Ii,Rs)
				hi->instruction = HEX_INS_J2_PLOOP3SR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_LOOP_0;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].op.imm = ((((hi_u32)&0x1f00) >> 6) | (((hi_u32)&0x18) >> 3)) << 2; // scaled Ii
				hi->ops[0].attr = HEX_OP_IMM_SCALED;
				hi->ops[0].shift = 2;
				if (hi->ops[0].op.imm & (1 << 8)) { // signed
					hi->ops[0].op.imm |= (0xffffffff << 8);
				}
				hex_op_extend(&(hi->ops[0]), false); // Extension possible
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s P3 = sP3loop0(0x%x,%s) %s", hi->pkt_info.syntax_prefix, addr + (st32)hi->ops[0].op.imm, hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0x6c200000) {
				// 0110110000100000PP00000000000000 | brkpt
				hi->instruction = HEX_INS_Y2_BREAK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s brkpt %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0x64400000) {
				// 01100100010sssssPP00000000000000 | wait(Rs)
				hi->instruction = HEX_INS_Y2_WAIT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s wait(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0x62400000) {
				// 01100010010sssssPP00000000000000 | trace(Rs)
				hi->instruction = HEX_INS_Y4_TRACE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s trace(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0x62400020) {
				// 01100010010sssssPP00000000100000 | diag(Rs)
				hi->instruction = HEX_INS_Y6_DIAG;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s diag(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020ff) == 0x62400040) {
				// 01100010010sssssPP0ttttt01000000 | diag0(Rss,Rtt)
				hi->instruction = HEX_INS_Y6_DIAG0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s diag0(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020ff) == 0x62400060) {
				// 01100010010sssssPP0ttttt01100000 | diag1(Rss,Rtt)
				hi->instruction = HEX_INS_Y6_DIAG1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s diag1(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x7:
			if ((hi_u32 & 0xffc00000) == 0x76000000) {
				// 0111011000isssssPPiiiiiiiiiddddd | Rd = and(Rs,#Ii)
				hi->instruction = HEX_INS_A2_ANDIR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 9)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x70000000) {
				// 01110000000sssssPP000000000ddddd | Rd = aslh(Rs)
				hi->instruction = HEX_INS_A2_ASLH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = aslh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x70200000) {
				// 01110000001sssssPP000000000ddddd | Rd = asrh(Rs)
				hi->instruction = HEX_INS_A2_ASRH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = asrh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff800000) == 0x7c000000) {
				// 011111000IIIIIIIPPIiiiiiiiiddddd | Rdd = combine(#Ii,#II)
				hi->instruction = HEX_INS_A2_COMBINEII;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[1].op.imm & (1 << 7)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x7f0000) >> 15) | (((hi_u32)&0x2000) >> 13)); // II
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = combine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), signed_imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0x7f000000) {
				// 0111111100000000PP00000000000000 | nop
				hi->instruction = HEX_INS_A2_NOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s nop %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0x76800000) {
				// 0111011010isssssPPiiiiiiiiiddddd | Rd = or(Rs,#Ii)
				hi->instruction = HEX_INS_A2_ORIR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 9)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x74800000) {
				// 011101001uusssssPP0iiiiiiiiddddd | if (!Pu) Rd = add(Rs,#Ii)
				hi->instruction = HEX_INS_A2_PADDIF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 7)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x74802000) {
				// 011101001uusssssPP1iiiiiiiiddddd | if (!Pu.new) Rd = add(Rs,#Ii)
				hi->instruction = HEX_INS_A2_PADDIFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 7)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x74000000) {
				// 011101000uusssssPP0iiiiiiiiddddd | if (Pu) Rd = add(Rs,#Ii)
				hi->instruction = HEX_INS_A2_PADDIT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 7)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x74002000) {
				// 011101000uusssssPP1iiiiiiiiddddd | if (Pu.new) Rd = add(Rs,#Ii)
				hi->instruction = HEX_INS_A2_PADDITNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 7)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0x76400000) {
				// 0111011001isssssPPiiiiiiiiiddddd | Rd = sub(#Ii,Rs)
				hi->instruction = HEX_INS_A2_SUBRI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[1].op.imm & (1 << 9)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x70a00000) {
				// 01110000101sssssPP000000000ddddd | Rd = sxtb(Rs)
				hi->instruction = HEX_INS_A2_SXTB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x70e00000) {
				// 01110000111sssssPP000000000ddddd | Rd = sxth(Rs)
				hi->instruction = HEX_INS_A2_SXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x70600000) {
				// 01110000011sssssPP000000000ddddd | Rd = Rs
				hi->instruction = HEX_INS_A2_TFR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff200000) == 0x72200000) {
				// 01110010ii1xxxxxPPiiiiiiiiiiiiii | Rx.h = #Ii
				hi->instruction = HEX_INS_A2_TFRIH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 8) | (((hi_u32)&0x3fff) >> 0)); // Ii
				sprintf(hi->mnem, "%s %s.h = #0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff200000) == 0x71200000) {
				// 01110001ii1xxxxxPPiiiiiiiiiiiiii | Rx.l = #Ii
				hi->instruction = HEX_INS_A2_TFRIL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 8) | (((hi_u32)&0x3fff) >> 0)); // Ii
				sprintf(hi->mnem, "%s %s.l = #0x%x %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff200000) == 0x78000000) {
				// 01111000ii0iiiiiPPiiiiiiiiiddddd | Rd = #Ii
				hi->instruction = HEX_INS_A2_TFRSI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xc00000) >> 8) | (((hi_u32)&0x1f0000) >> 7) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[1].op.imm & (1 << 15)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 15);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x70c00000) {
				// 01110000110sssssPP000000000ddddd | Rd = zxth(Rs)
				hi->instruction = HEX_INS_A2_ZXTH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00000) == 0x7c800000) {
				// 01111100100IIIIIPPIiiiiiiiiddddd | Rdd = combine(#Ii,#II)
				hi->instruction = HEX_INS_A4_COMBINEII;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[1].op.imm & (1 << 7)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x2000) >> 13)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = combine(%s,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), signed_imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x73202000) {
				// 01110011001sssssPP1iiiiiiiiddddd | Rdd = combine(#Ii,Rs)
				hi->instruction = HEX_INS_A4_COMBINEIR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[1].op.imm & (1 << 7)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = combine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x73002000) {
				// 01110011000sssssPP1iiiiiiiiddddd | Rdd = combine(Rs,#Ii)
				hi->instruction = HEX_INS_A4_COMBINERI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = combine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70002800) {
				// 01110000000sssssPP1010uu000ddddd | if (!Pu) Rd = aslh(Rs)
				hi->instruction = HEX_INS_A4_PASLHF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) %s = aslh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70002c00) {
				// 01110000000sssssPP1011uu000ddddd | if (!Pu.new) Rd = aslh(Rs)
				hi->instruction = HEX_INS_A4_PASLHFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = aslh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70002000) {
				// 01110000000sssssPP1000uu000ddddd | if (Pu) Rd = aslh(Rs)
				hi->instruction = HEX_INS_A4_PASLHT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) %s = aslh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70002400) {
				// 01110000000sssssPP1001uu000ddddd | if (Pu.new) Rd = aslh(Rs)
				hi->instruction = HEX_INS_A4_PASLHTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = aslh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70202800) {
				// 01110000001sssssPP1010uu000ddddd | if (!Pu) Rd = asrh(Rs)
				hi->instruction = HEX_INS_A4_PASRHF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) %s = asrh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70202c00) {
				// 01110000001sssssPP1011uu000ddddd | if (!Pu.new) Rd = asrh(Rs)
				hi->instruction = HEX_INS_A4_PASRHFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = asrh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70202000) {
				// 01110000001sssssPP1000uu000ddddd | if (Pu) Rd = asrh(Rs)
				hi->instruction = HEX_INS_A4_PASRHT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) %s = asrh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70202400) {
				// 01110000001sssssPP1001uu000ddddd | if (Pu.new) Rd = asrh(Rs)
				hi->instruction = HEX_INS_A4_PASRHTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = asrh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70a02800) {
				// 01110000101sssssPP1010uu000ddddd | if (!Pu) Rd = sxtb(Rs)
				hi->instruction = HEX_INS_A4_PSXTBF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70a02c00) {
				// 01110000101sssssPP1011uu000ddddd | if (!Pu.new) Rd = sxtb(Rs)
				hi->instruction = HEX_INS_A4_PSXTBFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70a02000) {
				// 01110000101sssssPP1000uu000ddddd | if (Pu) Rd = sxtb(Rs)
				hi->instruction = HEX_INS_A4_PSXTBT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70a02400) {
				// 01110000101sssssPP1001uu000ddddd | if (Pu.new) Rd = sxtb(Rs)
				hi->instruction = HEX_INS_A4_PSXTBTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = sxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70e02800) {
				// 01110000111sssssPP1010uu000ddddd | if (!Pu) Rd = sxth(Rs)
				hi->instruction = HEX_INS_A4_PSXTHF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70e02c00) {
				// 01110000111sssssPP1011uu000ddddd | if (!Pu.new) Rd = sxth(Rs)
				hi->instruction = HEX_INS_A4_PSXTHFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70e02000) {
				// 01110000111sssssPP1000uu000ddddd | if (Pu) Rd = sxth(Rs)
				hi->instruction = HEX_INS_A4_PSXTHT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70e02400) {
				// 01110000111sssssPP1001uu000ddddd | if (Pu.new) Rd = sxth(Rs)
				hi->instruction = HEX_INS_A4_PSXTHTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = sxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70802800) {
				// 01110000100sssssPP1010uu000ddddd | if (!Pu) Rd = zxtb(Rs)
				hi->instruction = HEX_INS_A4_PZXTBF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) %s = zxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70802c00) {
				// 01110000100sssssPP1011uu000ddddd | if (!Pu.new) Rd = zxtb(Rs)
				hi->instruction = HEX_INS_A4_PZXTBFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = zxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70802000) {
				// 01110000100sssssPP1000uu000ddddd | if (Pu) Rd = zxtb(Rs)
				hi->instruction = HEX_INS_A4_PZXTBT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) %s = zxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70802400) {
				// 01110000100sssssPP1001uu000ddddd | if (Pu.new) Rd = zxtb(Rs)
				hi->instruction = HEX_INS_A4_PZXTBTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = zxtb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70c02800) {
				// 01110000110sssssPP1010uu000ddddd | if (!Pu) Rd = zxth(Rs)
				hi->instruction = HEX_INS_A4_PZXTHF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70c02c00) {
				// 01110000110sssssPP1011uu000ddddd | if (!Pu.new) Rd = zxth(Rs)
				hi->instruction = HEX_INS_A4_PZXTHFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70c02000) {
				// 01110000110sssssPP1000uu000ddddd | if (Pu) Rd = zxth(Rs)
				hi->instruction = HEX_INS_A4_PZXTHT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x70c02400) {
				// 01110000110sssssPP1001uu000ddddd | if (Pu.new) Rd = zxth(Rs)
				hi->instruction = HEX_INS_A4_PZXTHTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = zxth(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x73402000) {
				// 01110011010sssssPP1iiiiiiiiddddd | Rd = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_A4_RCMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0x73602000) {
				// 01110011011sssssPP1iiiiiiiiddddd | Rd = !cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_A4_RCMPNEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = !cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff902000) == 0x7e800000) {
				// 011111101uu0iiiiPP0iiiiiiiiddddd | if (!Pu) Rd = #Ii
				hi->instruction = HEX_INS_C2_CMOVEIF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf0000) >> 8) | (((hi_u32)&0x1fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff902000) == 0x7e000000) {
				// 011111100uu0iiiiPP0iiiiiiiiddddd | if (Pu) Rd = #Ii
				hi->instruction = HEX_INS_C2_CMOVEIT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf0000) >> 8) | (((hi_u32)&0x1fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff902000) == 0x7e802000) {
				// 011111101uu0iiiiPP1iiiiiiiiddddd | if (!Pu.new) Rd = #Ii
				hi->instruction = HEX_INS_C2_CMOVENEWIF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf0000) >> 8) | (((hi_u32)&0x1fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff902000) == 0x7e002000) {
				// 011111100uu0iiiiPP1iiiiiiiiddddd | if (Pu.new) Rd = #Ii
				hi->instruction = HEX_INS_C2_CMOVENEWIT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf0000) >> 8) | (((hi_u32)&0x1fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc0001c) == 0x75000000) {
				// 0111010100isssssPPiiiiiiiii000dd | Pd = cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_C2_CMPEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 9)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc0001c) == 0x75400000) {
				// 0111010101isssssPPiiiiiiiii000dd | Pd = cmp.gt(Rs,#Ii)
				hi->instruction = HEX_INS_C2_CMPGTI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 9)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = cmp.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0001c) == 0x75800000) {
				// 01110101100sssssPPiiiiiiiii000dd | Pd = cmp.gtu(Rs,#Ii)
				hi->instruction = HEX_INS_C2_CMPGTUI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3fe0) >> 5); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = cmp.gtu(%s,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfe000000) == 0x7a000000) {
				// 0111101uuIIIIIIIPPIiiiiiiiiddddd | Rd = mux(Pu,#Ii,#II)
				hi->instruction = HEX_INS_C2_MUXII;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1800000) >> 23); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x7f0000) >> 15) | (((hi_u32)&0x2000) >> 13)); // II
				if (hi->ops[3].op.imm & (1 << 7)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s %s = mux(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), signed_imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x73000000) {
				// 011100110uusssssPP0iiiiiiiiddddd | Rd = mux(Pu,Rs,#Ii)
				hi->instruction = HEX_INS_C2_MUXIR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 7)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s %s = mux(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x73800000) {
				// 011100111uusssssPP0iiiiiiiiddddd | Rd = mux(Pu,#Ii,Rs)
				hi->instruction = HEX_INS_C2_MUXRI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x600000) >> 21); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = mux(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc0001c) == 0x75400010) {
				// 0111010101isssssPPiiiiiiiii100dd | Pd = !cmp.gt(Rs,#Ii)
				hi->instruction = HEX_INS_C4_CMPLTEI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 9)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = !cmp.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0001c) == 0x75800010) {
				// 01110101100sssssPPiiiiiiiii100dd | Pd = !cmp.gtu(Rs,#Ii)
				hi->instruction = HEX_INS_C4_CMPLTEUI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3fe0) >> 5); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = !cmp.gtu(%s,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc0001c) == 0x75000010) {
				// 0111010100isssssPPiiiiiiiii100dd | Pd = !cmp.eq(Rs,#Ii)
				hi->instruction = HEX_INS_C4_CMPNEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 9)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = !cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x8:
			if ((hi_u32 & 0xffe03fe0) == 0x8c800080) {
				// 10001100100sssssPP000000100ddddd | Rd = abs(Rs)
				hi->instruction = HEX_INS_A2_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = abs(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x808000c0) {
				// 10000000100sssssPP000000110ddddd | Rdd = abs(Rss)
				hi->instruction = HEX_INS_A2_ABSP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = abs(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c8000a0) {
				// 10001100100sssssPP000000101ddddd | Rd = abs(Rs):sat
				hi->instruction = HEX_INS_A2_ABSSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = abs(%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x808000a0) {
				// 10000000100sssssPP000000101ddddd | Rdd = neg(Rss)
				hi->instruction = HEX_INS_A2_NEGP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = neg(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c8000c0) {
				// 10001100100sssssPP000000110ddddd | Rd = neg(Rs):sat
				hi->instruction = HEX_INS_A2_NEGSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = neg(%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80800080) {
				// 10000000100sssssPP000000100ddddd | Rdd = not(Rss)
				hi->instruction = HEX_INS_A2_NOTP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = not(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88c00020) {
				// 10001000110sssssPP000000001ddddd | Rd = round(Rss):sat
				hi->instruction = HEX_INS_A2_ROUNDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = round(%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88c00000) {
				// 10001000110sssssPP000000000ddddd | Rd = sat(Rss)
				hi->instruction = HEX_INS_A2_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = sat(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8cc000e0) {
				// 10001100110sssssPP000000111ddddd | Rd = satb(Rs)
				hi->instruction = HEX_INS_A2_SATB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = satb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8cc00080) {
				// 10001100110sssssPP000000100ddddd | Rd = sath(Rs)
				hi->instruction = HEX_INS_A2_SATH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sath(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8cc000c0) {
				// 10001100110sssssPP000000110ddddd | Rd = satub(Rs)
				hi->instruction = HEX_INS_A2_SATUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = satub(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8cc000a0) {
				// 10001100110sssssPP000000101ddddd | Rd = satuh(Rs)
				hi->instruction = HEX_INS_A2_SATUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = satuh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c8000e0) {
				// 10001100100sssssPP000000111ddddd | Rd = swiz(Rs)
				hi->instruction = HEX_INS_A2_SWIZ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = swiz(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84400000) {
				// 10000100010sssssPP000000000ddddd | Rdd = sxtw(Rs)
				hi->instruction = HEX_INS_A2_SXTW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sxtw(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80400080) {
				// 10000000010sssssPP000000100ddddd | Rdd = vabsh(Rss)
				hi->instruction = HEX_INS_A2_VABSH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vabsh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x804000a0) {
				// 10000000010sssssPP000000101ddddd | Rdd = vabsh(Rss):sat
				hi->instruction = HEX_INS_A2_VABSHSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vabsh(%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x804000c0) {
				// 10000000010sssssPP000000110ddddd | Rdd = vabsw(Rss)
				hi->instruction = HEX_INS_A2_VABSW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vabsw(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x804000e0) {
				// 10000000010sssssPP000000111ddddd | Rdd = vabsw(Rss):sat
				hi->instruction = HEX_INS_A2_VABSWSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vabsw(%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x808000e0) {
				// 10000000100sssssPP000000111ddddd | Rdd = vconj(Rss):sat
				hi->instruction = HEX_INS_A2_VCONJ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vconj(%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x88c00080) {
				// 10001000110sssssPP0iiiii100ddddd | Rdd = bitsplit(Rs,#Ii)
				hi->instruction = HEX_INS_A4_BITSPLITI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = bitsplit(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8ce00000) {
				// 10001100111sssssPP0iiiii000ddddd | Rd = cround(Rs,#Ii)
				hi->instruction = HEX_INS_A4_CROUND_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = cround(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8ce00080) {
				// 10001100111sssssPP0iiiii100ddddd | Rd = round(Rs,#Ii)
				hi->instruction = HEX_INS_A4_ROUND_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = round(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8ce000c0) {
				// 10001100111sssssPP0iiiii110ddddd | Rd = round(Rs,#Ii):sat
				hi->instruction = HEX_INS_A4_ROUND_RI_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = round(%s,#0x%x):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x88c000a0) {
				// 10001000110sssssPP0iiiii101ddddd | Rd = clip(Rs,#Ii)
				hi->instruction = HEX_INS_A7_CLIP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = clip(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x8ce00040) {
				// 10001100111sssssPPiiiiii010ddddd | Rdd = cround(Rss,#Ii)
				hi->instruction = HEX_INS_A7_CROUNDD_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = cround(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x88c000c0) {
				// 10001000110sssssPP0iiiii110ddddd | Rdd = vclip(Rss,#Ii)
				hi->instruction = HEX_INS_A7_VCLIP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vclip(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000fc) == 0x85800000) {
				// 10000101100sssssPPiiiiii000000dd | Pd = bitsclr(Rs,#Ii)
				hi->instruction = HEX_INS_C2_BITSCLRI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = bitsclr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3ce0) == 0x86000000) {
				// 1000011000000000PP0000tt000ddddd | Rdd = mask(Pt)
				hi->instruction = HEX_INS_C2_MASK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				sprintf(hi->mnem, "%s %s = mask(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3fe0) == 0x89400000) {
				// 10001001010000ssPP000000000ddddd | Rd = Ps
				hi->instruction = HEX_INS_C2_TFRPR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ffc) == 0x85400000) {
				// 10000101010sssssPP000000000000dd | Pd = Rs
				hi->instruction = HEX_INS_C2_TFRRP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3ce0) == 0x89000000) {
				// 10001001000000ssPP0000tt000ddddd | Rd = vitpack(Ps,Pt)
				hi->instruction = HEX_INS_C2_VITPACK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x30000) >> 16); // Ps4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x300) >> 8); // Pt4
				sprintf(hi->mnem, "%s %s = vitpack(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000fc) == 0x85a00000) {
				// 10000101101sssssPPiiiiii000000dd | Pd = !bitsclr(Rs,#Ii)
				hi->instruction = HEX_INS_C4_NBITSCLRI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = !bitsclr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80e00060) {
				// 10000000111sssssPP000000011ddddd | Rdd = convert_d2df(Rss)
				hi->instruction = HEX_INS_F2_CONV_D2DF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_D2df(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88400020) {
				// 10001000010sssssPP000000001ddddd | Rd = convert_d2sf(Rss)
				hi->instruction = HEX_INS_F2_CONV_D2SF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_D2sf(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80e00000) {
				// 10000000111sssssPP000000000ddddd | Rdd = convert_df2d(Rss)
				hi->instruction = HEX_INS_F2_CONV_DF2D;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2d(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80e000c0) {
				// 10000000111sssssPP000000110ddddd | Rdd = convert_df2d(Rss):chop
				hi->instruction = HEX_INS_F2_CONV_DF2D_CHOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2d(%s):chop %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88000020) {
				// 10001000000sssssPP000000001ddddd | Rd = convert_df2sf(Rss)
				hi->instruction = HEX_INS_F2_CONV_DF2SF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2sf(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80e00020) {
				// 10000000111sssssPP000000001ddddd | Rdd = convert_df2ud(Rss)
				hi->instruction = HEX_INS_F2_CONV_DF2UD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2ud(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80e000e0) {
				// 10000000111sssssPP000000111ddddd | Rdd = convert_df2ud(Rss):chop
				hi->instruction = HEX_INS_F2_CONV_DF2UD_CHOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2ud(%s):chop %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88600020) {
				// 10001000011sssssPP000000001ddddd | Rd = convert_df2uw(Rss)
				hi->instruction = HEX_INS_F2_CONV_DF2UW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2uw(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88a00020) {
				// 10001000101sssssPP000000001ddddd | Rd = convert_df2uw(Rss):chop
				hi->instruction = HEX_INS_F2_CONV_DF2UW_CHOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2uw(%s):chop %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88800020) {
				// 10001000100sssssPP000000001ddddd | Rd = convert_df2w(Rss)
				hi->instruction = HEX_INS_F2_CONV_DF2W;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2w(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88e00020) {
				// 10001000111sssssPP000000001ddddd | Rd = convert_df2w(Rss):chop
				hi->instruction = HEX_INS_F2_CONV_DF2W_CHOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_df2w(%s):chop %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84800080) {
				// 10000100100sssssPP000000100ddddd | Rdd = convert_sf2d(Rs)
				hi->instruction = HEX_INS_F2_CONV_SF2D;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2d(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x848000c0) {
				// 10000100100sssssPP000000110ddddd | Rdd = convert_sf2d(Rs):chop
				hi->instruction = HEX_INS_F2_CONV_SF2D_CHOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2d(%s):chop %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84800000) {
				// 10000100100sssssPP000000000ddddd | Rdd = convert_sf2df(Rs)
				hi->instruction = HEX_INS_F2_CONV_SF2DF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2df(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84800060) {
				// 10000100100sssssPP000000011ddddd | Rdd = convert_sf2ud(Rs)
				hi->instruction = HEX_INS_F2_CONV_SF2UD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2ud(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x848000a0) {
				// 10000100100sssssPP000000101ddddd | Rdd = convert_sf2ud(Rs):chop
				hi->instruction = HEX_INS_F2_CONV_SF2UD_CHOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2ud(%s):chop %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8b600000) {
				// 10001011011sssssPP000000000ddddd | Rd = convert_sf2uw(Rs)
				hi->instruction = HEX_INS_F2_CONV_SF2UW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2uw(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8b600020) {
				// 10001011011sssssPP000000001ddddd | Rd = convert_sf2uw(Rs):chop
				hi->instruction = HEX_INS_F2_CONV_SF2UW_CHOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2uw(%s):chop %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8b800000) {
				// 10001011100sssssPP000000000ddddd | Rd = convert_sf2w(Rs)
				hi->instruction = HEX_INS_F2_CONV_SF2W;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2w(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8b800020) {
				// 10001011100sssssPP000000001ddddd | Rd = convert_sf2w(Rs):chop
				hi->instruction = HEX_INS_F2_CONV_SF2W_CHOP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_sf2w(%s):chop %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80e00040) {
				// 10000000111sssssPP000000010ddddd | Rdd = convert_ud2df(Rss)
				hi->instruction = HEX_INS_F2_CONV_UD2DF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_ud2df(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88200020) {
				// 10001000001sssssPP000000001ddddd | Rd = convert_ud2sf(Rss)
				hi->instruction = HEX_INS_F2_CONV_UD2SF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = convert_ud2sf(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84800020) {
				// 10000100100sssssPP000000001ddddd | Rdd = convert_uw2df(Rs)
				hi->instruction = HEX_INS_F2_CONV_UW2DF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_uw2df(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8b200000) {
				// 10001011001sssssPP000000000ddddd | Rd = convert_uw2sf(Rs)
				hi->instruction = HEX_INS_F2_CONV_UW2SF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_uw2sf(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84800040) {
				// 10000100100sssssPP000000010ddddd | Rdd = convert_w2df(Rs)
				hi->instruction = HEX_INS_F2_CONV_W2DF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_W2df(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8b400000) {
				// 10001011010sssssPP000000000ddddd | Rd = convert_w2sf(Rs)
				hi->instruction = HEX_INS_F2_CONV_W2SF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = convert_W2sf(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x85e00000) {
				// 10000101111sssssPP0iiiii000000dd | Pd = sfclass(Rs,#Ii)
				hi->instruction = HEX_INS_F2_SFCLASS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = sfclass(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8ba00000) {
				// 10001011101sssssPP000000000ddddd | Rd = sffixupr(Rs)
				hi->instruction = HEX_INS_F2_SFFIXUPR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sffixupr(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03f80) == 0x8be00000) {
				// 10001011111sssssPP0000000eeddddd | Rd,Pe = sfinvsqrta(Rs)
				hi->instruction = HEX_INS_F2_SFINVSQRTA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Pe4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s,%s = sfinvsqrta(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x80000040) {
				// 10000000000sssssPPiiiiii010ddddd | Rdd = asl(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x820000c0) {
				// 10000010000sssssPPiiiiii110xxxxx | Rxx += asl(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_P_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s += asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82400040) {
				// 10000010010sssssPPiiiiii010xxxxx | Rxx &= asl(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_P_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s &= asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82000040) {
				// 10000010000sssssPPiiiiii010xxxxx | Rxx -= asl(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_P_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s -= asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x824000c0) {
				// 10000010010sssssPPiiiiii110xxxxx | Rxx |= asl(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_P_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s |= asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82800040) {
				// 10000010100sssssPPiiiiii010xxxxx | Rxx ^= asl(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_P_XACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s ^= asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8c000040) {
				// 10001100000sssssPP0iiiii010ddddd | Rd = asl(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e0000c0) {
				// 10001110000sssssPP0iiiii110xxxxx | Rx += asl(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_R_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s += asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e400040) {
				// 10001110010sssssPP0iiiii010xxxxx | Rx &= asl(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_R_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s &= asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e000040) {
				// 10001110000sssssPP0iiiii010xxxxx | Rx -= asl(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_R_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s -= asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e4000c0) {
				// 10001110010sssssPP0iiiii110xxxxx | Rx |= asl(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_R_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s |= asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8c400040) {
				// 10001100010sssssPP0iiiii010ddddd | Rd = asl(Rs,#Ii):sat
				hi->instruction = HEX_INS_S2_ASL_I_R_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = asl(%s,#0x%x):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e800040) {
				// 10001110100sssssPP0iiiii010xxxxx | Rx ^= asl(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_R_XACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s ^= asl(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe030e0) == 0x80800040) {
				// 10000000100sssssPP00iiii010ddddd | Rdd = vaslh(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_VH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vaslh(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x80400040) {
				// 10000000010sssssPP0iiiii010ddddd | Rdd = vaslw(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASL_I_VW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vaslw(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x80000000) {
				// 10000000000sssssPPiiiiii000ddddd | Rdd = asr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82000080) {
				// 10000010000sssssPPiiiiii100xxxxx | Rxx += asr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_P_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s += asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82400000) {
				// 10000010010sssssPPiiiiii000xxxxx | Rxx &= asr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_P_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s &= asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82000000) {
				// 10000010000sssssPPiiiiii000xxxxx | Rxx -= asr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_P_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s -= asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82400080) {
				// 10000010010sssssPPiiiiii100xxxxx | Rxx |= asr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_P_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s |= asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x80c000e0) {
				// 10000000110sssssPPiiiiii111ddddd | Rdd = asr(Rss,#Ii):rnd
				hi->instruction = HEX_INS_S2_ASR_I_P_RND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = asr(%s,#0x%x):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8c000000) {
				// 10001100000sssssPP0iiiii000ddddd | Rd = asr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e000080) {
				// 10001110000sssssPP0iiiii100xxxxx | Rx += asr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_R_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s += asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e400000) {
				// 10001110010sssssPP0iiiii000xxxxx | Rx &= asr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_R_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s &= asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e000000) {
				// 10001110000sssssPP0iiiii000xxxxx | Rx -= asr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_R_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s -= asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e400080) {
				// 10001110010sssssPP0iiiii100xxxxx | Rx |= asr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_R_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s |= asr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8c400000) {
				// 10001100010sssssPP0iiiii000ddddd | Rd = asr(Rs,#Ii):rnd
				hi->instruction = HEX_INS_S2_ASR_I_R_RND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = asr(%s,#0x%x):rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x88c00040) {
				// 10001000110sssssPP0iiiii010ddddd | Rd = vasrw(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_SVW_TRUN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vasrw(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe030e0) == 0x80800000) {
				// 10000000100sssssPP00iiii000ddddd | Rdd = vasrh(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_VH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vasrh(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x80400000) {
				// 10000000010sssssPP0iiiii000ddddd | Rdd = vasrw(Rss,#Ii)
				hi->instruction = HEX_INS_S2_ASR_I_VW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vasrw(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c4000c0) {
				// 10001100010sssssPP000000110ddddd | Rd = brev(Rs)
				hi->instruction = HEX_INS_S2_BREV;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = brev(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80c000c0) {
				// 10000000110sssssPP000000110ddddd | Rdd = brev(Rss)
				hi->instruction = HEX_INS_S2_BREVP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = brev(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c0000a0) {
				// 10001100000sssssPP000000101ddddd | Rd = cl0(Rs)
				hi->instruction = HEX_INS_S2_CL0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = cl0(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88400040) {
				// 10001000010sssssPP000000010ddddd | Rd = cl0(Rss)
				hi->instruction = HEX_INS_S2_CL0P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = cl0(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c0000c0) {
				// 10001100000sssssPP000000110ddddd | Rd = cl1(Rs)
				hi->instruction = HEX_INS_S2_CL1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = cl1(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88400080) {
				// 10001000010sssssPP000000100ddddd | Rd = cl1(Rss)
				hi->instruction = HEX_INS_S2_CL1P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = cl1(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c000080) {
				// 10001100000sssssPP000000100ddddd | Rd = clb(Rs)
				hi->instruction = HEX_INS_S2_CLB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = clb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c0000e0) {
				// 10001100000sssssPP000000111ddddd | Rd = normamt(Rs)
				hi->instruction = HEX_INS_S2_CLBNORM;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = normamt(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88400000) {
				// 10001000010sssssPP000000000ddddd | Rd = clb(Rss)
				hi->instruction = HEX_INS_S2_CLBP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = clb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8cc00020) {
				// 10001100110sssssPP0iiiii001ddddd | Rd = clrbit(Rs,#Ii)
				hi->instruction = HEX_INS_S2_CLRBIT_I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = clrbit(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c400080) {
				// 10001100010sssssPP000000100ddddd | Rd = ct0(Rs)
				hi->instruction = HEX_INS_S2_CT0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = ct0(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88e00040) {
				// 10001000111sssssPP000000010ddddd | Rd = ct0(Rss)
				hi->instruction = HEX_INS_S2_CT0P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = ct0(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c4000a0) {
				// 10001100010sssssPP000000101ddddd | Rd = ct1(Rs)
				hi->instruction = HEX_INS_S2_CT1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = ct1(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88e00080) {
				// 10001000111sssssPP000000100ddddd | Rd = ct1(Rss)
				hi->instruction = HEX_INS_S2_CT1P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = ct1(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80c00080) {
				// 10000000110sssssPP000000100ddddd | Rdd = deinterleave(Rss)
				hi->instruction = HEX_INS_S2_DEINTERLEAVE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = deinterleave(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x8d000000) {
				// 100011010IIsssssPP0iiiiiIIIddddd | Rd = extractu(Rs,#Ii,#II)
				hi->instruction = HEX_INS_S2_EXTRACTU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x600000) >> 18) | (((hi_u32)&0xe0) >> 5)); // II
				sprintf(hi->mnem, "%s %s = extractu(%s,#0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000000) == 0x81000000) {
				// 10000001IIIsssssPPiiiiiiIIIddddd | Rdd = extractu(Rss,#Ii,#II)
				hi->instruction = HEX_INS_S2_EXTRACTUP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xe00000) >> 18) | (((hi_u32)&0xe0) >> 5)); // II
				sprintf(hi->mnem, "%s %s = extractu(%s,#0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x8f000000) {
				// 100011110IIsssssPP0iiiiiIIIxxxxx | Rx = insert(Rs,#Ii,#II)
				hi->instruction = HEX_INS_S2_INSERT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x600000) >> 18) | (((hi_u32)&0xe0) >> 5)); // II
				sprintf(hi->mnem, "%s %s = insert(%s,#0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000000) == 0x83000000) {
				// 10000011IIIsssssPPiiiiiiIIIxxxxx | Rxx = insert(Rss,#Ii,#II)
				hi->instruction = HEX_INS_S2_INSERTP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xe00000) >> 18) | (((hi_u32)&0xe0) >> 5)); // II
				sprintf(hi->mnem, "%s %s = insert(%s,#0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80c000a0) {
				// 10000000110sssssPP000000101ddddd | Rdd = interleave(Rss)
				hi->instruction = HEX_INS_S2_INTERLEAVE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = interleave(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x80000020) {
				// 10000000000sssssPPiiiiii001ddddd | Rdd = lsr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x820000a0) {
				// 10000010000sssssPPiiiiii101xxxxx | Rxx += lsr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_P_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s += lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82400020) {
				// 10000010010sssssPPiiiiii001xxxxx | Rxx &= lsr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_P_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s &= lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82000020) {
				// 10000010000sssssPPiiiiii001xxxxx | Rxx -= lsr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_P_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s -= lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x824000a0) {
				// 10000010010sssssPPiiiiii101xxxxx | Rxx |= lsr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_P_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s |= lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82800020) {
				// 10000010100sssssPPiiiiii001xxxxx | Rxx ^= lsr(Rss,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_P_XACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s ^= lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8c000020) {
				// 10001100000sssssPP0iiiii001ddddd | Rd = lsr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e0000a0) {
				// 10001110000sssssPP0iiiii101xxxxx | Rx += lsr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_R_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s += lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e400020) {
				// 10001110010sssssPP0iiiii001xxxxx | Rx &= lsr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_R_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s &= lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e000020) {
				// 10001110000sssssPP0iiiii001xxxxx | Rx -= lsr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_R_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s -= lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e4000a0) {
				// 10001110010sssssPP0iiiii101xxxxx | Rx |= lsr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_R_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s |= lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e800020) {
				// 10001110100sssssPP0iiiii001xxxxx | Rx ^= lsr(Rs,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_R_XACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s ^= lsr(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe030e0) == 0x80800020) {
				// 10000000100sssssPP00iiii001ddddd | Rdd = vlsrh(Rss,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_VH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vlsrh(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x80400020) {
				// 10000000010sssssPP0iiiii001ddddd | Rdd = vlsrw(Rss,#Ii)
				hi->instruction = HEX_INS_S2_LSR_I_VW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vlsrw(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff9f2000) == 0x8d002000) {
				// 100011010II00000PP1iiiiiIIIddddd | Rd = mask(#Ii,#II)
				hi->instruction = HEX_INS_S2_MASK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x600000) >> 18) | (((hi_u32)&0xe0) >> 5)); // II
				sprintf(hi->mnem, "%s %s = mask(#0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8cc00000) {
				// 10001100110sssssPP0iiiii000ddddd | Rd = setbit(Rs,#Ii)
				hi->instruction = HEX_INS_S2_SETBIT_I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = setbit(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c800000) {
				// 10001100100sssssPP000000000ddddd | Rd = vsathb(Rs)
				hi->instruction = HEX_INS_S2_SVSATHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsathb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c800040) {
				// 10001100100sssssPP000000010ddddd | Rd = vsathub(Rs)
				hi->instruction = HEX_INS_S2_SVSATHUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsathub(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0x87000000) {
				// 1000011100isssssPPIIIIIIiiixxxxx | Rx = tableidxb(Rs,#Ii,#II):raw
				hi->instruction = HEX_INS_S2_TABLEIDXB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 18) | (((hi_u32)&0xe0) >> 5)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3f00) >> 8); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s %s = tableidxb(%s,#0x%x,%s):raw %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0x87c00000) {
				// 1000011111isssssPPIIIIIIiiixxxxx | Rx = tableidxd(Rs,#Ii,#II):raw
				hi->instruction = HEX_INS_S2_TABLEIDXD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 18) | (((hi_u32)&0xe0) >> 5)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3f00) >> 8); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s %s = tableidxd(%s,#0x%x,%s):raw %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0x87400000) {
				// 1000011101isssssPPIIIIIIiiixxxxx | Rx = tableidxh(Rs,#Ii,#II):raw
				hi->instruction = HEX_INS_S2_TABLEIDXH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 18) | (((hi_u32)&0xe0) >> 5)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3f00) >> 8); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s %s = tableidxh(%s,#0x%x,%s):raw %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0x87800000) {
				// 1000011110isssssPPIIIIIIiiixxxxx | Rx = tableidxw(Rs,#Ii,#II):raw
				hi->instruction = HEX_INS_S2_TABLEIDXW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 18) | (((hi_u32)&0xe0) >> 5)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x3f00) >> 8); // II
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s %s = tableidxw(%s,#0x%x,%s):raw %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8cc00040) {
				// 10001100110sssssPP0iiiii010ddddd | Rd = togglebit(Rs,#Ii)
				hi->instruction = HEX_INS_S2_TOGGLEBIT_I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = togglebit(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x85000000) {
				// 10000101000sssssPP0iiiii000000dd | Pd = tstbit(Rs,#Ii)
				hi->instruction = HEX_INS_S2_TSTBIT_I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = tstbit(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88800080) {
				// 10001000100sssssPP000000100ddddd | Rd = vrndwh(Rss)
				hi->instruction = HEX_INS_S2_VRNDPACKWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vrndwh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x888000c0) {
				// 10001000100sssssPP000000110ddddd | Rd = vrndwh(Rss):sat
				hi->instruction = HEX_INS_S2_VRNDPACKWHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vrndwh(%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x880000c0) {
				// 10001000000sssssPP000000110ddddd | Rd = vsathb(Rss)
				hi->instruction = HEX_INS_S2_VSATHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsathb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x800000e0) {
				// 10000000000sssssPP000000111ddddd | Rdd = vsathb(Rss)
				hi->instruction = HEX_INS_S2_VSATHB_NOPACK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsathb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88000000) {
				// 10001000000sssssPP000000000ddddd | Rd = vsathub(Rss)
				hi->instruction = HEX_INS_S2_VSATHUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsathub(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x80000080) {
				// 10000000000sssssPP000000100ddddd | Rdd = vsathub(Rss)
				hi->instruction = HEX_INS_S2_VSATHUB_NOPACK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsathub(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88000040) {
				// 10001000000sssssPP000000010ddddd | Rd = vsatwh(Rss)
				hi->instruction = HEX_INS_S2_VSATWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsatwh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x800000c0) {
				// 10000000000sssssPP000000110ddddd | Rdd = vsatwh(Rss)
				hi->instruction = HEX_INS_S2_VSATWH_NOPACK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsatwh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88000080) {
				// 10001000000sssssPP000000100ddddd | Rd = vsatwuh(Rss)
				hi->instruction = HEX_INS_S2_VSATWUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsatwuh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x800000a0) {
				// 10000000000sssssPP000000101ddddd | Rdd = vsatwuh(Rss)
				hi->instruction = HEX_INS_S2_VSATWUH_NOPACK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsatwuh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x8c4000e0) {
				// 10001100010sssssPP000000111ddddd | Rd = vsplatb(Rs)
				hi->instruction = HEX_INS_S2_VSPLATRB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsplatb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84400040) {
				// 10000100010sssssPP000000010ddddd | Rdd = vsplath(Rs)
				hi->instruction = HEX_INS_S2_VSPLATRH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsplath(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84000000) {
				// 10000100000sssssPP000000000ddddd | Rdd = vsxtbh(Rs)
				hi->instruction = HEX_INS_S2_VSXTBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsxtbh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84000080) {
				// 10000100000sssssPP000000100ddddd | Rdd = vsxthw(Rs)
				hi->instruction = HEX_INS_S2_VSXTHW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsxthw(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88800040) {
				// 10001000100sssssPP000000010ddddd | Rd = vtrunehb(Rss)
				hi->instruction = HEX_INS_S2_VTRUNEHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vtrunehb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88800000) {
				// 10001000100sssssPP000000000ddddd | Rd = vtrunohb(Rss)
				hi->instruction = HEX_INS_S2_VTRUNOHB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vtrunohb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84000040) {
				// 10000100000sssssPP000000010ddddd | Rdd = vzxtbh(Rs)
				hi->instruction = HEX_INS_S2_VZXTBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vzxtbh(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x840000c0) {
				// 10000100000sssssPP000000110ddddd | Rdd = vzxthw(Rs)
				hi->instruction = HEX_INS_S2_VZXTHW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vzxthw(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x8c200000) {
				// 10001100001sssssPPiiiiii000ddddd | Rd = add(clb(Rs),#Ii)
				hi->instruction = HEX_INS_S4_CLBADDI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(clb(%s),%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x88600040) {
				// 10001000011sssssPPiiiiii010ddddd | Rd = add(clb(Rss),#Ii)
				hi->instruction = HEX_INS_S4_CLBPADDI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(clb(%s),%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88600000) {
				// 10001000011sssssPP000000000ddddd | Rd = normamt(Rss)
				hi->instruction = HEX_INS_S4_CLBPNORM;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = normamt(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff802000) == 0x8d800000) {
				// 100011011IIsssssPP0iiiiiIIIddddd | Rd = extract(Rs,#Ii,#II)
				hi->instruction = HEX_INS_S4_EXTRACT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x600000) >> 18) | (((hi_u32)&0xe0) >> 5)); // II
				sprintf(hi->mnem, "%s %s = extract(%s,#0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000000) == 0x8a000000) {
				// 10001010IIIsssssPPiiiiiiIIIddddd | Rdd = extract(Rss,#Ii,#II)
				hi->instruction = HEX_INS_S4_EXTRACTP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xe00000) >> 18) | (((hi_u32)&0xe0) >> 5)); // II
				sprintf(hi->mnem, "%s %s = extract(%s,#0x%x,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0x85200000) {
				// 10000101001sssssPP0iiiii000000dd | Pd = !tstbit(Rs,#Ii)
				hi->instruction = HEX_INS_S4_NTSTBIT_I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = !tstbit(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe030e0) == 0x88600080) {
				// 10001000011sssssPP00iiii100ddddd | Rd = vasrhub(Rss,#Ii):raw
				hi->instruction = HEX_INS_S5_ASRHUB_RND_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vasrhub(%s,#0x%x):raw %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe030e0) == 0x886000a0) {
				// 10001000011sssssPP00iiii101ddddd | Rd = vasrhub(Rss,#Ii):sat
				hi->instruction = HEX_INS_S5_ASRHUB_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vasrhub(%s,#0x%x):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x88600060) {
				// 10001000011sssssPP000000011ddddd | Rd = popcount(Rss)
				hi->instruction = HEX_INS_S5_POPCOUNTP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = popcount(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe030e0) == 0x80200000) {
				// 10000000001sssssPP00iiii000ddddd | Rdd = vasrh(Rss,#Ii):raw
				hi->instruction = HEX_INS_S5_VASRHRND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xf00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = vasrh(%s,#0x%x):raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x80000060) {
				// 10000000000sssssPPiiiiii011ddddd | Rdd = rol(Rss,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x820000e0) {
				// 10000010000sssssPPiiiiii111xxxxx | Rxx += rol(Rss,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_P_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s += rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82400060) {
				// 10000010010sssssPPiiiiii011xxxxx | Rxx &= rol(Rss,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_P_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s &= rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82000060) {
				// 10000010000sssssPPiiiiii011xxxxx | Rxx -= rol(Rss,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_P_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s -= rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x824000e0) {
				// 10000010010sssssPPiiiiii111xxxxx | Rxx |= rol(Rss,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_P_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s |= rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000e0) == 0x82800060) {
				// 10000010100sssssPPiiiiii011xxxxx | Rxx ^= rol(Rss,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_P_XACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s ^= rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8c000060) {
				// 10001100000sssssPP0iiiii011ddddd | Rd = rol(Rs,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s = rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e0000e0) {
				// 10001110000sssssPP0iiiii111xxxxx | Rx += rol(Rs,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_R_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s += rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e400060) {
				// 10001110010sssssPP0iiiii011xxxxx | Rx &= rol(Rs,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_R_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s &= rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e000060) {
				// 10001110000sssssPP0iiiii011xxxxx | Rx -= rol(Rs,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_R_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s -= rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e4000e0) {
				// 10001110010sssssPP0iiiii111xxxxx | Rx |= rol(Rs,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_R_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s |= rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x8e800060) {
				// 10001110100sssssPP0iiiii011xxxxx | Rx ^= rol(Rs,#Ii)
				hi->instruction = HEX_INS_S6_ROL_I_R_XACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1f00) >> 8); // Ii
				sprintf(hi->mnem, "%s %s ^= rol(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x84400080) {
				// 10000100010sssssPP000000100ddddd | Rdd = vsplatb(Rs)
				hi->instruction = HEX_INS_S6_VSPLATRBP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsplatb(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0x9:
			if ((hi_u32 & 0xffe03fe0) == 0x90000000) {
				// 10010000000sssssPP000000000ddddd | Rdd = deallocframe(Rs):raw
				hi->instruction = HEX_INS_L2_DEALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = deallocframe(%s):raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x90800000) {
				// 10010ii0100sssssPPiiiiiiiiiyyyyy | Ryy = memb_fifo(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADALIGNB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memb_fifo(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9e800000) {
				// 10011110100xxxxxPPu00000000yyyyy | Ryy = memb_fifo(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADALIGNB_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memb_fifo(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x98800000) {
				// 10011000100xxxxxPPu0000iiiiyyyyy | Ryy = memb_fifo(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADALIGNB_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memb_fifo(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x98800200) {
				// 10011000100xxxxxPPu00010000yyyyy | Ryy = memb_fifo(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADALIGNB_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memb_fifo(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9a800000) {
				// 10011010100xxxxxPP00000iiiiyyyyy | Ryy = memb_fifo(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADALIGNB_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memb_fifo(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9c800000) {
				// 10011100100xxxxxPPu00000000yyyyy | Ryy = memb_fifo(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADALIGNB_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memb_fifo(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x90400000) {
				// 10010ii0010sssssPPiiiiiiiiiyyyyy | Ryy = memh_fifo(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADALIGNH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memh_fifo(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9e400000) {
				// 10011110010xxxxxPPu00000000yyyyy | Ryy = memh_fifo(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADALIGNH_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memh_fifo(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x98400000) {
				// 10011000010xxxxxPPu0000iiiiyyyyy | Ryy = memh_fifo(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADALIGNH_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memh_fifo(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x98400200) {
				// 10011000010xxxxxPPu00010000yyyyy | Ryy = memh_fifo(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADALIGNH_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memh_fifo(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9a400000) {
				// 10011010010xxxxxPP00000iiiiyyyyy | Ryy = memh_fifo(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADALIGNH_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memh_fifo(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9c400000) {
				// 10011100010xxxxxPPu00000000yyyyy | Ryy = memh_fifo(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADALIGNH_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memh_fifo(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x90200000) {
				// 10010ii0001sssssPPiiiiiiiiiddddd | Rd = membh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADBSW2_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = membh(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9e200000) {
				// 10011110001xxxxxPPu00000000ddddd | Rd = membh(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADBSW2_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = membh(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x98200000) {
				// 10011000001xxxxxPPu0000iiiiddddd | Rd = membh(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADBSW2_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = membh(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x98200200) {
				// 10011000001xxxxxPPu00010000ddddd | Rd = membh(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADBSW2_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = membh(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9a200000) {
				// 10011010001xxxxxPP00000iiiiddddd | Rd = membh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADBSW2_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = membh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9c200000) {
				// 10011100001xxxxxPPu00000000ddddd | Rd = membh(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADBSW2_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = membh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x90e00000) {
				// 10010ii0111sssssPPiiiiiiiiiddddd | Rdd = membh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADBSW4_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 12)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 12);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = membh(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9ee00000) {
				// 10011110111xxxxxPPu00000000ddddd | Rdd = membh(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADBSW4_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = membh(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x98e00000) {
				// 10011000111xxxxxPPu0000iiiiddddd | Rdd = membh(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADBSW4_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = membh(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x98e00200) {
				// 10011000111xxxxxPPu00010000ddddd | Rdd = membh(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADBSW4_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = membh(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9ae00000) {
				// 10011010111xxxxxPP00000iiiiddddd | Rdd = membh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADBSW4_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = membh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9ce00000) {
				// 10011100111xxxxxPPu00000000ddddd | Rdd = membh(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADBSW4_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = membh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x90600000) {
				// 10010ii0011sssssPPiiiiiiiiiddddd | Rd = memubh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADBZW2_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memubh(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9e600000) {
				// 10011110011xxxxxPPu00000000ddddd | Rd = memubh(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADBZW2_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memubh(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x98600000) {
				// 10011000011xxxxxPPu0000iiiiddddd | Rd = memubh(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADBZW2_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memubh(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x98600200) {
				// 10011000011xxxxxPPu00010000ddddd | Rd = memubh(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADBZW2_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memubh(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9a600000) {
				// 10011010011xxxxxPP00000iiiiddddd | Rd = memubh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADBZW2_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memubh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9c600000) {
				// 10011100011xxxxxPPu00000000ddddd | Rd = memubh(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADBZW2_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memubh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x90a00000) {
				// 10010ii0101sssssPPiiiiiiiiiddddd | Rdd = memubh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADBZW4_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 12)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 12);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memubh(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9ea00000) {
				// 10011110101xxxxxPPu00000000ddddd | Rdd = memubh(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADBZW4_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memubh(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x98a00000) {
				// 10011000101xxxxxPPu0000iiiiddddd | Rdd = memubh(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADBZW4_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memubh(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x98a00200) {
				// 10011000101xxxxxPPu00010000ddddd | Rdd = memubh(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADBZW4_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memubh(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9aa00000) {
				// 10011010101xxxxxPP00000iiiiddddd | Rdd = memubh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADBZW4_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memubh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9ca00000) {
				// 10011100101xxxxxPPu00000000ddddd | Rdd = memubh(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADBZW4_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memubh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x91000000) {
				// 10010ii1000sssssPPiiiiiiiiiddddd | Rd = memb(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADRB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memb(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9f000000) {
				// 10011111000xxxxxPPu00000000ddddd | Rd = memb(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADRB_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memb(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x99000000) {
				// 10011001000xxxxxPPu0000iiiiddddd | Rd = memb(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRB_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memb(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x99000200) {
				// 10011001000xxxxxPPu00010000ddddd | Rd = memb(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRB_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memb(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9b000000) {
				// 10011011000xxxxxPP00000iiiiddddd | Rd = memb(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADRB_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memb(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9d000000) {
				// 10011101000xxxxxPPu00000000ddddd | Rd = memb(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADRB_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memb(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x91c00000) {
				// 10010ii1110sssssPPiiiiiiiiiddddd | Rdd = memd(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADRD_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 13)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 13);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memd(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9fc00000) {
				// 10011111110xxxxxPPu00000000ddddd | Rdd = memd(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADRD_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memd(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x99c00000) {
				// 10011001110xxxxxPPu0000iiiiddddd | Rdd = memd(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRD_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memd(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x99c00200) {
				// 10011001110xxxxxPPu00010000ddddd | Rdd = memd(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRD_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memd(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9bc00000) {
				// 10011011110xxxxxPP00000iiiiddddd | Rdd = memd(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADRD_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memd(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9dc00000) {
				// 10011101110xxxxxPPu00000000ddddd | Rdd = memd(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADRD_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memd(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x91400000) {
				// 10010ii1010sssssPPiiiiiiiiiddddd | Rd = memh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADRH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memh(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9f400000) {
				// 10011111010xxxxxPPu00000000ddddd | Rd = memh(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADRH_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memh(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x99400000) {
				// 10011001010xxxxxPPu0000iiiiddddd | Rd = memh(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRH_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memh(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x99400200) {
				// 10011001010xxxxxPPu00010000ddddd | Rd = memh(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRH_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memh(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9b400000) {
				// 10011011010xxxxxPP00000iiiiddddd | Rd = memh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADRH_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9d400000) {
				// 10011101010xxxxxPPu00000000ddddd | Rd = memh(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADRH_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x91800000) {
				// 10010ii1100sssssPPiiiiiiiiiddddd | Rd = memw(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADRI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 12)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 12);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memw(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9f800000) {
				// 10011111100xxxxxPPu00000000ddddd | Rd = memw(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADRI_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memw(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x99800000) {
				// 10011001100xxxxxPPu0000iiiiddddd | Rd = memw(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRI_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memw(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x99800200) {
				// 10011001100xxxxxPPu00010000ddddd | Rd = memw(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRI_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memw(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9b800000) {
				// 10011011100xxxxxPP00000iiiiddddd | Rd = memw(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADRI_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memw(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9d800000) {
				// 10011101100xxxxxPPu00000000ddddd | Rd = memw(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADRI_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memw(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x91200000) {
				// 10010ii1001sssssPPiiiiiiiiiddddd | Rd = memub(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADRUB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 10)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memub(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9f200000) {
				// 10011111001xxxxxPPu00000000ddddd | Rd = memub(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADRUB_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memub(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x99200000) {
				// 10011001001xxxxxPPu0000iiiiddddd | Rd = memub(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRUB_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memub(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x99200200) {
				// 10011001001xxxxxPPu00010000ddddd | Rd = memub(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRUB_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memub(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9b200000) {
				// 10011011001xxxxxPP00000iiiiddddd | Rd = memub(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADRUB_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memub(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9d200000) {
				// 10011101001xxxxxPPu00000000ddddd | Rd = memub(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADRUB_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memub(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0x91600000) {
				// 10010ii1011sssssPPiiiiiiiiiddddd | Rd = memuh(Rs+#Ii)
				hi->instruction = HEX_INS_L2_LOADRUH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x3fe0) >> 5)) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 11)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memuh(%s+%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9f600000) {
				// 10011111011xxxxxPPu00000000ddddd | Rd = memuh(Rx++Mu:brev)
				hi->instruction = HEX_INS_L2_LOADRUH_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memuh(%s++%s:brev) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01e00) == 0x99600000) {
				// 10011001011xxxxxPPu0000iiiiddddd | Rd = memuh(Rx++#Ii:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRUH_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memuh(%s++%s:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_mod_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x99600200) {
				// 10011001011xxxxxPPu00010000ddddd | Rd = memuh(Rx++I:circ(Mu))
				hi->instruction = HEX_INS_L2_LOADRUH_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memuh(%s++I:circ(%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03e00) == 0x9b600000) {
				// 10011011011xxxxxPP00000iiiiddddd | Rd = memuh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_LOADRUH_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = memuh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01fe0) == 0x9d600000) {
				// 10011101011xxxxxPPu00000000ddddd | Rd = memuh(Rx++Mu)
				hi->instruction = HEX_INS_L2_LOADRUH_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s %s = memuh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x92000800) {
				// 10010010000sssssPP001000000ddddd | Rd = memw_aq(Rs)
				hi->instruction = HEX_INS_L2_LOADW_AQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = memw_aq(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x92000000) {
				// 10010010000sssssPP000000000ddddd | Rd = memw_locked(Rs)
				hi->instruction = HEX_INS_L2_LOADW_LOCKED;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = memw_locked(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b002800) {
				// 10011011000xxxxxPP101ttiiiiddddd | if (!Pt) Rd = memb(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRBF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = memb(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b003800) {
				// 10011011000xxxxxPP111ttiiiiddddd | if (!Pt.new) Rd = memb(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRBFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) %s = memb(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b002000) {
				// 10011011000xxxxxPP100ttiiiiddddd | if (Pt) Rd = memb(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRBT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = memb(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b003000) {
				// 10011011000xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memb(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRBTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) %s = memb(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9bc02800) {
				// 10011011110xxxxxPP101ttiiiiddddd | if (!Pt) Rdd = memd(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRDF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 6)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = memd(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9bc03800) {
				// 10011011110xxxxxPP111ttiiiiddddd | if (!Pt.new) Rdd = memd(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRDFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 6)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) %s = memd(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9bc02000) {
				// 10011011110xxxxxPP100ttiiiiddddd | if (Pt) Rdd = memd(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRDT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 6)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = memd(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9bc03000) {
				// 10011011110xxxxxPP110ttiiiiddddd | if (Pt.new) Rdd = memd(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRDTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 3; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 3;
				if (hi->ops[3].op.imm & (1 << 6)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) %s = memd(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b402800) {
				// 10011011010xxxxxPP101ttiiiiddddd | if (!Pt) Rd = memh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRHF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				if (hi->ops[3].op.imm & (1 << 4)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = memh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b403800) {
				// 10011011010xxxxxPP111ttiiiiddddd | if (!Pt.new) Rd = memh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRHFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				if (hi->ops[3].op.imm & (1 << 4)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) %s = memh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b402000) {
				// 10011011010xxxxxPP100ttiiiiddddd | if (Pt) Rd = memh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRHT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				if (hi->ops[3].op.imm & (1 << 4)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = memh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b403000) {
				// 10011011010xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRHTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				if (hi->ops[3].op.imm & (1 << 4)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) %s = memh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b802800) {
				// 10011011100xxxxxPP101ttiiiiddddd | if (!Pt) Rd = memw(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRIF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = memw(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b803800) {
				// 10011011100xxxxxPP111ttiiiiddddd | if (!Pt.new) Rd = memw(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRIFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) %s = memw(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b802000) {
				// 10011011100xxxxxPP100ttiiiiddddd | if (Pt) Rd = memw(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRIT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = memw(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b803000) {
				// 10011011100xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memw(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRITNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 2; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 2;
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) %s = memw(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b202800) {
				// 10011011001xxxxxPP101ttiiiiddddd | if (!Pt) Rd = memub(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUBF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = memub(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b203800) {
				// 10011011001xxxxxPP111ttiiiiddddd | if (!Pt.new) Rd = memub(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUBFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) %s = memub(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b202000) {
				// 10011011001xxxxxPP100ttiiiiddddd | if (Pt) Rd = memub(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUBT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = memub(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b203000) {
				// 10011011001xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memub(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUBTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5); // Ii
				if (hi->ops[3].op.imm & (1 << 3)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) %s = memub(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b602800) {
				// 10011011011xxxxxPP101ttiiiiddddd | if (!Pt) Rd = memuh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUHF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				if (hi->ops[3].op.imm & (1 << 4)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s) %s = memuh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b603800) {
				// 10011011011xxxxxPP111ttiiiiddddd | if (!Pt.new) Rd = memuh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUHFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				if (hi->ops[3].op.imm & (1 << 4)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (!%s.new) %s = memuh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b602000) {
				// 10011011011xxxxxPP100ttiiiiddddd | if (Pt) Rd = memuh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUHT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				if (hi->ops[3].op.imm & (1 << 4)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s) %s = memuh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x9b603000) {
				// 10011011011xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memuh(Rx++#Ii)
				hi->instruction = HEX_INS_L2_PLOADRUHTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1e0) >> 5) << 1; // scaled Ii
				hi->ops[3].attr = HEX_OP_IMM_SCALED;
				hi->ops[3].shift = 1;
				if (hi->ops[3].op.imm & (1 << 4)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s if (%s.new) %s = memuh(%s++%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9a801000) {
				// 10011010100eeeeePP01IIII0IIyyyyy | Ryy = memb_fifo(Re=#II)
				hi->instruction = HEX_INS_L4_LOADALIGNB_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memb_fifo(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9c801000) {
				// 10011100100tttttPPi1IIIIiIIyyyyy | Ryy = memb_fifo(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADALIGNB_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memb_fifo(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9a401000) {
				// 10011010010eeeeePP01IIII0IIyyyyy | Ryy = memh_fifo(Re=#II)
				hi->instruction = HEX_INS_L4_LOADALIGNH_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memh_fifo(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9c401000) {
				// 10011100010tttttPPi1IIIIiIIyyyyy | Ryy = memh_fifo(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADALIGNH_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Ryy32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memh_fifo(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9a201000) {
				// 10011010001eeeeePP01IIII0IIddddd | Rd = membh(Re=#II)
				hi->instruction = HEX_INS_L4_LOADBSW2_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = membh(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9c201000) {
				// 10011100001tttttPPi1IIIIiIIddddd | Rd = membh(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADBSW2_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = membh(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9ae01000) {
				// 10011010111eeeeePP01IIII0IIddddd | Rdd = membh(Re=#II)
				hi->instruction = HEX_INS_L4_LOADBSW4_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = membh(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9ce01000) {
				// 10011100111tttttPPi1IIIIiIIddddd | Rdd = membh(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADBSW4_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = membh(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9a601000) {
				// 10011010011eeeeePP01IIII0IIddddd | Rd = memubh(Re=#II)
				hi->instruction = HEX_INS_L4_LOADBZW2_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memubh(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9c601000) {
				// 10011100011tttttPPi1IIIIiIIddddd | Rd = memubh(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADBZW2_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memubh(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9aa01000) {
				// 10011010101eeeeePP01IIII0IIddddd | Rdd = memubh(Re=#II)
				hi->instruction = HEX_INS_L4_LOADBZW4_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memubh(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9ca01000) {
				// 10011100101tttttPPi1IIIIiIIddddd | Rdd = memubh(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADBZW4_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memubh(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x92001800) {
				// 10010010000sssssPP011000000ddddd | Rdd = memd_aq(Rs)
				hi->instruction = HEX_INS_L4_LOADD_AQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = memd_aq(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x92001000) {
				// 10010010000sssssPP010000000ddddd | Rdd = memd_locked(Rs)
				hi->instruction = HEX_INS_L4_LOADD_LOCKED;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = memd_locked(%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9b001000) {
				// 10011011000eeeeePP01IIII0IIddddd | Rd = memb(Re=#II)
				hi->instruction = HEX_INS_L4_LOADRB_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memb(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9d001000) {
				// 10011101000tttttPPi1IIIIiIIddddd | Rd = memb(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADRB_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memb(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9bc01000) {
				// 10011011110eeeeePP01IIII0IIddddd | Rdd = memd(Re=#II)
				hi->instruction = HEX_INS_L4_LOADRD_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memd(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9dc01000) {
				// 10011101110tttttPPi1IIIIiIIddddd | Rdd = memd(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADRD_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memd(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9b401000) {
				// 10011011010eeeeePP01IIII0IIddddd | Rd = memh(Re=#II)
				hi->instruction = HEX_INS_L4_LOADRH_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memh(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9d401000) {
				// 10011101010tttttPPi1IIIIiIIddddd | Rd = memh(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADRH_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memh(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9b801000) {
				// 10011011100eeeeePP01IIII0IIddddd | Rd = memw(Re=#II)
				hi->instruction = HEX_INS_L4_LOADRI_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memw(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9d801000) {
				// 10011101100tttttPPi1IIIIiIIddddd | Rd = memw(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADRI_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memw(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9b201000) {
				// 10011011001eeeeePP01IIII0IIddddd | Rd = memub(Re=#II)
				hi->instruction = HEX_INS_L4_LOADRUB_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memub(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9d201000) {
				// 10011101001tttttPPi1IIIIiIIddddd | Rd = memub(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADRUB_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memub(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03080) == 0x9b601000) {
				// 10011011011eeeeePP01IIII0IIddddd | Rd = memuh(Re=#II)
				hi->instruction = HEX_INS_L4_LOADRUH_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memuh(%s=##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01000) == 0x9d601000) {
				// 10011101011tttttPPi1IIIIiIIddddd | Rd = memuh(Rt<<#Ii+#II)
				hi->instruction = HEX_INS_L4_LOADRUH_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x80) >> 7)); // Ii
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0xf00) >> 6) | (((hi_u32)&0x60) >> 5)); // II
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = memuh(%s<<#0x%x+##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f002880) {
				// 10011111000iiiiiPP101tti100ddddd | if (!Pt) Rd = memb(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRBF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memb(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f003880) {
				// 10011111000iiiiiPP111tti100ddddd | if (!Pt.new) Rd = memb(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRBFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memb(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f002080) {
				// 10011111000iiiiiPP100tti100ddddd | if (Pt) Rd = memb(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRBT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memb(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f003080) {
				// 10011111000iiiiiPP110tti100ddddd | if (Pt.new) Rd = memb(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRBTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memb(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9fc02880) {
				// 10011111110iiiiiPP101tti100ddddd | if (!Pt) Rdd = memd(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRDF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memd(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9fc03880) {
				// 10011111110iiiiiPP111tti100ddddd | if (!Pt.new) Rdd = memd(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRDFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memd(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9fc02080) {
				// 10011111110iiiiiPP100tti100ddddd | if (Pt) Rdd = memd(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRDT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memd(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9fc03080) {
				// 10011111110iiiiiPP110tti100ddddd | if (Pt.new) Rdd = memd(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRDTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memd(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f402880) {
				// 10011111010iiiiiPP101tti100ddddd | if (!Pt) Rd = memh(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRHF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f403880) {
				// 10011111010iiiiiPP111tti100ddddd | if (!Pt.new) Rd = memh(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRHFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f402080) {
				// 10011111010iiiiiPP100tti100ddddd | if (Pt) Rd = memh(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRHT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f403080) {
				// 10011111010iiiiiPP110tti100ddddd | if (Pt.new) Rd = memh(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRHTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f802880) {
				// 10011111100iiiiiPP101tti100ddddd | if (!Pt) Rd = memw(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRIF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memw(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f803880) {
				// 10011111100iiiiiPP111tti100ddddd | if (!Pt.new) Rd = memw(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRIFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memw(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f802080) {
				// 10011111100iiiiiPP100tti100ddddd | if (Pt) Rd = memw(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRIT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memw(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f803080) {
				// 10011111100iiiiiPP110tti100ddddd | if (Pt.new) Rd = memw(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRITNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memw(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f202880) {
				// 10011111001iiiiiPP101tti100ddddd | if (!Pt) Rd = memub(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUBF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memub(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f203880) {
				// 10011111001iiiiiPP111tti100ddddd | if (!Pt.new) Rd = memub(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUBFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memub(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f202080) {
				// 10011111001iiiiiPP100tti100ddddd | if (Pt) Rd = memub(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUBT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memub(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f203080) {
				// 10011111001iiiiiPP110tti100ddddd | if (Pt.new) Rd = memub(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUBTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memub(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f602880) {
				// 10011111011iiiiiPP101tti100ddddd | if (!Pt) Rd = memuh(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUHF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s) %s = memuh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f603880) {
				// 10011111011iiiiiPP111tti100ddddd | if (!Pt.new) Rd = memuh(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUHFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (!%s.new) %s = memuh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f602080) {
				// 10011111011iiiiiPP100tti100ddddd | if (Pt) Rd = memuh(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUHT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s) %s = memuh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038e0) == 0x9f603080) {
				// 10011111011iiiiiPP110tti100ddddd | if (Pt.new) Rd = memuh(#Ii)
				hi->instruction = HEX_INS_L4_PLOADRUHTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x600) >> 9); // Pt4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x100) >> 8)); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s if (%s.new) %s = memuh(##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fe0) == 0x96000000) {
				// 10010110000sssssPP000000000ddddd | Rdd = dealloc_return(Rs):raw
				hi->instruction = HEX_INS_L4_RETURN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = dealloc_return(%s):raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x96003000) {
				// 10010110000sssssPP1100vv000ddddd | if (!Pv) Rdd = dealloc_return(Rs):raw
				hi->instruction = HEX_INS_L4_RETURN_F;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) %s = dealloc_return(%s):raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x96002800) {
				// 10010110000sssssPP1010vv000ddddd | if (!Pv.new) Rdd = dealloc_return(Rs):nt:raw
				hi->instruction = HEX_INS_L4_RETURN_FNEW_PNT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = dealloc_return(%s):nt:raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x96003800) {
				// 10010110000sssssPP1110vv000ddddd | if (!Pv.new) Rdd = dealloc_return(Rs):t:raw
				hi->instruction = HEX_INS_L4_RETURN_FNEW_PT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = dealloc_return(%s):t:raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x96001000) {
				// 10010110000sssssPP0100vv000ddddd | if (Pv) Rdd = dealloc_return(Rs):raw
				hi->instruction = HEX_INS_L4_RETURN_T;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) %s = dealloc_return(%s):raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x96000800) {
				// 10010110000sssssPP0010vv000ddddd | if (Pv.new) Rdd = dealloc_return(Rs):nt:raw
				hi->instruction = HEX_INS_L4_RETURN_TNEW_PNT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = dealloc_return(%s):nt:raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03ce0) == 0x96001800) {
				// 10010110000sssssPP0110vv000ddddd | if (Pv.new) Rdd = dealloc_return(Rs):t:raw
				hi->instruction = HEX_INS_L4_RETURN_TNEW_PT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x300) >> 8); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = dealloc_return(%s):t:raw %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0x92000040) {
				// 10010010000sssssPPuttttt01000000 | memcpy(Rs,Rt,Mu)
				hi->instruction = HEX_INS_L6_MEMCPY;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				sprintf(hi->mnem, "%s memcpy(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_mod_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0x92000020) {
				// 10010010000sssssPP0uuuuu001ddddd | Rd = vextract(Vu,Rs)
				hi->instruction = HEX_INS_V6_EXTRACTW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Vu32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vextract(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_hvx_vr(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0x94000000) {
				// 10010100000sssssPP000iiiiiiiiiii | dcfetch(Rs+#Ii)
				hi->instruction = HEX_INS_Y2_DCFETCHBO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7ff) >> 0) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s dcfetch(%s+#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xa:
			if ((hi_u32 & 0xffe020fc) == 0xa0e0000c) {
				// 10100000111sssssPP0000011 | release(Rs):at
				hi->instruction = HEX_INS_R6_RELEASE_AT_VI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s release(%s):at %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xa0e0002c) {
				// 10100000111sssssPP0001011 | release(Rs):st
				hi->instruction = HEX_INS_R6_RELEASE_ST_VI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s release(%s):st %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03800) == 0xa0800000) {
				// 10100000100xxxxxPP000iiiiiiiiiii | allocframe(Rx,#Ii):raw
				hi->instruction = HEX_INS_S2_ALLOCFRAME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x7ff) >> 0) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				sprintf(hi->mnem, "%s allocframe(%s,#0x%x):raw %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab002004) {
				// 10101011000xxxxxPP1ttttt0iiii1vv | if (!Pv) memb(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERBF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memb(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab002084) {
				// 10101011000xxxxxPP1ttttt1iiii1vv | if (!Pv.new) memb(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERBFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memb(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba02004) {
				// 10101011101xxxxxPP100ttt0iiii1vv | if (!Pv) memb(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERBNEWF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memb(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba02084) {
				// 10101011101xxxxxPP100ttt1iiii1vv | if (!Pv.new) memb(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERBNEWFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memb(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba02000) {
				// 10101011101xxxxxPP100ttt0iiii0vv | if (Pv) memb(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERBNEWT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memb(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba02080) {
				// 10101011101xxxxxPP100ttt1iiii0vv | if (Pv.new) memb(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERBNEWTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memb(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab002000) {
				// 10101011000xxxxxPP1ttttt0iiii0vv | if (Pv) memb(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERBT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memb(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab002080) {
				// 10101011000xxxxxPP1ttttt1iiii0vv | if (Pv.new) memb(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERBTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[2].op.imm & (1 << 3)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memb(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xabc02004) {
				// 10101011110xxxxxPP1ttttt0iiii1vv | if (!Pv) memd(Rx++#Ii) = Rtt
				hi->instruction = HEX_INS_S2_PSTORERDF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (!%s) memd(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xabc02084) {
				// 10101011110xxxxxPP1ttttt1iiii1vv | if (!Pv.new) memd(Rx++#Ii) = Rtt
				hi->instruction = HEX_INS_S2_PSTORERDFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (!%s.new) memd(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xabc02000) {
				// 10101011110xxxxxPP1ttttt0iiii0vv | if (Pv) memd(Rx++#Ii) = Rtt
				hi->instruction = HEX_INS_S2_PSTORERDT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (%s) memd(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xabc02080) {
				// 10101011110xxxxxPP1ttttt1iiii0vv | if (Pv.new) memd(Rx++#Ii) = Rtt
				hi->instruction = HEX_INS_S2_PSTORERDTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 3; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 3;
				if (hi->ops[2].op.imm & (1 << 6)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (%s.new) memd(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab602004) {
				// 10101011011xxxxxPP1ttttt0iiii1vv | if (!Pv) memh(Rx++#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_PSTORERFF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memh(%s++%s) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab602084) {
				// 10101011011xxxxxPP1ttttt1iiii1vv | if (!Pv.new) memh(Rx++#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_PSTORERFFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s++%s) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab602000) {
				// 10101011011xxxxxPP1ttttt0iiii0vv | if (Pv) memh(Rx++#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_PSTORERFT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memh(%s++%s) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab602080) {
				// 10101011011xxxxxPP1ttttt1iiii0vv | if (Pv.new) memh(Rx++#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_PSTORERFTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memh(%s++%s) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab402004) {
				// 10101011010xxxxxPP1ttttt0iiii1vv | if (!Pv) memh(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERHF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memh(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab402084) {
				// 10101011010xxxxxPP1ttttt1iiii1vv | if (!Pv.new) memh(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERHFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba02804) {
				// 10101011101xxxxxPP101ttt0iiii1vv | if (!Pv) memh(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERHNEWF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memh(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba02884) {
				// 10101011101xxxxxPP101ttt1iiii1vv | if (!Pv.new) memh(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERHNEWFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memh(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba02800) {
				// 10101011101xxxxxPP101ttt0iiii0vv | if (Pv) memh(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERHNEWT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memh(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba02880) {
				// 10101011101xxxxxPP101ttt1iiii0vv | if (Pv.new) memh(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERHNEWTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memh(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab402000) {
				// 10101011010xxxxxPP1ttttt0iiii0vv | if (Pv) memh(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERHT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memh(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab402080) {
				// 10101011010xxxxxPP1ttttt1iiii0vv | if (Pv.new) memh(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERHTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 1;
				if (hi->ops[2].op.imm & (1 << 4)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memh(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab802004) {
				// 10101011100xxxxxPP1ttttt0iiii1vv | if (!Pv) memw(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERIF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memw(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab802084) {
				// 10101011100xxxxxPP1ttttt1iiii1vv | if (!Pv.new) memw(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERIFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memw(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba03004) {
				// 10101011101xxxxxPP110ttt0iiii1vv | if (!Pv) memw(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERINEWF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memw(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba03084) {
				// 10101011101xxxxxPP110ttt1iiii1vv | if (!Pv.new) memw(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERINEWFNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memw(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba03000) {
				// 10101011101xxxxxPP110ttt0iiii0vv | if (Pv) memw(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERINEWT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memw(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03884) == 0xaba03080) {
				// 10101011101xxxxxPP110ttt1iiii0vv | if (Pv.new) memw(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_PSTORERINEWTNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memw(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab802000) {
				// 10101011100xxxxxPP1ttttt0iiii0vv | if (Pv) memw(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERIT_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memw(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02084) == 0xab802080) {
				// 10101011100xxxxxPP1ttttt1iiii0vv | if (Pv.new) memw(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_PSTORERITNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memw(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0xa1000000) {
				// 10100ii1000sssssPPitttttiiiiiiii | memb(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERB_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)); // Ii
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xaf000000) {
				// 10101111000xxxxxPPuttttt00000000 | memb(Rx++Mu:brev) = Rt
				hi->instruction = HEX_INS_S2_STORERB_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(%s++%s:brev) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00087) == 0xa9000000) {
				// 10101001000xxxxxPPuttttt0iiii000 | memb(Rx++#Ii:circ(Mu)) = Rt
				hi->instruction = HEX_INS_S2_STORERB_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(%s++%s:circ(%s)) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_mod_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xa9000002) {
				// 10101001000xxxxxPPuttttt00000010 | memb(Rx++I:circ(Mu)) = Rt
				hi->instruction = HEX_INS_S2_STORERB_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(%s++I:circ(%s)) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02087) == 0xab000000) {
				// 10101011000xxxxxPP0ttttt0iiii000 | memb(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERB_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xad000000) {
				// 10101101000xxxxxPPuttttt00000000 | memb(Rx++Mu) = Rt
				hi->instruction = HEX_INS_S2_STORERB_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0xa1a00000) {
				// 10100ii1101sssssPPi00tttiiiiiiii | memb(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERBNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)); // Ii
				if (hi->ops[1].op.imm & (1 << 10)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 10);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(%s+%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xafa00000) {
				// 10101111101xxxxxPPu00ttt00000000 | memb(Rx++Mu:brev) = Nt.new
				hi->instruction = HEX_INS_S2_STORERBNEW_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(%s++%s:brev) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01887) == 0xa9a00000) {
				// 10101001101xxxxxPPu00ttt0iiii000 | memb(Rx++#Ii:circ(Mu)) = Nt.new
				hi->instruction = HEX_INS_S2_STORERBNEW_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(%s++%s:circ(%s)) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_mod_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xa9a00002) {
				// 10101001101xxxxxPPu00ttt00000010 | memb(Rx++I:circ(Mu)) = Nt.new
				hi->instruction = HEX_INS_S2_STORERBNEW_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(%s++I:circ(%s)) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03887) == 0xaba00000) {
				// 10101011101xxxxxPP000ttt0iiii000 | memb(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERBNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3); // Ii
				if (hi->ops[1].op.imm & (1 << 3)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 3);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xada00000) {
				// 10101101101xxxxxPPu00ttt00000000 | memb(Rx++Mu) = Nt.new
				hi->instruction = HEX_INS_S2_STORERBNEW_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0xa1c00000) {
				// 10100ii1110sssssPPitttttiiiiiiii | memd(Rs+#Ii) = Rtt
				hi->instruction = HEX_INS_S2_STORERD_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				if (hi->ops[1].op.imm & (1 << 13)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 13);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xafc00000) {
				// 10101111110xxxxxPPuttttt00000000 | memd(Rx++Mu:brev) = Rtt
				hi->instruction = HEX_INS_S2_STORERD_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(%s++%s:brev) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00087) == 0xa9c00000) {
				// 10101001110xxxxxPPuttttt0iiii000 | memd(Rx++#Ii:circ(Mu)) = Rtt
				hi->instruction = HEX_INS_S2_STORERD_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				if (hi->ops[1].op.imm & (1 << 6)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(%s++%s:circ(%s)) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_mod_regs(hi->ops[2].op.reg), hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xa9c00002) {
				// 10101001110xxxxxPPuttttt00000010 | memd(Rx++I:circ(Mu)) = Rtt
				hi->instruction = HEX_INS_S2_STORERD_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(%s++I:circ(%s)) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02087) == 0xabc00000) {
				// 10101011110xxxxxPP0ttttt0iiii000 | memd(Rx++#Ii) = Rtt
				hi->instruction = HEX_INS_S2_STORERD_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 3; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 3;
				if (hi->ops[1].op.imm & (1 << 6)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 6);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xadc00000) {
				// 10101101110xxxxxPPuttttt00000000 | memd(Rx++Mu) = Rtt
				hi->instruction = HEX_INS_S2_STORERD_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0xa1600000) {
				// 10100ii1011sssssPPitttttiiiiiiii | memh(Rs+#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_STORERF_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 11)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s+%s) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xaf600000) {
				// 10101111011xxxxxPPuttttt00000000 | memh(Rx++Mu:brev) = Rt.h
				hi->instruction = HEX_INS_S2_STORERF_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++%s:brev) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00087) == 0xa9600000) {
				// 10101001011xxxxxPPuttttt0iiii000 | memh(Rx++#Ii:circ(Mu)) = Rt.h
				hi->instruction = HEX_INS_S2_STORERF_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 4)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++%s:circ(%s)) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_mod_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xa9600002) {
				// 10101001011xxxxxPPuttttt00000010 | memh(Rx++I:circ(Mu)) = Rt.h
				hi->instruction = HEX_INS_S2_STORERF_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++I:circ(%s)) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02087) == 0xab600000) {
				// 10101011011xxxxxPP0ttttt0iiii000 | memh(Rx++#Ii) = Rt.h
				hi->instruction = HEX_INS_S2_STORERF_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 4)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++%s) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xad600000) {
				// 10101101011xxxxxPPuttttt00000000 | memh(Rx++Mu) = Rt.h
				hi->instruction = HEX_INS_S2_STORERF_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++%s) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0xa1400000) {
				// 10100ii1010sssssPPitttttiiiiiiii | memh(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERH_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 11)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xaf400000) {
				// 10101111010xxxxxPPuttttt00000000 | memh(Rx++Mu:brev) = Rt
				hi->instruction = HEX_INS_S2_STORERH_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++%s:brev) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00087) == 0xa9400000) {
				// 10101001010xxxxxPPuttttt0iiii000 | memh(Rx++#Ii:circ(Mu)) = Rt
				hi->instruction = HEX_INS_S2_STORERH_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 4)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++%s:circ(%s)) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_mod_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xa9400002) {
				// 10101001010xxxxxPPuttttt00000010 | memh(Rx++I:circ(Mu)) = Rt
				hi->instruction = HEX_INS_S2_STORERH_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++I:circ(%s)) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02087) == 0xab400000) {
				// 10101011010xxxxxPP0ttttt0iiii000 | memh(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERH_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 4)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xad400000) {
				// 10101101010xxxxxPPuttttt00000000 | memh(Rx++Mu) = Rt
				hi->instruction = HEX_INS_S2_STORERH_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0xa1a00800) {
				// 10100ii1101sssssPPi01tttiiiiiiii | memh(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERHNEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 11)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 11);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(%s+%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xafa00800) {
				// 10101111101xxxxxPPu01ttt00000000 | memh(Rx++Mu:brev) = Nt.new
				hi->instruction = HEX_INS_S2_STORERHNEW_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(%s++%s:brev) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01887) == 0xa9a00800) {
				// 10101001101xxxxxPPu01ttt0iiii000 | memh(Rx++#Ii:circ(Mu)) = Nt.new
				hi->instruction = HEX_INS_S2_STORERHNEW_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 4)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(%s++%s:circ(%s)) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_mod_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xa9a00802) {
				// 10101001101xxxxxPPu01ttt00000010 | memh(Rx++I:circ(Mu)) = Nt.new
				hi->instruction = HEX_INS_S2_STORERHNEW_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(%s++I:circ(%s)) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03887) == 0xaba00800) {
				// 10101011101xxxxxPP001ttt0iiii000 | memh(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERHNEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 1; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 1;
				if (hi->ops[1].op.imm & (1 << 4)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 4);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xada00800) {
				// 10101101101xxxxxPPu01ttt00000000 | memh(Rx++Mu) = Nt.new
				hi->instruction = HEX_INS_S2_STORERHNEW_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e00000) == 0xa1800000) {
				// 10100ii1100sssssPPitttttiiiiiiii | memw(Rs+#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERI_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 12)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 12);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(%s+%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xaf800000) {
				// 10101111100xxxxxPPuttttt00000000 | memw(Rx++Mu:brev) = Rt
				hi->instruction = HEX_INS_S2_STORERI_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(%s++%s:brev) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00087) == 0xa9800000) {
				// 10101001100xxxxxPPuttttt0iiii000 | memw(Rx++#Ii:circ(Mu)) = Rt
				hi->instruction = HEX_INS_S2_STORERI_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 5)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(%s++%s:circ(%s)) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_mod_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xa9800002) {
				// 10101001100xxxxxPPuttttt00000010 | memw(Rx++I:circ(Mu)) = Rt
				hi->instruction = HEX_INS_S2_STORERI_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(%s++I:circ(%s)) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02087) == 0xab800000) {
				// 10101011100xxxxxPP0ttttt0iiii000 | memw(Rx++#Ii) = Rt
				hi->instruction = HEX_INS_S2_STORERI_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 5)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000ff) == 0xad800000) {
				// 10101101100xxxxxPPuttttt00000000 | memw(Rx++Mu) = Rt
				hi->instruction = HEX_INS_S2_STORERI_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(%s++%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xf9e01800) == 0xa1a01000) {
				// 10100ii1101sssssPPi10tttiiiiiiii | memw(Rs+#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERINEW_IO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x6000000) >> 16) | (((hi_u32)&0x2000) >> 5) | (((hi_u32)&0xff) >> 0)) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 12)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 12);
				}
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(%s+%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xafa01000) {
				// 10101111101xxxxxPPu10ttt00000000 | memw(Rx++Mu:brev) = Nt.new
				hi->instruction = HEX_INS_S2_STORERINEW_PBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(%s++%s:brev) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01887) == 0xa9a01000) {
				// 10101001101xxxxxPPu10ttt0iiii000 | memw(Rx++#Ii:circ(Mu)) = Nt.new
				hi->instruction = HEX_INS_S2_STORERINEW_PCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 5)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(%s++%s:circ(%s)) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_mod_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xa9a01002) {
				// 10101001101xxxxxPPu10ttt00000010 | memw(Rx++I:circ(Mu)) = Nt.new
				hi->instruction = HEX_INS_S2_STORERINEW_PCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(%s++I:circ(%s)) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03887) == 0xaba01000) {
				// 10101011101xxxxxPP010ttt0iiii000 | memw(Rx++#Ii) = Nt.new
				hi->instruction = HEX_INS_S2_STORERINEW_PI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x78) >> 3) << 2; // scaled Ii
				hi->ops[1].attr = HEX_OP_IMM_SCALED;
				hi->ops[1].shift = 2;
				if (hi->ops[1].op.imm & (1 << 5)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe018ff) == 0xada01000) {
				// 10101101101xxxxxPPu10ttt00000000 | memw(Rx++Mu) = Nt.new
				hi->instruction = HEX_INS_S2_STORERINEW_PR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x2000) >> 13); // Mu2
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(%s++%s) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_mod_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xa0a00000) {
				// 10100000101sssssPP0ttttt000000dd | memw_locked(Rs,Pd) = Rt
				hi->instruction = HEX_INS_S2_STOREW_LOCKED;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw_locked(%s,%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xa0a00008) {
				// 10100000101sssssPP0ttttt000010 | memw_rl(Rs):at = Rt
				hi->instruction = HEX_INS_S2_STOREW_RL_AT_VI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw_rl(%s):at = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xa0a00028) {
				// 10100000101sssssPP0ttttt001010 | memw_rl(Rs):st = Rt
				hi->instruction = HEX_INS_S2_STOREW_RL_ST_VI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw_rl(%s):st = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf000084) {
				// 10101111000000iiPP0ttttt1iiii1vv | if (!Pv) memb(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memb(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf002084) {
				// 10101111000000iiPP1ttttt1iiii1vv | if (!Pv.new) memb(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memb(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa00084) {
				// 10101111101000iiPP000ttt1iiii1vv | if (!Pv) memb(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memb(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa02084) {
				// 10101111101000iiPP100ttt1iiii1vv | if (!Pv.new) memb(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memb(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa00080) {
				// 10101111101000iiPP000ttt1iiii0vv | if (Pv) memb(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memb(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa02080) {
				// 10101111101000iiPP100ttt1iiii0vv | if (Pv.new) memb(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERBNEWTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memb(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf000080) {
				// 10101111000000iiPP0ttttt1iiii0vv | if (Pv) memb(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memb(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf002080) {
				// 10101111000000iiPP1ttttt1iiii0vv | if (Pv.new) memb(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERBTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memb(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xafc00084) {
				// 10101111110000iiPP0ttttt1iiii1vv | if (!Pv) memd(#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (!%s) memd(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xafc02084) {
				// 10101111110000iiPP1ttttt1iiii1vv | if (!Pv.new) memd(#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (!%s.new) memd(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xafc00080) {
				// 10101111110000iiPP0ttttt1iiii0vv | if (Pv) memd(#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (%s) memd(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xafc02080) {
				// 10101111110000iiPP1ttttt1iiii0vv | if (Pv.new) memd(#Ii) = Rtt
				hi->instruction = HEX_INS_S4_PSTORERDTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s if (%s.new) memd(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf600084) {
				// 10101111011000iiPP0ttttt1iiii1vv | if (!Pv) memh(#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memh(##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf602084) {
				// 10101111011000iiPP1ttttt1iiii1vv | if (!Pv.new) memh(#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memh(##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf600080) {
				// 10101111011000iiPP0ttttt1iiii0vv | if (Pv) memh(#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memh(##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf602080) {
				// 10101111011000iiPP1ttttt1iiii0vv | if (Pv.new) memh(#Ii) = Rt.h
				hi->instruction = HEX_INS_S4_PSTORERFTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memh(##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf400084) {
				// 10101111010000iiPP0ttttt1iiii1vv | if (!Pv) memh(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memh(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf402084) {
				// 10101111010000iiPP1ttttt1iiii1vv | if (!Pv.new) memh(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memh(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa00884) {
				// 10101111101000iiPP001ttt1iiii1vv | if (!Pv) memh(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memh(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa02884) {
				// 10101111101000iiPP101ttt1iiii1vv | if (!Pv.new) memh(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memh(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa00880) {
				// 10101111101000iiPP001ttt1iiii0vv | if (Pv) memh(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memh(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa02880) {
				// 10101111101000iiPP101ttt1iiii0vv | if (Pv.new) memh(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERHNEWTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memh(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf400080) {
				// 10101111010000iiPP0ttttt1iiii0vv | if (Pv) memh(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memh(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf402080) {
				// 10101111010000iiPP1ttttt1iiii0vv | if (Pv.new) memh(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERHTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memh(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf800084) {
				// 10101111100000iiPP0ttttt1iiii1vv | if (!Pv) memw(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERIF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) memw(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf802084) {
				// 10101111100000iiPP1ttttt1iiii1vv | if (!Pv.new) memw(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERIFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) memw(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa01084) {
				// 10101111101000iiPP010ttt1iiii1vv | if (!Pv) memw(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWF_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s) memw(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa03084) {
				// 10101111101000iiPP110ttt1iiii1vv | if (!Pv.new) memw(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWFNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (!%s.new) memw(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa01080) {
				// 10101111101000iiPP010ttt1iiii0vv | if (Pv) memw(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s) memw(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc3884) == 0xafa03080) {
				// 10101111101000iiPP110ttt1iiii0vv | if (Pv.new) memw(#Ii) = Nt.new
				hi->instruction = HEX_INS_S4_PSTORERINEWTNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s if (%s.new) memw(##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf800080) {
				// 10101111100000iiPP0ttttt1iiii0vv | if (Pv) memw(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERIT_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) memw(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xfffc2084) == 0xaf802080) {
				// 10101111100000iiPP1ttttt1iiii0vv | if (Pv.new) memw(#Ii) = Rt
				hi->instruction = HEX_INS_S4_PSTORERITNEW_ABS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pv4
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x30000) >> 12) | (((hi_u32)&0x78) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) memw(##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xa0e00000) {
				// 10100000111sssssPP0ttttt000000dd | memd_locked(Rs,Pd) = Rtt
				hi->instruction = HEX_INS_S4_STORED_LOCKED;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd_locked(%s,%s) = %s %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xa0e00008) {
				// 10100000111sssssPP0ttttt000010 | memd_rl(Rs):at = Rtt
				hi->instruction = HEX_INS_S4_STORED_RL_AT_VI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd_rl(%s):at = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xa0e00028) {
				// 10100000111sssssPP0ttttt001010 | memd_rl(Rs):st = Rtt
				hi->instruction = HEX_INS_S4_STORED_RL_ST_VI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd_rl(%s):st = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0xab000080) {
				// 10101011000eeeeePP0ttttt10IIIIII | memb(Re=#II) = Rt
				hi->instruction = HEX_INS_S4_STORERB_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(%s=##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00080) == 0xad000080) {
				// 10101101000uuuuuPPittttt1iIIIIII | memb(Ru<<#Ii+#II) = Rt
				hi->instruction = HEX_INS_S4_STORERB_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Ru32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x40) >> 6)); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memb(%s<<#0x%x+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038c0) == 0xaba00080) {
				// 10101011101eeeeePP000ttt10IIIIII | memb(Re=#II) = Nt.new
				hi->instruction = HEX_INS_S4_STORERBNEW_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(%s=##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01880) == 0xada00080) {
				// 10101101101uuuuuPPi00ttt1iIIIIII | memb(Ru<<#Ii+#II) = Nt.new
				hi->instruction = HEX_INS_S4_STORERBNEW_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Ru32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x40) >> 6)); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memb(%s<<#0x%x+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0xabc00080) {
				// 10101011110eeeeePP0ttttt10IIIIII | memd(Re=#II) = Rtt
				hi->instruction = HEX_INS_S4_STORERD_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(%s=##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00080) == 0xadc00080) {
				// 10101101110uuuuuPPittttt1iIIIIII | memd(Ru<<#Ii+#II) = Rtt
				hi->instruction = HEX_INS_S4_STORERD_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Ru32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x40) >> 6)); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s memd(%s<<#0x%x+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0xab600080) {
				// 10101011011eeeeePP0ttttt10IIIIII | memh(Re=#II) = Rt.h
				hi->instruction = HEX_INS_S4_STORERF_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s=##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00080) == 0xad600080) {
				// 10101101011uuuuuPPittttt1iIIIIII | memh(Ru<<#Ii+#II) = Rt.h
				hi->instruction = HEX_INS_S4_STORERF_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Ru32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x40) >> 6)); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s<<#0x%x+##0x%x) = %s.h %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0xab400080) {
				// 10101011010eeeeePP0ttttt10IIIIII | memh(Re=#II) = Rt
				hi->instruction = HEX_INS_S4_STORERH_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s=##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00080) == 0xad400080) {
				// 10101101010uuuuuPPittttt1iIIIIII | memh(Ru<<#Ii+#II) = Rt
				hi->instruction = HEX_INS_S4_STORERH_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Ru32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x40) >> 6)); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memh(%s<<#0x%x+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038c0) == 0xaba00880) {
				// 10101011101eeeeePP001ttt10IIIIII | memh(Re=#II) = Nt.new
				hi->instruction = HEX_INS_S4_STORERHNEW_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(%s=##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01880) == 0xada00880) {
				// 10101101101uuuuuPPi01ttt1iIIIIII | memh(Ru<<#Ii+#II) = Nt.new
				hi->instruction = HEX_INS_S4_STORERHNEW_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Ru32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x40) >> 6)); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memh(%s<<#0x%x+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0xab800080) {
				// 10101011100eeeeePP0ttttt10IIIIII | memw(Re=#II) = Rt
				hi->instruction = HEX_INS_S4_STORERI_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(%s=##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe00080) == 0xad800080) {
				// 10101101100uuuuuPPittttt1iIIIIII | memw(Ru<<#Ii+#II) = Rt
				hi->instruction = HEX_INS_S4_STORERI_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Ru32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x40) >> 6)); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s memw(%s<<#0x%x+##0x%x) = %s %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe038c0) == 0xaba01080) {
				// 10101011101eeeeePP010ttt10IIIIII | memw(Re=#II) = Nt.new
				hi->instruction = HEX_INS_S4_STORERINEW_AP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Re32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(%s=##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe01880) == 0xada01080) {
				// 10101101101uuuuuPPi10ttt1iIIIIII | memw(Ru<<#Ii+#II) = Nt.new
				hi->instruction = HEX_INS_S4_STORERINEW_UR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Ru32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x40) >> 6)); // Ii
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3f) >> 0); // II
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x700) >> 8); // Nt8
				sprintf(hi->mnem, "%s memw(%s<<#0x%x+##0x%x) = %s.new %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0xa8000000) {
				// 1010100000000000PP00000000000000 | barrier
				hi->instruction = HEX_INS_Y2_BARRIER;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s barrier %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0xa0000000) {
				// 10100000000sssssPP00000000000000 | dccleana(Rs)
				hi->instruction = HEX_INS_Y2_DCCLEANA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s dccleana(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0xa0400000) {
				// 10100000010sssssPP00000000000000 | dccleaninva(Rs)
				hi->instruction = HEX_INS_Y2_DCCLEANINVA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s dccleaninva(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0xa0200000) {
				// 10100000001sssssPP00000000000000 | dcinva(Rs)
				hi->instruction = HEX_INS_Y2_DCINVA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s dcinva(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0xa0c00000) {
				// 10100000110sssssPP00000000000000 | dczeroa(Rs)
				hi->instruction = HEX_INS_Y2_DCZEROA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s dczeroa(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fff) == 0xa8400000) {
				// 1010100001000000PP00000000000000 | syncht
				hi->instruction = HEX_INS_Y2_SYNCHT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 0;
				sprintf(hi->mnem, "%s syncht %s", hi->pkt_info.syntax_prefix, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020ff) == 0xa6000000) {
				// 10100110000sssssPP0ttttt00000000 | l2fetch(Rs,Rt)
				hi->instruction = HEX_INS_Y4_L2FETCH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s l2fetch(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020ff) == 0xa6800000) {
				// 10100110100sssssPP0ttttt00000000 | l2fetch(Rs,Rtt)
				hi->instruction = HEX_INS_Y5_L2FETCH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s l2fetch(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020ff) == 0xa6000040) {
				// 10100110000sssssPP0ttttt01000000 | dmlink(Rs,Rt)
				hi->instruction = HEX_INS_Y6_DMLINK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s dmlink(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fe0) == 0xa8000060) {
				// 1010100000000000PP000000011ddddd | Rd = dmpause
				hi->instruction = HEX_INS_Y6_DMPAUSE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				sprintf(hi->mnem, "%s %s = dmpause %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fe0) == 0xa8000040) {
				// 1010100000000000PP000000010ddddd | Rd = dmpoll
				hi->instruction = HEX_INS_Y6_DMPOLL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				sprintf(hi->mnem, "%s %s = dmpoll %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0xa6000080) {
				// 10100110000sssssPP00000010000000 | dmresume(Rs)
				hi->instruction = HEX_INS_Y6_DMRESUME;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s dmresume(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03fff) == 0xa6000020) {
				// 10100110000sssssPP00000000100000 | dmstart(Rs)
				hi->instruction = HEX_INS_Y6_DMSTART;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s dmstart(%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffff3fe0) == 0xa8000020) {
				// 1010100000000000PP000000001ddddd | Rd = dmwait
				hi->instruction = HEX_INS_Y6_DMWAIT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				sprintf(hi->mnem, "%s %s = dmwait %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xb:
			if ((hi_u32 & 0xf0000000) == 0xb0000000) {
				// 1011iiiiiiisssssPPiiiiiiiiiddddd | Rd = add(Rs,#Ii)
				hi->instruction = HEX_INS_A2_ADDI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0xfe00000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 15)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 15);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xc:
			if ((hi_u32 & 0xffe02080) == 0xc2c00000) {
				// 11000010110sssssPP0ttttt0xxddddd | Rdd = add(Rss,Rtt,Px):carry
				hi->instruction = HEX_INS_A4_ADDP_C;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x60) >> 5); // Px4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = add(%s,%s,%s):carry %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7c000c0) {
				// 11000111110sssssPP0ttttt110000dd | Pd = cmpb.eq(Rs,Rt)
				hi->instruction = HEX_INS_A4_CMPBEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpb.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7c00040) {
				// 11000111110sssssPP0ttttt010000dd | Pd = cmpb.gt(Rs,Rt)
				hi->instruction = HEX_INS_A4_CMPBGT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpb.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7c000e0) {
				// 11000111110sssssPP0ttttt111000dd | Pd = cmpb.gtu(Rs,Rt)
				hi->instruction = HEX_INS_A4_CMPBGTU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpb.gtu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7c00060) {
				// 11000111110sssssPP0ttttt011000dd | Pd = cmph.eq(Rs,Rt)
				hi->instruction = HEX_INS_A4_CMPHEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmph.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7c00080) {
				// 11000111110sssssPP0ttttt100000dd | Pd = cmph.gt(Rs,Rt)
				hi->instruction = HEX_INS_A4_CMPHGT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmph.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7c000a0) {
				// 11000111110sssssPP0ttttt101000dd | Pd = cmph.gtu(Rs,Rt)
				hi->instruction = HEX_INS_A4_CMPHGTU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmph.gtu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6c00000) {
				// 11000110110sssssPP0ttttt000ddddd | Rd = cround(Rs,Rt)
				hi->instruction = HEX_INS_A4_CROUND_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cround(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6c00080) {
				// 11000110110sssssPP0ttttt100ddddd | Rd = round(Rs,Rt)
				hi->instruction = HEX_INS_A4_ROUND_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = round(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6c000c0) {
				// 11000110110sssssPP0ttttt110ddddd | Rd = round(Rs,Rt):sat
				hi->instruction = HEX_INS_A4_ROUND_RR_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = round(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xc2e00000) {
				// 11000010111sssssPP0ttttt0xxddddd | Rdd = sub(Rss,Rtt,Px):carry
				hi->instruction = HEX_INS_A4_SUBP_C;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x60) >> 5); // Px4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = sub(%s,%s,%s):carry %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb200020) {
				// 11001011001sssssPP0xxxxx001uuuuu | Rxx = vrmaxh(Rss,Ru)
				hi->instruction = HEX_INS_A4_VRMAXH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = vrmaxh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb202020) {
				// 11001011001sssssPP1xxxxx001uuuuu | Rxx = vrmaxuh(Rss,Ru)
				hi->instruction = HEX_INS_A4_VRMAXUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = vrmaxuh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb202040) {
				// 11001011001sssssPP1xxxxx010uuuuu | Rxx = vrmaxuw(Rss,Ru)
				hi->instruction = HEX_INS_A4_VRMAXUW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = vrmaxuw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb200040) {
				// 11001011001sssssPP0xxxxx010uuuuu | Rxx = vrmaxw(Rss,Ru)
				hi->instruction = HEX_INS_A4_VRMAXW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = vrmaxw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb2000a0) {
				// 11001011001sssssPP0xxxxx101uuuuu | Rxx = vrminh(Rss,Ru)
				hi->instruction = HEX_INS_A4_VRMINH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = vrminh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb2020a0) {
				// 11001011001sssssPP1xxxxx101uuuuu | Rxx = vrminuh(Rss,Ru)
				hi->instruction = HEX_INS_A4_VRMINUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = vrminuh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb2020c0) {
				// 11001011001sssssPP1xxxxx110uuuuu | Rxx = vrminuw(Rss,Ru)
				hi->instruction = HEX_INS_A4_VRMINUW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = vrminuw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb2000c0) {
				// 11001011001sssssPP0xxxxx110uuuuu | Rxx = vrminw(Rss,Ru)
				hi->instruction = HEX_INS_A4_VRMINW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = vrminw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1400020) {
				// 11000001010sssssPP0ttttt001ddddd | Rd = vaddhub(Rss,Rtt):sat
				hi->instruction = HEX_INS_A5_VADDHUBS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vaddhub(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6c00040) {
				// 11000110110sssssPP0ttttt010ddddd | Rdd = cround(Rss,Rt)
				hi->instruction = HEX_INS_A7_CROUNDD_RR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cround(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7800000) {
				// 11000111100sssssPP0ttttt000000dd | Pd = bitsclr(Rs,Rt)
				hi->instruction = HEX_INS_C2_BITSCLR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = bitsclr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7400000) {
				// 11000111010sssssPP0ttttt000000dd | Pd = bitsset(Rs,Rt)
				hi->instruction = HEX_INS_C2_BITSSET;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = bitsset(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7a00000) {
				// 11000111101sssssPP0ttttt000000dd | Pd = !bitsclr(Rs,Rt)
				hi->instruction = HEX_INS_C4_NBITSCLR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = !bitsclr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7600000) {
				// 11000111011sssssPP0ttttt000000dd | Pd = !bitsset(Rs,Rt)
				hi->instruction = HEX_INS_C4_NBITSSET;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = !bitsset(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7e00060) {
				// 11000111111sssssPP0ttttt011000dd | Pd = sfcmp.eq(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFCMPEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfcmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7e00000) {
				// 11000111111sssssPP0ttttt000000dd | Pd = sfcmp.ge(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFCMPGE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfcmp.ge(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7e00080) {
				// 11000111111sssssPP0ttttt100000dd | Pd = sfcmp.gt(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFCMPGT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfcmp.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7e00020) {
				// 11000111111sssssPP0ttttt001000dd | Pd = sfcmp.uo(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFCMPUO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfcmp.uo(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc5000080) {
				// 11000101000sssssPP0ttttt100ddddd | Rd = cmpyiwh(Rss,Rt):<<1:rnd:sat
				hi->instruction = HEX_INS_M4_CMPYI_WH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpyiwh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc50000a0) {
				// 11000101000sssssPP0ttttt101ddddd | Rd = cmpyiwh(Rss,Rt*):<<1:rnd:sat
				hi->instruction = HEX_INS_M4_CMPYI_WHC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpyiwh(%s,%s*):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc50000c0) {
				// 11000101000sssssPP0ttttt110ddddd | Rd = cmpyrwh(Rss,Rt):<<1:rnd:sat
				hi->instruction = HEX_INS_M4_CMPYR_WH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpyrwh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc50000e0) {
				// 11000101000sssssPP0ttttt111ddddd | Rd = cmpyrwh(Rss,Rt*):<<1:rnd:sat
				hi->instruction = HEX_INS_M4_CMPYR_WHC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpyrwh(%s,%s*):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xca800000) {
				// 11001010100sssssPP0ttttt000xxxxx | Rxx ^= xor(Rss,Rtt)
				hi->instruction = HEX_INS_M4_XOR_XACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s ^= xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xc4000000) {
				// 11000100000sssssPP0tttttiiiddddd | Rd = addasl(Rt,Rs,#Ii)
				hi->instruction = HEX_INS_S2_ADDASL_RRRI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = addasl(%s,%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3800080) {
				// 11000011100sssssPP0ttttt100ddddd | Rdd = asl(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcbc00080) {
				// 11001011110sssssPP0ttttt100xxxxx | Rxx += asl(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_P_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb400080) {
				// 11001011010sssssPP0ttttt100xxxxx | Rxx &= asl(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_P_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb800080) {
				// 11001011100sssssPP0ttttt100xxxxx | Rxx -= asl(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_P_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb000080) {
				// 11001011000sssssPP0ttttt100xxxxx | Rxx |= asl(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_P_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb600080) {
				// 11001011011sssssPP0ttttt100xxxxx | Rxx ^= asl(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_P_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6400080) {
				// 11000110010sssssPP0ttttt100ddddd | Rd = asl(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xccc00080) {
				// 11001100110sssssPP0ttttt100xxxxx | Rx += asl(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_R_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc400080) {
				// 11001100010sssssPP0ttttt100xxxxx | Rx &= asl(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_R_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc800080) {
				// 11001100100sssssPP0ttttt100xxxxx | Rx -= asl(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_R_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc000080) {
				// 11001100000sssssPP0ttttt100xxxxx | Rx |= asl(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_R_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= asl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6000080) {
				// 11000110000sssssPP0ttttt100ddddd | Rd = asl(Rs,Rt):sat
				hi->instruction = HEX_INS_S2_ASL_R_R_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = asl(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3400080) {
				// 11000011010sssssPP0ttttt100ddddd | Rdd = vaslh(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_VH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vaslh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3000080) {
				// 11000011000sssssPP0ttttt100ddddd | Rdd = vaslw(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASL_R_VW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vaslw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3800000) {
				// 11000011100sssssPP0ttttt000ddddd | Rdd = asr(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcbc00000) {
				// 11001011110sssssPP0ttttt000xxxxx | Rxx += asr(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_P_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb400000) {
				// 11001011010sssssPP0ttttt000xxxxx | Rxx &= asr(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_P_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb800000) {
				// 11001011100sssssPP0ttttt000xxxxx | Rxx -= asr(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_P_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb000000) {
				// 11001011000sssssPP0ttttt000xxxxx | Rxx |= asr(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_P_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb600000) {
				// 11001011011sssssPP0ttttt000xxxxx | Rxx ^= asr(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_P_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6400000) {
				// 11000110010sssssPP0ttttt000ddddd | Rd = asr(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xccc00000) {
				// 11001100110sssssPP0ttttt000xxxxx | Rx += asr(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_R_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc400000) {
				// 11001100010sssssPP0ttttt000xxxxx | Rx &= asr(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_R_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc800000) {
				// 11001100100sssssPP0ttttt000xxxxx | Rx -= asr(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_R_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc000000) {
				// 11001100000sssssPP0ttttt000xxxxx | Rx |= asr(Rs,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_R_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= asr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6000000) {
				// 11000110000sssssPP0ttttt000ddddd | Rd = asr(Rs,Rt):sat
				hi->instruction = HEX_INS_S2_ASR_R_R_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = asr(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc5000040) {
				// 11000101000sssssPP0ttttt010ddddd | Rd = vasrw(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_SVW_TRUN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vasrw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3400000) {
				// 11000011010sssssPP0ttttt000ddddd | Rdd = vasrh(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_VH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vasrh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3000000) {
				// 11000011000sssssPP0ttttt000ddddd | Rdd = vasrw(Rss,Rt)
				hi->instruction = HEX_INS_S2_ASR_R_VW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vasrw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1c000c0) {
				// 11000001110sssssPP0ttttt110ddddd | Rdd = decbin(Rss,Rtt)
				hi->instruction = HEX_INS_S2_CABACDECBIN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = decbin(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6800040) {
				// 11000110100sssssPP0ttttt010ddddd | Rd = clrbit(Rs,Rt)
				hi->instruction = HEX_INS_S2_CLRBIT_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = clrbit(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc9000000) {
				// 11001001000sssssPP0ttttt000ddddd | Rd = extractu(Rs,Rtt)
				hi->instruction = HEX_INS_S2_EXTRACTU_RP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = extractu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1000000) {
				// 11000001000sssssPP0ttttt000ddddd | Rdd = extractu(Rss,Rtt)
				hi->instruction = HEX_INS_S2_EXTRACTUP_RP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = extractu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc8000000) {
				// 11001000000sssssPP0ttttt000xxxxx | Rx = insert(Rs,Rtt)
				hi->instruction = HEX_INS_S2_INSERT_RP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = insert(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xca000000) {
				// 11001010000sssssPP0ttttt000xxxxx | Rxx = insert(Rss,Rtt)
				hi->instruction = HEX_INS_S2_INSERTP_RP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = insert(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc18000c0) {
				// 11000001100sssssPP0ttttt110ddddd | Rdd = lfs(Rss,Rtt)
				hi->instruction = HEX_INS_S2_LFSP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = lfs(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc38000c0) {
				// 11000011100sssssPP0ttttt110ddddd | Rdd = lsl(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcbc000c0) {
				// 11001011110sssssPP0ttttt110xxxxx | Rxx += lsl(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_P_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb4000c0) {
				// 11001011010sssssPP0ttttt110xxxxx | Rxx &= lsl(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_P_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb8000c0) {
				// 11001011100sssssPP0ttttt110xxxxx | Rxx -= lsl(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_P_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb0000c0) {
				// 11001011000sssssPP0ttttt110xxxxx | Rxx |= lsl(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_P_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb6000c0) {
				// 11001011011sssssPP0ttttt110xxxxx | Rxx ^= lsl(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_P_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc64000c0) {
				// 11000110010sssssPP0ttttt110ddddd | Rd = lsl(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xccc000c0) {
				// 11001100110sssssPP0ttttt110xxxxx | Rx += lsl(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_R_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc4000c0) {
				// 11001100010sssssPP0ttttt110xxxxx | Rx &= lsl(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_R_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc8000c0) {
				// 11001100100sssssPP0ttttt110xxxxx | Rx -= lsl(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_R_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc0000c0) {
				// 11001100000sssssPP0ttttt110xxxxx | Rx |= lsl(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_R_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc34000c0) {
				// 11000011010sssssPP0ttttt110ddddd | Rdd = vlslh(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_VH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vlslh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc30000c0) {
				// 11000011000sssssPP0ttttt110ddddd | Rdd = vlslw(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSL_R_VW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vlslw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3800040) {
				// 11000011100sssssPP0ttttt010ddddd | Rdd = lsr(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcbc00040) {
				// 11001011110sssssPP0ttttt010xxxxx | Rxx += lsr(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_P_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb400040) {
				// 11001011010sssssPP0ttttt010xxxxx | Rxx &= lsr(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_P_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb800040) {
				// 11001011100sssssPP0ttttt010xxxxx | Rxx -= lsr(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_P_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb000040) {
				// 11001011000sssssPP0ttttt010xxxxx | Rxx |= lsr(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_P_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb600040) {
				// 11001011011sssssPP0ttttt010xxxxx | Rxx ^= lsr(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_P_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6400040) {
				// 11000110010sssssPP0ttttt010ddddd | Rd = lsr(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xccc00040) {
				// 11001100110sssssPP0ttttt010xxxxx | Rx += lsr(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_R_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc400040) {
				// 11001100010sssssPP0ttttt010xxxxx | Rx &= lsr(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_R_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc800040) {
				// 11001100100sssssPP0ttttt010xxxxx | Rx -= lsr(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_R_NAC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcc000040) {
				// 11001100000sssssPP0ttttt010xxxxx | Rx |= lsr(Rs,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_R_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= lsr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3400040) {
				// 11000011010sssssPP0ttttt010ddddd | Rdd = vlsrh(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_VH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vlsrh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3000040) {
				// 11000011000sssssPP0ttttt010ddddd | Rdd = vlsrw(Rss,Rt)
				hi->instruction = HEX_INS_S2_LSR_R_VW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vlsrw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6800000) {
				// 11000110100sssssPP0ttttt000ddddd | Rd = setbit(Rs,Rt)
				hi->instruction = HEX_INS_S2_SETBIT_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = setbit(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1000040) {
				// 11000001000sssssPP0ttttt010ddddd | Rdd = shuffeb(Rss,Rtt)
				hi->instruction = HEX_INS_S2_SHUFFEB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = shuffeb(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc10000c0) {
				// 11000001000sssssPP0ttttt110ddddd | Rdd = shuffeh(Rss,Rtt)
				hi->instruction = HEX_INS_S2_SHUFFEH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = shuffeh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1000080) {
				// 11000001000sssssPP0ttttt100ddddd | Rdd = shuffob(Rtt,Rss)
				hi->instruction = HEX_INS_S2_SHUFFOB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = shuffob(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1800000) {
				// 11000001100sssssPP0ttttt000ddddd | Rdd = shuffoh(Rtt,Rss)
				hi->instruction = HEX_INS_S2_SHUFFOH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = shuffoh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc6800080) {
				// 11000110100sssssPP0ttttt100ddddd | Rd = togglebit(Rs,Rt)
				hi->instruction = HEX_INS_S2_TOGGLEBIT_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = togglebit(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7000000) {
				// 11000111000sssssPP0ttttt000000dd | Pd = tstbit(Rs,Rt)
				hi->instruction = HEX_INS_S2_TSTBIT_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = tstbit(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xc0000000) {
				// 11000000000sssssPP0tttttiiiddddd | Rdd = valignb(Rtt,Rss,#Ii)
				hi->instruction = HEX_INS_S2_VALIGNIB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = valignb(%s,%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xc2000000) {
				// 11000010000sssssPP0ttttt0uuddddd | Rdd = valignb(Rtt,Rss,Pu)
				hi->instruction = HEX_INS_S2_VALIGNRB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				sprintf(hi->mnem, "%s %s = valignb(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3c00040) {
				// 11000011110sssssPP0ttttt010ddddd | Rdd = vcnegh(Rss,Rt)
				hi->instruction = HEX_INS_S2_VCNEGH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vcnegh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc3c00000) {
				// 11000011110sssssPP0ttttt000ddddd | Rdd = vcrotate(Rss,Rt)
				hi->instruction = HEX_INS_S2_VCROTATE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vcrotate(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xcb2020e0) {
				// 11001011001sssssPP1ttttt111xxxxx | Rxx += vrcnegh(Rss,Rt)
				hi->instruction = HEX_INS_S2_VRCNEGH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += vrcnegh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xc0800000) {
				// 11000000100sssssPP0tttttiiiddddd | Rdd = vspliceb(Rss,Rtt,#Ii)
				hi->instruction = HEX_INS_S2_VSPLICEIB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0xe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = vspliceb(%s,%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xc2800000) {
				// 11000010100sssssPP0ttttt0uuddddd | Rdd = vspliceb(Rss,Rtt,Pu)
				hi->instruction = HEX_INS_S2_VSPLICERB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				sprintf(hi->mnem, "%s %s = vspliceb(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1800040) {
				// 11000001100sssssPP0ttttt010ddddd | Rdd = vtrunewh(Rss,Rtt)
				hi->instruction = HEX_INS_S2_VTRUNEWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vtrunewh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1800080) {
				// 11000001100sssssPP0ttttt100ddddd | Rdd = vtrunowh(Rss,Rtt)
				hi->instruction = HEX_INS_S2_VTRUNOWH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vtrunowh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc9000040) {
				// 11001001000sssssPP0ttttt010ddddd | Rd = extract(Rs,Rtt)
				hi->instruction = HEX_INS_S4_EXTRACT_RP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = extract(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1c00080) {
				// 11000001110sssssPP0ttttt100ddddd | Rdd = extract(Rss,Rtt)
				hi->instruction = HEX_INS_S4_EXTRACTP_RP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = extract(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020c0) == 0xc68000c0) {
				// 11000110100iiiiiPP0ttttt11iddddd | Rd = lsl(#Ii,Rt)
				hi->instruction = HEX_INS_S4_LSLI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x1f0000) >> 15) | (((hi_u32)&0x20) >> 5)); // Ii
				if (hi->ops[1].op.imm & (1 << 5)) { // signed
					hi->ops[1].op.imm |= (0xffffffff << 5);
				}
				if (((st32)hi->ops[1].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[1].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[1].op.imm);
				}
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = lsl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), signed_imm, hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xc7200000) {
				// 11000111001sssssPP0ttttt000000dd | Pd = !tstbit(Rs,Rt)
				hi->instruction = HEX_INS_S4_NTSTBIT_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = !tstbit(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000c0) == 0xc3c000c0) {
				// 11000011110sssssPPittttt11iddddd | Rdd = vrcrotate(Rss,Rt,#Ii)
				hi->instruction = HEX_INS_S4_VRCROTATE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x20) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = vrcrotate(%s,%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe000c0) == 0xcba00000) {
				// 11001011101sssssPPittttt00ixxxxx | Rxx += vrcrotate(Rss,Rt,#Ii)
				hi->instruction = HEX_INS_S4_VRCROTATE_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x2000) >> 12) | (((hi_u32)&0x20) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s += vrcrotate(%s,%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1400080) {
				// 11000001010sssssPP0ttttt100ddddd | Rdd = vxaddsubh(Rss,Rtt):sat
				hi->instruction = HEX_INS_S4_VXADDSUBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vxaddsubh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1c00000) {
				// 11000001110sssssPP0ttttt000ddddd | Rdd = vxaddsubh(Rss,Rtt):rnd:>>1:sat
				hi->instruction = HEX_INS_S4_VXADDSUBHR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vxaddsubh(%s,%s):rnd:>>1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1400000) {
				// 11000001010sssssPP0ttttt000ddddd | Rdd = vxaddsubw(Rss,Rtt):sat
				hi->instruction = HEX_INS_S4_VXADDSUBW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vxaddsubw(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc14000c0) {
				// 11000001010sssssPP0ttttt110ddddd | Rdd = vxsubaddh(Rss,Rtt):sat
				hi->instruction = HEX_INS_S4_VXSUBADDH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vxsubaddh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1c00040) {
				// 11000001110sssssPP0ttttt010ddddd | Rdd = vxsubaddh(Rss,Rtt):rnd:>>1:sat
				hi->instruction = HEX_INS_S4_VXSUBADDHR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vxsubaddh(%s,%s):rnd:>>1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1400040) {
				// 11000001010sssssPP0ttttt010ddddd | Rdd = vxsubaddw(Rss,Rtt):sat
				hi->instruction = HEX_INS_S4_VXSUBADDW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vxsubaddw(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc1800060) {
				// 11000001100sssssPP0ttttt011ddddd | Rdd = vtrunehb(Rss,Rtt)
				hi->instruction = HEX_INS_S6_VTRUNEHB_PPP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vtrunehb(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xc18000a0) {
				// 11000001100sssssPP0ttttt101ddddd | Rdd = vtrunohb(Rss,Rtt)
				hi->instruction = HEX_INS_S6_VTRUNOHB_PPP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vtrunohb(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xd:
			if ((hi_u32 & 0xffe020e0) == 0xd5400060) {
				// 11010101010sssssPP0ttttt011ddddd | Rd = add(Rt.h,Rs.h):<<16
				hi->instruction = HEX_INS_A2_ADDH_H16_HH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.h,%s.h):<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5400040) {
				// 11010101010sssssPP0ttttt010ddddd | Rd = add(Rt.h,Rs.l):<<16
				hi->instruction = HEX_INS_A2_ADDH_H16_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.h,%s.l):<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5400020) {
				// 11010101010sssssPP0ttttt001ddddd | Rd = add(Rt.l,Rs.h):<<16
				hi->instruction = HEX_INS_A2_ADDH_H16_LH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.l,%s.h):<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5400000) {
				// 11010101010sssssPP0ttttt000ddddd | Rd = add(Rt.l,Rs.l):<<16
				hi->instruction = HEX_INS_A2_ADDH_H16_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.l,%s.l):<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd54000e0) {
				// 11010101010sssssPP0ttttt111ddddd | Rd = add(Rt.h,Rs.h):sat:<<16
				hi->instruction = HEX_INS_A2_ADDH_H16_SAT_HH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.h,%s.h):sat:<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd54000c0) {
				// 11010101010sssssPP0ttttt110ddddd | Rd = add(Rt.h,Rs.l):sat:<<16
				hi->instruction = HEX_INS_A2_ADDH_H16_SAT_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.h,%s.l):sat:<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd54000a0) {
				// 11010101010sssssPP0ttttt101ddddd | Rd = add(Rt.l,Rs.h):sat:<<16
				hi->instruction = HEX_INS_A2_ADDH_H16_SAT_LH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.l,%s.h):sat:<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5400080) {
				// 11010101010sssssPP0ttttt100ddddd | Rd = add(Rt.l,Rs.l):sat:<<16
				hi->instruction = HEX_INS_A2_ADDH_H16_SAT_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.l,%s.l):sat:<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5000040) {
				// 11010101000sssssPP0ttttt010ddddd | Rd = add(Rt.l,Rs.h)
				hi->instruction = HEX_INS_A2_ADDH_L16_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5000000) {
				// 11010101000sssssPP0ttttt000ddddd | Rd = add(Rt.l,Rs.l)
				hi->instruction = HEX_INS_A2_ADDH_L16_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd50000c0) {
				// 11010101000sssssPP0ttttt110ddddd | Rd = add(Rt.l,Rs.h):sat
				hi->instruction = HEX_INS_A2_ADDH_L16_SAT_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.l,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5000080) {
				// 11010101000sssssPP0ttttt100ddddd | Rd = add(Rt.l,Rs.l):sat
				hi->instruction = HEX_INS_A2_ADDH_L16_SAT_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s.l,%s.l):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd30000e0) {
				// 11010011000sssssPP0ttttt111ddddd | Rdd = add(Rss,Rtt)
				hi->instruction = HEX_INS_A2_ADDP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd36000a0) {
				// 11010011011sssssPP0ttttt101ddddd | Rdd = add(Rss,Rtt):sat
				hi->instruction = HEX_INS_A2_ADDPSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = add(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd36000e0) {
				// 11010011011sssssPP0ttttt111ddddd | Rdd = add(Rss,Rtt):raw:hi
				hi->instruction = HEX_INS_A2_ADDSPH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = add(%s,%s):raw:hi %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd36000c0) {
				// 11010011011sssssPP0ttttt110ddddd | Rdd = add(Rss,Rtt):raw:lo
				hi->instruction = HEX_INS_A2_ADDSPL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = add(%s,%s):raw:lo %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3e00000) {
				// 11010011111sssssPP0ttttt000ddddd | Rdd = and(Rss,Rtt)
				hi->instruction = HEX_INS_A2_ANDP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5c00000) {
				// 11010101110sssssPP0ttttt000ddddd | Rd = max(Rs,Rt)
				hi->instruction = HEX_INS_A2_MAX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = max(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3c00080) {
				// 11010011110sssssPP0ttttt100ddddd | Rdd = max(Rss,Rtt)
				hi->instruction = HEX_INS_A2_MAXP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = max(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5c00080) {
				// 11010101110sssssPP0ttttt100ddddd | Rd = maxu(Rs,Rt)
				hi->instruction = HEX_INS_A2_MAXU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = maxu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3c000a0) {
				// 11010011110sssssPP0ttttt101ddddd | Rdd = maxu(Rss,Rtt)
				hi->instruction = HEX_INS_A2_MAXUP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = maxu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5a00000) {
				// 11010101101sssssPP0ttttt000ddddd | Rd = min(Rt,Rs)
				hi->instruction = HEX_INS_A2_MIN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = min(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3a000c0) {
				// 11010011101sssssPP0ttttt110ddddd | Rdd = min(Rtt,Rss)
				hi->instruction = HEX_INS_A2_MINP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = min(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5a00080) {
				// 11010101101sssssPP0ttttt100ddddd | Rd = minu(Rt,Rs)
				hi->instruction = HEX_INS_A2_MINU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = minu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3a000e0) {
				// 11010011101sssssPP0ttttt111ddddd | Rdd = minu(Rtt,Rss)
				hi->instruction = HEX_INS_A2_MINUP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = minu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3e00040) {
				// 11010011111sssssPP0ttttt010ddddd | Rdd = or(Rss,Rtt)
				hi->instruction = HEX_INS_A2_ORP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5600060) {
				// 11010101011sssssPP0ttttt011ddddd | Rd = sub(Rt.h,Rs.h):<<16
				hi->instruction = HEX_INS_A2_SUBH_H16_HH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.h,%s.h):<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5600040) {
				// 11010101011sssssPP0ttttt010ddddd | Rd = sub(Rt.h,Rs.l):<<16
				hi->instruction = HEX_INS_A2_SUBH_H16_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.h,%s.l):<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5600020) {
				// 11010101011sssssPP0ttttt001ddddd | Rd = sub(Rt.l,Rs.h):<<16
				hi->instruction = HEX_INS_A2_SUBH_H16_LH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.l,%s.h):<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5600000) {
				// 11010101011sssssPP0ttttt000ddddd | Rd = sub(Rt.l,Rs.l):<<16
				hi->instruction = HEX_INS_A2_SUBH_H16_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.l,%s.l):<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd56000e0) {
				// 11010101011sssssPP0ttttt111ddddd | Rd = sub(Rt.h,Rs.h):sat:<<16
				hi->instruction = HEX_INS_A2_SUBH_H16_SAT_HH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.h,%s.h):sat:<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd56000c0) {
				// 11010101011sssssPP0ttttt110ddddd | Rd = sub(Rt.h,Rs.l):sat:<<16
				hi->instruction = HEX_INS_A2_SUBH_H16_SAT_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.h,%s.l):sat:<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd56000a0) {
				// 11010101011sssssPP0ttttt101ddddd | Rd = sub(Rt.l,Rs.h):sat:<<16
				hi->instruction = HEX_INS_A2_SUBH_H16_SAT_LH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.l,%s.h):sat:<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5600080) {
				// 11010101011sssssPP0ttttt100ddddd | Rd = sub(Rt.l,Rs.l):sat:<<16
				hi->instruction = HEX_INS_A2_SUBH_H16_SAT_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.l,%s.l):sat:<<16 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5200040) {
				// 11010101001sssssPP0ttttt010ddddd | Rd = sub(Rt.l,Rs.h)
				hi->instruction = HEX_INS_A2_SUBH_L16_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5200000) {
				// 11010101001sssssPP0ttttt000ddddd | Rd = sub(Rt.l,Rs.l)
				hi->instruction = HEX_INS_A2_SUBH_L16_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd52000c0) {
				// 11010101001sssssPP0ttttt110ddddd | Rd = sub(Rt.l,Rs.h):sat
				hi->instruction = HEX_INS_A2_SUBH_L16_SAT_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.l,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5200080) {
				// 11010101001sssssPP0ttttt100ddddd | Rd = sub(Rt.l,Rs.l):sat
				hi->instruction = HEX_INS_A2_SUBH_L16_SAT_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s.l,%s.l):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd32000e0) {
				// 11010011001sssssPP0ttttt111ddddd | Rdd = sub(Rtt,Rss)
				hi->instruction = HEX_INS_A2_SUBP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = sub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3000040) {
				// 11010011000sssssPP0ttttt010ddddd | Rdd = vaddh(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VADDH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vaddh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3000060) {
				// 11010011000sssssPP0ttttt011ddddd | Rdd = vaddh(Rss,Rtt):sat
				hi->instruction = HEX_INS_A2_VADDHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vaddh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3000000) {
				// 11010011000sssssPP0ttttt000ddddd | Rdd = vaddub(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VADDUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vaddub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3000020) {
				// 11010011000sssssPP0ttttt001ddddd | Rdd = vaddub(Rss,Rtt):sat
				hi->instruction = HEX_INS_A2_VADDUBS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vaddub(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3000080) {
				// 11010011000sssssPP0ttttt100ddddd | Rdd = vadduh(Rss,Rtt):sat
				hi->instruction = HEX_INS_A2_VADDUHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vadduh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd30000a0) {
				// 11010011000sssssPP0ttttt101ddddd | Rdd = vaddw(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VADDW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vaddw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd30000c0) {
				// 11010011000sssssPP0ttttt110ddddd | Rdd = vaddw(Rss,Rtt):sat
				hi->instruction = HEX_INS_A2_VADDWS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vaddw(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3400040) {
				// 11010011010sssssPP0ttttt010ddddd | Rdd = vavgh(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VAVGH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavgh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3400080) {
				// 11010011010sssssPP0ttttt100ddddd | Rdd = vavgh(Rss,Rtt):crnd
				hi->instruction = HEX_INS_A2_VAVGHCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavgh(%s,%s):crnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3400060) {
				// 11010011010sssssPP0ttttt011ddddd | Rdd = vavgh(Rss,Rtt):rnd
				hi->instruction = HEX_INS_A2_VAVGHR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavgh(%s,%s):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3400000) {
				// 11010011010sssssPP0ttttt000ddddd | Rdd = vavgub(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VAVGUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavgub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3400020) {
				// 11010011010sssssPP0ttttt001ddddd | Rdd = vavgub(Rss,Rtt):rnd
				hi->instruction = HEX_INS_A2_VAVGUBR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavgub(%s,%s):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd34000a0) {
				// 11010011010sssssPP0ttttt101ddddd | Rdd = vavguh(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VAVGUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavguh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd34000c0) {
				// 11010011010sssssPP0ttttt110ddddd | Rdd = vavguh(Rss,Rtt):rnd
				hi->instruction = HEX_INS_A2_VAVGUHR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavguh(%s,%s):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3600060) {
				// 11010011011sssssPP0ttttt011ddddd | Rdd = vavguw(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VAVGUW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavguw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3600080) {
				// 11010011011sssssPP0ttttt100ddddd | Rdd = vavguw(Rss,Rtt):rnd
				hi->instruction = HEX_INS_A2_VAVGUWR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavguw(%s,%s):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3600000) {
				// 11010011011sssssPP0ttttt000ddddd | Rdd = vavgw(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VAVGW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavgw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3600040) {
				// 11010011011sssssPP0ttttt010ddddd | Rdd = vavgw(Rss,Rtt):crnd
				hi->instruction = HEX_INS_A2_VAVGWCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavgw(%s,%s):crnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3600020) {
				// 11010011011sssssPP0ttttt001ddddd | Rdd = vavgw(Rss,Rtt):rnd
				hi->instruction = HEX_INS_A2_VAVGWR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vavgw(%s,%s):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd20000c0) {
				// 11010010000sssssPP0ttttt110000dd | Pd = vcmpb.eq(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VCMPBEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpb.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd20000e0) {
				// 11010010000sssssPP0ttttt111000dd | Pd = vcmpb.gtu(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VCMPBGTU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpb.gtu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2000060) {
				// 11010010000sssssPP0ttttt011000dd | Pd = vcmph.eq(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VCMPHEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmph.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2000080) {
				// 11010010000sssssPP0ttttt100000dd | Pd = vcmph.gt(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VCMPHGT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmph.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd20000a0) {
				// 11010010000sssssPP0ttttt101000dd | Pd = vcmph.gtu(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VCMPHGTU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmph.gtu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2000000) {
				// 11010010000sssssPP0ttttt000000dd | Pd = vcmpw.eq(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VCMPWEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpw.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2000020) {
				// 11010010000sssssPP0ttttt001000dd | Pd = vcmpw.gt(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VCMPWGT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpw.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2000040) {
				// 11010010000sssssPP0ttttt010000dd | Pd = vcmpw.gtu(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VCMPWGTU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpw.gtu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3c000c0) {
				// 11010011110sssssPP0ttttt110ddddd | Rdd = vmaxb(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMAXB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vmaxb(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3c00020) {
				// 11010011110sssssPP0ttttt001ddddd | Rdd = vmaxh(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMAXH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vmaxh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3c00000) {
				// 11010011110sssssPP0ttttt000ddddd | Rdd = vmaxub(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMAXUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vmaxub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3c00040) {
				// 11010011110sssssPP0ttttt010ddddd | Rdd = vmaxuh(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMAXUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vmaxuh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3a000a0) {
				// 11010011101sssssPP0ttttt101ddddd | Rdd = vmaxuw(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMAXUW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vmaxuw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3c00060) {
				// 11010011110sssssPP0ttttt011ddddd | Rdd = vmaxw(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMAXW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vmaxw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3c000e0) {
				// 11010011110sssssPP0ttttt111ddddd | Rdd = vminb(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMINB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vminb(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3a00020) {
				// 11010011101sssssPP0ttttt001ddddd | Rdd = vminh(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMINH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vminh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3a00000) {
				// 11010011101sssssPP0ttttt000ddddd | Rdd = vminub(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMINUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vminub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3a00040) {
				// 11010011101sssssPP0ttttt010ddddd | Rdd = vminuh(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMINUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vminuh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3a00080) {
				// 11010011101sssssPP0ttttt100ddddd | Rdd = vminuw(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMINUW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vminuw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3a00060) {
				// 11010011101sssssPP0ttttt011ddddd | Rdd = vminw(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VMINW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vminw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3800000) {
				// 11010011100sssssPP0ttttt000ddddd | Rdd = vnavgh(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VNAVGH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vnavgh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3800040) {
				// 11010011100sssssPP0ttttt010ddddd | Rdd = vnavgh(Rtt,Rss):crnd:sat
				hi->instruction = HEX_INS_A2_VNAVGHCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vnavgh(%s,%s):crnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3800020) {
				// 11010011100sssssPP0ttttt001ddddd | Rdd = vnavgh(Rtt,Rss):rnd:sat
				hi->instruction = HEX_INS_A2_VNAVGHR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vnavgh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3800060) {
				// 11010011100sssssPP0ttttt011ddddd | Rdd = vnavgw(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VNAVGW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vnavgw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd38000c0) {
				// 11010011100sssssPP0ttttt110ddddd | Rdd = vnavgw(Rtt,Rss):crnd:sat
				hi->instruction = HEX_INS_A2_VNAVGWCR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vnavgw(%s,%s):crnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3800080) {
				// 11010011100sssssPP0ttttt100ddddd | Rdd = vnavgw(Rtt,Rss):rnd:sat
				hi->instruction = HEX_INS_A2_VNAVGWR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vnavgw(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3200040) {
				// 11010011001sssssPP0ttttt010ddddd | Rdd = vsubh(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VSUBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsubh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3200060) {
				// 11010011001sssssPP0ttttt011ddddd | Rdd = vsubh(Rtt,Rss):sat
				hi->instruction = HEX_INS_A2_VSUBHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsubh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3200000) {
				// 11010011001sssssPP0ttttt000ddddd | Rdd = vsubub(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VSUBUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsubub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3200020) {
				// 11010011001sssssPP0ttttt001ddddd | Rdd = vsubub(Rtt,Rss):sat
				hi->instruction = HEX_INS_A2_VSUBUBS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsubub(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3200080) {
				// 11010011001sssssPP0ttttt100ddddd | Rdd = vsubuh(Rtt,Rss):sat
				hi->instruction = HEX_INS_A2_VSUBUHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsubuh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd32000a0) {
				// 11010011001sssssPP0ttttt101ddddd | Rdd = vsubw(Rtt,Rss)
				hi->instruction = HEX_INS_A2_VSUBW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsubw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd32000c0) {
				// 11010011001sssssPP0ttttt110ddddd | Rdd = vsubw(Rtt,Rss):sat
				hi->instruction = HEX_INS_A2_VSUBWS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vsubw(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3e00080) {
				// 11010011111sssssPP0ttttt100ddddd | Rdd = xor(Rss,Rtt)
				hi->instruction = HEX_INS_A2_XORP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3e00020) {
				// 11010011111sssssPP0ttttt001ddddd | Rdd = and(Rtt,~Rss)
				hi->instruction = HEX_INS_A4_ANDNP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = and(%s,~%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd4200000) {
				// 11010100001sssssPP0ttttt000ddddd | Rdd = bitsplit(Rs,Rt)
				hi->instruction = HEX_INS_A4_BITSPLIT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = bitsplit(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd20020a0) {
				// 11010010000sssssPP1ttttt101000dd | Pd = boundscheck(Rss,Rtt):raw:hi
				hi->instruction = HEX_INS_A4_BOUNDSCHECK_HI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = boundscheck(%s,%s):raw:hi %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2002080) {
				// 11010010000sssssPP1ttttt100000dd | Pd = boundscheck(Rss,Rtt):raw:lo
				hi->instruction = HEX_INS_A4_BOUNDSCHECK_LO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = boundscheck(%s,%s):raw:lo %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdd000000) {
				// 11011101000sssssPP0iiiiiiii000dd | Pd = cmpb.eq(Rs,#Ii)
				hi->instruction = HEX_INS_A4_CMPBEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = cmpb.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdd200000) {
				// 11011101001sssssPP0iiiiiiii000dd | Pd = cmpb.gt(Rs,#Ii)
				hi->instruction = HEX_INS_A4_CMPBGTI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = cmpb.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0301c) == 0xdd400000) {
				// 11011101010sssssPP00iiiiiii000dd | Pd = cmpb.gtu(Rs,#Ii)
				hi->instruction = HEX_INS_A4_CMPBGTUI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xfe0) >> 5); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = cmpb.gtu(%s,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdd000008) {
				// 11011101000sssssPP0iiiiiiii010dd | Pd = cmph.eq(Rs,#Ii)
				hi->instruction = HEX_INS_A4_CMPHEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = cmph.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdd200008) {
				// 11011101001sssssPP0iiiiiiii010dd | Pd = cmph.gt(Rs,#Ii)
				hi->instruction = HEX_INS_A4_CMPHGTI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = cmph.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0301c) == 0xdd400008) {
				// 11011101010sssssPP00iiiiiii010dd | Pd = cmph.gtu(Rs,#Ii)
				hi->instruction = HEX_INS_A4_CMPHGTUI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xfe0) >> 5); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = cmph.gtu(%s,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3e000e0) {
				// 11010011111sssssPP0ttttt111ddddd | Rd = modwrap(Rs,Rt)
				hi->instruction = HEX_INS_A4_MODWRAPU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = modwrap(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd3e00060) {
				// 11010011111sssssPP0ttttt011ddddd | Rdd = or(Rtt,~Rss)
				hi->instruction = HEX_INS_A4_ORNP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = or(%s,~%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2002060) {
				// 11010010000sssssPP1ttttt011000dd | Pd = tlbmatch(Rss,Rt)
				hi->instruction = HEX_INS_A4_TLBMATCH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = tlbmatch(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2002000) {
				// 11010010000sssssPP1ttttt000000dd | Pd = any8(vcmpb.eq(Rss,Rtt))
				hi->instruction = HEX_INS_A4_VCMPBEQ_ANY;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = any8(vcmpb.eq(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdc000000) {
				// 11011100000sssssPP0iiiiiiii000dd | Pd = vcmpb.eq(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPBEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = vcmpb.eq(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2002040) {
				// 11010010000sssssPP1ttttt010000dd | Pd = vcmpb.gt(Rss,Rtt)
				hi->instruction = HEX_INS_A4_VCMPBGT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpb.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdc200000) {
				// 11011100001sssssPP0iiiiiiii000dd | Pd = vcmpb.gt(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPBGTI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vcmpb.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0301c) == 0xdc400000) {
				// 11011100010sssssPP00iiiiiii000dd | Pd = vcmpb.gtu(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPBGTUI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xfe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = vcmpb.gtu(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdc000008) {
				// 11011100000sssssPP0iiiiiiii010dd | Pd = vcmph.eq(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPHEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vcmph.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdc200008) {
				// 11011100001sssssPP0iiiiiiii010dd | Pd = vcmph.gt(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPHGTI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vcmph.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0301c) == 0xdc400008) {
				// 11011100010sssssPP00iiiiiii010dd | Pd = vcmph.gtu(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPHGTUI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xfe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = vcmph.gtu(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdc000010) {
				// 11011100000sssssPP0iiiiiiii100dd | Pd = vcmpw.eq(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPWEQI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vcmpw.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0201c) == 0xdc200010) {
				// 11011100001sssssPP0iiiiiiii100dd | Pd = vcmpw.gt(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPWGTI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "#", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "#", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s = vcmpw.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe0301c) == 0xdc400010) {
				// 11011100010sssssPP00iiiiiii100dd | Pd = vcmpw.gtu(Rss,#Ii)
				hi->instruction = HEX_INS_A4_VCMPWGTUI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0xfe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = vcmpw.gtu(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2002020) {
				// 11010010000sssssPP1ttttt001000dd | Pd = !any8(vcmpb.eq(Rss,Rtt))
				hi->instruction = HEX_INS_A6_VCMPBEQ_NOTANY;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = !any8(vcmpb.eq(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2800000) {
				// 11010010100sssssPP0ttttt000000dd | Pd = cmp.eq(Rss,Rtt)
				hi->instruction = HEX_INS_C2_CMPEQP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2800040) {
				// 11010010100sssssPP0ttttt010000dd | Pd = cmp.gt(Rss,Rtt)
				hi->instruction = HEX_INS_C2_CMPGTP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmp.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2800080) {
				// 11010010100sssssPP0ttttt100000dd | Pd = cmp.gtu(Rss,Rtt)
				hi->instruction = HEX_INS_C2_CMPGTUP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmp.gtu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xd1000000) {
				// 11010001000sssssPP0ttttt0uuddddd | Rdd = vmux(Pu,Rss,Rtt)
				hi->instruction = HEX_INS_C2_VMUX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmux(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe03c1c) == 0xdc800010) {
				// 11011100100sssssPP0000iiiii100dd | Pd = dfclass(Rss,#Ii)
				hi->instruction = HEX_INS_F2_DFCLASS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x3e0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = dfclass(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2e00000) {
				// 11010010111sssssPP0ttttt000000dd | Pd = dfcmp.eq(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFCMPEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfcmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2e00040) {
				// 11010010111sssssPP0ttttt010000dd | Pd = dfcmp.ge(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFCMPGE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfcmp.ge(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2e00020) {
				// 11010010111sssssPP0ttttt001000dd | Pd = dfcmp.gt(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFCMPGT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfcmp.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xd2e00060) {
				// 11010010111sssssPP0ttttt011000dd | Pd = dfcmp.uo(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFCMPUO;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfcmp.uo(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffdf0000) == 0xd9400000) {
				// 1101100101i00000PPiiiiiiiiiddddd | Rdd = dfmake(#Ii):neg
				hi->instruction = HEX_INS_F2_DFIMM_N;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = dfmake(#0x%x):neg %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffdf0000) == 0xd9000000) {
				// 1101100100i00000PPiiiiiiiiiddddd | Rdd = dfmake(#Ii):pos
				hi->instruction = HEX_INS_F2_DFIMM_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = dfmake(#0x%x):pos %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffdf0000) == 0xd6400000) {
				// 1101011001i00000PPiiiiiiiiiddddd | Rd = sfmake(#Ii):neg
				hi->instruction = HEX_INS_F2_SFIMM_N;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = sfmake(#0x%x):neg %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffdf0000) == 0xd6000000) {
				// 1101011000i00000PPiiiiiiiiiddddd | Rd = sfmake(#Ii):pos
				hi->instruction = HEX_INS_F2_SFIMM_P;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 2;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				sprintf(hi->mnem, "%s %s = sfmake(#0x%x):pos %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000000) == 0xd8000000) {
				// 11011000IiisssssPPidddddiiiIIIII | Rd = add(#Ii,mpyi(Rs,#II))
				hi->instruction = HEX_INS_M4_MPYRI_ADDI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x600000) >> 17) | (((hi_u32)&0x2000) >> 10) | (((hi_u32)&0xe0) >> 5)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x800000) >> 18) | (((hi_u32)&0x1f) >> 0)); // II
				sprintf(hi->mnem, "%s %s = add(##0x%x,mpyi(%s,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff800000) == 0xdf800000) {
				// 110111111iisssssPPidddddiiiuuuuu | Rd = add(Ru,mpyi(Rs,#Ii))
				hi->instruction = HEX_INS_M4_MPYRI_ADDR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x600000) >> 17) | (((hi_u32)&0x2000) >> 10) | (((hi_u32)&0xe0) >> 5)); // Ii
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = add(%s,mpyi(%s,##0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff800000) == 0xdf000000) {
				// 110111110iisssssPPidddddiiiuuuuu | Rd = add(Ru,mpyi(#Ii,Rs))
				hi->instruction = HEX_INS_M4_MPYRI_ADDR_U2;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x600000) >> 17) | (((hi_u32)&0x2000) >> 10) | (((hi_u32)&0xe0) >> 5)) << 2; // scaled Ii
				hi->ops[2].attr = HEX_OP_IMM_SCALED;
				hi->ops[2].shift = 2;
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s,mpyi(#0x%x,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff800000) == 0xd7000000) {
				// 110101110iisssssPPitttttiiiddddd | Rd = add(#Ii,mpyi(Rs,Rt))
				hi->instruction = HEX_INS_M4_MPYRR_ADDI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0x600000) >> 17) | (((hi_u32)&0x2000) >> 10) | (((hi_u32)&0xe0) >> 5)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = add(##0x%x,mpyi(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd0000000) {
				// 11010000000sssssPP0ttttt000ddddd | Rd = parity(Rss,Rtt)
				hi->instruction = HEX_INS_S2_PARITYP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = parity(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff800000) == 0xdb000000) {
				// 110110110iisssssPPidddddiiiuuuuu | Rd = add(Rs,add(Ru,#Ii))
				hi->instruction = HEX_INS_S4_ADDADDI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x600000) >> 17) | (((hi_u32)&0x2000) >> 10) | (((hi_u32)&0xe0) >> 5)); // Ii
				if (hi->ops[3].op.imm & (1 << 5)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s %s = add(%s,add(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000017) == 0xde000004) {
				// 11011110iiixxxxxPPiIIIIIiii0i100 | Rx = add(#Ii,asl(Rxin,#II))
				hi->instruction = HEX_INS_S4_ADDI_ASL_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xe00000) >> 16) | (((hi_u32)&0x2000) >> 9) | (((hi_u32)&0xe0) >> 4) | (((hi_u32)&0x8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				sprintf(hi->mnem, "%s %s = add(##0x%x,asl(%sin,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000017) == 0xde000014) {
				// 11011110iiixxxxxPPiIIIIIiii1i100 | Rx = add(#Ii,lsr(Rxin,#II))
				hi->instruction = HEX_INS_S4_ADDI_LSR_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xe00000) >> 16) | (((hi_u32)&0x2000) >> 9) | (((hi_u32)&0xe0) >> 4) | (((hi_u32)&0x8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				sprintf(hi->mnem, "%s %s = add(##0x%x,lsr(%sin,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000017) == 0xde000000) {
				// 11011110iiixxxxxPPiIIIIIiii0i000 | Rx = and(#Ii,asl(Rxin,#II))
				hi->instruction = HEX_INS_S4_ANDI_ASL_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xe00000) >> 16) | (((hi_u32)&0x2000) >> 9) | (((hi_u32)&0xe0) >> 4) | (((hi_u32)&0x8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				sprintf(hi->mnem, "%s %s = and(##0x%x,asl(%sin,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000017) == 0xde000010) {
				// 11011110iiixxxxxPPiIIIIIiii1i000 | Rx = and(#Ii,lsr(Rxin,#II))
				hi->instruction = HEX_INS_S4_ANDI_LSR_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xe00000) >> 16) | (((hi_u32)&0x2000) >> 9) | (((hi_u32)&0xe0) >> 4) | (((hi_u32)&0x8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				sprintf(hi->mnem, "%s %s = and(##0x%x,lsr(%sin,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0xda000000) {
				// 1101101000isssssPPiiiiiiiiixxxxx | Rx |= and(Rs,#Ii)
				hi->instruction = HEX_INS_S4_OR_ANDI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 9)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s |= and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0xda400000) {
				// 1101101001ixxxxxPPiiiiiiiiiuuuuu | Rx = or(Ru,and(Rxin,#Ii))
				hi->instruction = HEX_INS_S4_OR_ANDIX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[3].op.imm & (1 << 9)) { // signed
					hi->ops[3].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[3]), false); // Extension possible
				if (((st32)hi->ops[3].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[3].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[3].op.imm);
				}
				sprintf(hi->mnem, "%s %s = or(%s,and(%sin,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffc00000) == 0xda800000) {
				// 1101101010isssssPPiiiiiiiiixxxxx | Rx |= or(Rs,#Ii)
				hi->instruction = HEX_INS_S4_OR_ORI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x200000) >> 12) | (((hi_u32)&0x3fe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 9)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 9);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s |= or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000017) == 0xde000002) {
				// 11011110iiixxxxxPPiIIIIIiii0i010 | Rx = or(#Ii,asl(Rxin,#II))
				hi->instruction = HEX_INS_S4_ORI_ASL_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xe00000) >> 16) | (((hi_u32)&0x2000) >> 9) | (((hi_u32)&0xe0) >> 4) | (((hi_u32)&0x8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				sprintf(hi->mnem, "%s %s = or(##0x%x,asl(%sin,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000017) == 0xde000012) {
				// 11011110iiixxxxxPPiIIIIIiii1i010 | Rx = or(#Ii,lsr(Rxin,#II))
				hi->instruction = HEX_INS_S4_ORI_LSR_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xe00000) >> 16) | (((hi_u32)&0x2000) >> 9) | (((hi_u32)&0xe0) >> 4) | (((hi_u32)&0x8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				sprintf(hi->mnem, "%s %s = or(##0x%x,lsr(%sin,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5e00000) {
				// 11010101111sssssPP0ttttt000ddddd | Rd = parity(Rs,Rt)
				hi->instruction = HEX_INS_S4_PARITY;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = parity(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff800000) == 0xdb800000) {
				// 110110111iisssssPPidddddiiiuuuuu | Rd = add(Rs,sub(#Ii,Ru))
				hi->instruction = HEX_INS_S4_SUBADDI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = ((((hi_u32)&0x600000) >> 17) | (((hi_u32)&0x2000) >> 10) | (((hi_u32)&0xe0) >> 5)); // Ii
				if (hi->ops[2].op.imm & (1 << 5)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 5);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				sprintf(hi->mnem, "%s %s = add(%s,sub(%s,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000017) == 0xde000006) {
				// 11011110iiixxxxxPPiIIIIIiii0i110 | Rx = sub(#Ii,asl(Rxin,#II))
				hi->instruction = HEX_INS_S4_SUBI_ASL_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xe00000) >> 16) | (((hi_u32)&0x2000) >> 9) | (((hi_u32)&0xe0) >> 4) | (((hi_u32)&0x8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				sprintf(hi->mnem, "%s %s = sub(##0x%x,asl(%sin,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xff000017) == 0xde000016) {
				// 11011110iiixxxxxPPiIIIIIiii1i110 | Rx = sub(#Ii,lsr(Rxin,#II))
				hi->instruction = HEX_INS_S4_SUBI_LSR_RI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_IMM;
				hi->ops[1].op.imm = ((((hi_u32)&0xe00000) >> 16) | (((hi_u32)&0x2000) >> 9) | (((hi_u32)&0xe0) >> 4) | (((hi_u32)&0x8) >> 3)); // Ii
				hex_op_extend(&(hi->ops[1]), false); // Extension possible
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rx32in
				hi->ops[3].type = HEX_OP_TYPE_IMM;
				hi->ops[3].op.imm = (((hi_u32)&0x1f00) >> 8); // II
				sprintf(hi->mnem, "%s %s = sub(##0x%x,lsr(%sin,#0x%x)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_int_regs(hi->ops[2].op.reg), hi->ops[3].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5800000) {
				// 11010101100sssssPP0ttttt000ddddd | Rd = add(Rs,Rt):sat:deprecated
				hi->instruction = HEX_INS_DEP_A2_ADDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = add(%s,%s):sat:deprecated %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd5800080) {
				// 11010101100sssssPP0ttttt100ddddd | Rd = sub(Rt,Rs):sat:deprecated
				hi->instruction = HEX_INS_DEP_A2_SUBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s,%s):sat:deprecated %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xd4000000) {
				// 11010100000sssssPP0ttttt000ddddd | Rdd = packhl(Rs,Rt):deprecated
				hi->instruction = HEX_INS_DEP_S2_PACKHL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = packhl(%s,%s):deprecated %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xe:
			if ((hi_u32 & 0xffe020e0) == 0xe8400020) {
				// 11101000010sssssPP0ttttt001ddddd | Rdd = vraddub(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VRADDUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vraddub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea400020) {
				// 11101010010sssssPP0ttttt001xxxxx | Rxx += vraddub(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VRADDUB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vraddub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8400040) {
				// 11101000010sssssPP0ttttt010ddddd | Rdd = vrsadub(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VRSADUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrsadub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea400040) {
				// 11101010010sssssPP0ttttt010xxxxx | Rxx += vrsadub(Rss,Rtt)
				hi->instruction = HEX_INS_A2_VRSADUB_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrsadub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xeaa00000) {
				// 11101010101sssssPP0ttttt0eexxxxx | Rxx,Pe = vacsh(Rss,Rtt)
				hi->instruction = HEX_INS_A5_ACS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Pe4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s,%s = vacsh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xeae00000) {
				// 11101010111sssssPP0ttttt0eeddddd | Rdd,Pe = vminub(Rtt,Rss)
				hi->instruction = HEX_INS_A6_VMINUB_RDP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Pe4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s,%s = vminub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hex_get_double_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8000060) {
				// 11101000000sssssPP0ttttt011ddddd | Rdd = dfadd(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFADD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfadd(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8200060) {
				// 11101000001sssssPP0ttttt011ddddd | Rdd = dfmax(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFMAX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfmax(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8c00060) {
				// 11101000110sssssPP0ttttt011ddddd | Rdd = dfmin(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFMIN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfmin(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8400060) {
				// 11101000010sssssPP0ttttt011ddddd | Rdd = dfmpyfix(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFMPYFIX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfmpyfix(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea800060) {
				// 11101010100sssssPP0ttttt011xxxxx | Rxx += dfmpyhh(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFMPYHH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += dfmpyhh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea000060) {
				// 11101010000sssssPP0ttttt011xxxxx | Rxx += dfmpylh(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFMPYLH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += dfmpylh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8a00060) {
				// 11101000101sssssPP0ttttt011ddddd | Rdd = dfmpyll(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFMPYLL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfmpyll(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8800060) {
				// 11101000100sssssPP0ttttt011ddddd | Rdd = dfsub(Rss,Rtt)
				hi->instruction = HEX_INS_F2_DFSUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = dfsub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeb000000) {
				// 11101011000sssssPP0ttttt000ddddd | Rd = sfadd(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFADD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfadd(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xebc00020) {
				// 11101011110sssssPP0ttttt001ddddd | Rd = sffixupd(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFFIXUPD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sffixupd(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xebc00000) {
				// 11101011110sssssPP0ttttt000ddddd | Rd = sffixupn(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFFIXUPN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sffixupn(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef000080) {
				// 11101111000sssssPP0ttttt100xxxxx | Rx += sfmpy(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFFMA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += sfmpy(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef0000c0) {
				// 11101111000sssssPP0ttttt110xxxxx | Rx += sfmpy(Rs,Rt):lib
				hi->instruction = HEX_INS_F2_SFFMA_LIB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += sfmpy(%s,%s):lib %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xef600080) {
				// 11101111011sssssPP0ttttt1uuxxxxx | Rx += sfmpy(Rs,Rt,Pu):scale
				hi->instruction = HEX_INS_F2_SFFMA_SC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				sprintf(hi->mnem, "%s %s += sfmpy(%s,%s,%s):scale %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_pred_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef0000a0) {
				// 11101111000sssssPP0ttttt101xxxxx | Rx -= sfmpy(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFFMS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= sfmpy(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef0000e0) {
				// 11101111000sssssPP0ttttt111xxxxx | Rx -= sfmpy(Rs,Rt):lib
				hi->instruction = HEX_INS_F2_SFFMS_LIB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= sfmpy(%s,%s):lib %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeb800000) {
				// 11101011100sssssPP0ttttt000ddddd | Rd = sfmax(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFMAX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfmax(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeb800020) {
				// 11101011100sssssPP0ttttt001ddddd | Rd = sfmin(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFMIN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfmin(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeb400000) {
				// 11101011010sssssPP0ttttt000ddddd | Rd = sfmpy(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFMPY;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfmpy(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xebe00080) {
				// 11101011111sssssPP0ttttt1eeddddd | Rd,Pe = sfrecipa(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFRECIPA;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Pe4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s,%s = sfrecipa(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeb000020) {
				// 11101011000sssssPP0ttttt001ddddd | Rd = sfsub(Rs,Rt)
				hi->instruction = HEX_INS_F2_SFSUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = sfsub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef000020) {
				// 11101111000sssssPP0ttttt001xxxxx | Rx += add(Rs,Rt)
				hi->instruction = HEX_INS_M2_ACCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xe2000000) {
				// 11100010000sssssPP0iiiiiiiixxxxx | Rx += add(Rs,#Ii)
				hi->instruction = HEX_INS_M2_ACCII;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s += add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7000020) {
				// 11100111000sssssPP0ttttt001xxxxx | Rxx += cmpyi(Rs,Rt)
				hi->instruction = HEX_INS_M2_CMACI_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += cmpyi(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7000040) {
				// 11100111000sssssPP0ttttt010xxxxx | Rxx += cmpyr(Rs,Rt)
				hi->instruction = HEX_INS_M2_CMACR_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += cmpyr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe70000c0) {
				// 11100111000sssssPP0ttttt110xxxxx | Rxx += cmpy(Rs,Rt):sat
				hi->instruction = HEX_INS_M2_CMACS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += cmpy(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe78000c0) {
				// 11100111100sssssPP0ttttt110xxxxx | Rxx += cmpy(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M2_CMACS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += cmpy(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe74000c0) {
				// 11100111010sssssPP0ttttt110xxxxx | Rxx += cmpy(Rs,Rt*):sat
				hi->instruction = HEX_INS_M2_CMACSC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += cmpy(%s,%s*):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7c000c0) {
				// 11100111110sssssPP0ttttt110xxxxx | Rxx += cmpy(Rs,Rt*):<<1:sat
				hi->instruction = HEX_INS_M2_CMACSC_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += cmpy(%s,%s*):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe5000020) {
				// 11100101000sssssPP0ttttt001ddddd | Rdd = cmpyi(Rs,Rt)
				hi->instruction = HEX_INS_M2_CMPYI_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpyi(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe5000040) {
				// 11100101000sssssPP0ttttt010ddddd | Rdd = cmpyr(Rs,Rt)
				hi->instruction = HEX_INS_M2_CMPYR_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpyr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xed2000c0) {
				// 11101101001sssssPP0ttttt110ddddd | Rd = cmpy(Rs,Rt):rnd:sat
				hi->instruction = HEX_INS_M2_CMPYRS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpy(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeda000c0) {
				// 11101101101sssssPP0ttttt110ddddd | Rd = cmpy(Rs,Rt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_CMPYRS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpy(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xed6000c0) {
				// 11101101011sssssPP0ttttt110ddddd | Rd = cmpy(Rs,Rt*):rnd:sat
				hi->instruction = HEX_INS_M2_CMPYRSC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpy(%s,%s*):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xede000c0) {
				// 11101101111sssssPP0ttttt110ddddd | Rd = cmpy(Rs,Rt*):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_CMPYRSC_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpy(%s,%s*):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe50000c0) {
				// 11100101000sssssPP0ttttt110ddddd | Rdd = cmpy(Rs,Rt):sat
				hi->instruction = HEX_INS_M2_CMPYS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpy(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe58000c0) {
				// 11100101100sssssPP0ttttt110ddddd | Rdd = cmpy(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M2_CMPYS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpy(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe54000c0) {
				// 11100101010sssssPP0ttttt110ddddd | Rdd = cmpy(Rs,Rt*):sat
				hi->instruction = HEX_INS_M2_CMPYSC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpy(%s,%s*):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe5c000c0) {
				// 11100101110sssssPP0ttttt110ddddd | Rdd = cmpy(Rs,Rt*):<<1:sat
				hi->instruction = HEX_INS_M2_CMPYSC_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmpy(%s,%s*):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe70000e0) {
				// 11100111000sssssPP0ttttt111xxxxx | Rxx -= cmpy(Rs,Rt):sat
				hi->instruction = HEX_INS_M2_CNACS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= cmpy(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe78000e0) {
				// 11100111100sssssPP0ttttt111xxxxx | Rxx -= cmpy(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M2_CNACS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= cmpy(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe74000e0) {
				// 11100111010sssssPP0ttttt111xxxxx | Rxx -= cmpy(Rs,Rt*):sat
				hi->instruction = HEX_INS_M2_CNACSC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= cmpy(%s,%s*):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7c000e0) {
				// 11100111110sssssPP0ttttt111xxxxx | Rxx -= cmpy(Rs,Rt*):<<1:sat
				hi->instruction = HEX_INS_M2_CNACSC_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= cmpy(%s,%s*):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7000000) {
				// 11100111000sssssPP0ttttt000xxxxx | Rxx += mpy(Rs,Rt)
				hi->instruction = HEX_INS_M2_DPMPYSS_ACC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7200000) {
				// 11100111001sssssPP0ttttt000xxxxx | Rxx -= mpy(Rs,Rt)
				hi->instruction = HEX_INS_M2_DPMPYSS_NAC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xed200020) {
				// 11101101001sssssPP0ttttt001ddddd | Rd = mpy(Rs,Rt):rnd
				hi->instruction = HEX_INS_M2_DPMPYSS_RND_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s):rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe5000000) {
				// 11100101000sssssPP0ttttt000ddddd | Rdd = mpy(Rs,Rt)
				hi->instruction = HEX_INS_M2_DPMPYSS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7400000) {
				// 11100111010sssssPP0ttttt000xxxxx | Rxx += mpyu(Rs,Rt)
				hi->instruction = HEX_INS_M2_DPMPYUU_ACC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7600000) {
				// 11100111011sssssPP0ttttt000xxxxx | Rxx -= mpyu(Rs,Rt)
				hi->instruction = HEX_INS_M2_DPMPYUU_NAC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe5400000) {
				// 11100101010sssssPP0ttttt000ddddd | Rdd = mpyu(Rs,Rt)
				hi->instruction = HEX_INS_M2_DPMPYUU_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeda00080) {
				// 11101101101sssssPP0ttttt100ddddd | Rd = mpy(Rs,Rt.h):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_HMMPYH_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s.h):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeda00000) {
				// 11101101101sssssPP0ttttt000ddddd | Rd = mpy(Rs,Rt.h):<<1:sat
				hi->instruction = HEX_INS_M2_HMMPYH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xede00080) {
				// 11101101111sssssPP0ttttt100ddddd | Rd = mpy(Rs,Rt.l):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_HMMPYL_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s.l):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeda00020) {
				// 11101101101sssssPP0ttttt001ddddd | Rd = mpy(Rs,Rt.l):<<1:sat
				hi->instruction = HEX_INS_M2_HMMPYL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s.l):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef000000) {
				// 11101111000sssssPP0ttttt000xxxxx | Rx += mpyi(Rs,Rt)
				hi->instruction = HEX_INS_M2_MACI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyi(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xe1800000) {
				// 11100001100sssssPP0iiiiiiiixxxxx | Rx -= mpyi(Rs,#Ii)
				hi->instruction = HEX_INS_M2_MACSIN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s -= mpyi(%s,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xe1000000) {
				// 11100001000sssssPP0iiiiiiiixxxxx | Rx += mpyi(Rs,#Ii)
				hi->instruction = HEX_INS_M2_MACSIP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s += mpyi(%s,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea2000e0) {
				// 11101010001sssssPP0ttttt111xxxxx | Rxx += vmpywoh(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_MMACHS_RS0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpywoh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeaa000e0) {
				// 11101010101sssssPP0ttttt111xxxxx | Rxx += vmpywoh(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MMACHS_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpywoh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea0000e0) {
				// 11101010000sssssPP0ttttt111xxxxx | Rxx += vmpywoh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_MMACHS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpywoh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea8000e0) {
				// 11101010100sssssPP0ttttt111xxxxx | Rxx += vmpywoh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_MMACHS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpywoh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea2000a0) {
				// 11101010001sssssPP0ttttt101xxxxx | Rxx += vmpyweh(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_MMACLS_RS0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyweh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeaa000a0) {
				// 11101010101sssssPP0ttttt101xxxxx | Rxx += vmpyweh(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MMACLS_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyweh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea0000a0) {
				// 11101010000sssssPP0ttttt101xxxxx | Rxx += vmpyweh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_MMACLS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyweh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea8000a0) {
				// 11101010100sssssPP0ttttt101xxxxx | Rxx += vmpyweh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_MMACLS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyweh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea6000e0) {
				// 11101010011sssssPP0ttttt111xxxxx | Rxx += vmpywouh(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_MMACUHS_RS0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpywouh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeae000e0) {
				// 11101010111sssssPP0ttttt111xxxxx | Rxx += vmpywouh(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MMACUHS_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpywouh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea4000e0) {
				// 11101010010sssssPP0ttttt111xxxxx | Rxx += vmpywouh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_MMACUHS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpywouh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeac000e0) {
				// 11101010110sssssPP0ttttt111xxxxx | Rxx += vmpywouh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_MMACUHS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpywouh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea6000a0) {
				// 11101010011sssssPP0ttttt101xxxxx | Rxx += vmpyweuh(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_MMACULS_RS0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyweuh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeae000a0) {
				// 11101010111sssssPP0ttttt101xxxxx | Rxx += vmpyweuh(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MMACULS_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyweuh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea4000a0) {
				// 11101010010sssssPP0ttttt101xxxxx | Rxx += vmpyweuh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_MMACULS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyweuh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeac000a0) {
				// 11101010110sssssPP0ttttt101xxxxx | Rxx += vmpyweuh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_MMACULS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyweuh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe82000e0) {
				// 11101000001sssssPP0ttttt111ddddd | Rdd = vmpywoh(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_MMPYH_RS0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpywoh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8a000e0) {
				// 11101000101sssssPP0ttttt111ddddd | Rdd = vmpywoh(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MMPYH_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpywoh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe80000e0) {
				// 11101000000sssssPP0ttttt111ddddd | Rdd = vmpywoh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_MMPYH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpywoh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe88000e0) {
				// 11101000100sssssPP0ttttt111ddddd | Rdd = vmpywoh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_MMPYH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpywoh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe82000a0) {
				// 11101000001sssssPP0ttttt101ddddd | Rdd = vmpyweh(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_MMPYL_RS0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyweh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8a000a0) {
				// 11101000101sssssPP0ttttt101ddddd | Rdd = vmpyweh(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MMPYL_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyweh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe80000a0) {
				// 11101000000sssssPP0ttttt101ddddd | Rdd = vmpyweh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_MMPYL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyweh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe88000a0) {
				// 11101000100sssssPP0ttttt101ddddd | Rdd = vmpyweh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_MMPYL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyweh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe86000e0) {
				// 11101000011sssssPP0ttttt111ddddd | Rdd = vmpywouh(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_MMPYUH_RS0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpywouh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8e000e0) {
				// 11101000111sssssPP0ttttt111ddddd | Rdd = vmpywouh(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MMPYUH_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpywouh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe84000e0) {
				// 11101000010sssssPP0ttttt111ddddd | Rdd = vmpywouh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_MMPYUH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpywouh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8c000e0) {
				// 11101000110sssssPP0ttttt111ddddd | Rdd = vmpywouh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_MMPYUH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpywouh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe86000a0) {
				// 11101000011sssssPP0ttttt101ddddd | Rdd = vmpyweuh(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_MMPYUL_RS0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyweuh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8e000a0) {
				// 11101000111sssssPP0ttttt101ddddd | Rdd = vmpyweuh(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MMPYUL_RS1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyweuh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe84000a0) {
				// 11101000010sssssPP0ttttt101ddddd | Rdd = vmpyweuh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_MMPYUL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyweuh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8c000a0) {
				// 11101000110sssssPP0ttttt101ddddd | Rdd = vmpyweuh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_MMPYUL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyweuh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef800000) {
				// 11101111100sssssPP0ttttt000xxxxx | Rx -= mpyi(Rs,Rt)
				hi->instruction = HEX_INS_M2_MNACI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyi(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee000060) {
				// 11101110000sssssPP0ttttt011xxxxx | Rx += mpy(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPY_ACC_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee800060) {
				// 11101110100sssssPP0ttttt011xxxxx | Rx += mpy(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPY_ACC_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee000040) {
				// 11101110000sssssPP0ttttt010xxxxx | Rx += mpy(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPY_ACC_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee800040) {
				// 11101110100sssssPP0ttttt010xxxxx | Rx += mpy(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPY_ACC_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee000020) {
				// 11101110000sssssPP0ttttt001xxxxx | Rx += mpy(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPY_ACC_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee800020) {
				// 11101110100sssssPP0ttttt001xxxxx | Rx += mpy(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPY_ACC_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee000000) {
				// 11101110000sssssPP0ttttt000xxxxx | Rx += mpy(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPY_ACC_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee800000) {
				// 11101110100sssssPP0ttttt000xxxxx | Rx += mpy(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPY_ACC_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee0000e0) {
				// 11101110000sssssPP0ttttt111xxxxx | Rx += mpy(Rs.h,Rt.h):sat
				hi->instruction = HEX_INS_M2_MPY_ACC_SAT_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee8000e0) {
				// 11101110100sssssPP0ttttt111xxxxx | Rx += mpy(Rs.h,Rt.h):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_ACC_SAT_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee0000c0) {
				// 11101110000sssssPP0ttttt110xxxxx | Rx += mpy(Rs.h,Rt.l):sat
				hi->instruction = HEX_INS_M2_MPY_ACC_SAT_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.l):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee8000c0) {
				// 11101110100sssssPP0ttttt110xxxxx | Rx += mpy(Rs.h,Rt.l):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_ACC_SAT_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.l):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee0000a0) {
				// 11101110000sssssPP0ttttt101xxxxx | Rx += mpy(Rs.l,Rt.h):sat
				hi->instruction = HEX_INS_M2_MPY_ACC_SAT_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee8000a0) {
				// 11101110100sssssPP0ttttt101xxxxx | Rx += mpy(Rs.l,Rt.h):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_ACC_SAT_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee000080) {
				// 11101110000sssssPP0ttttt100xxxxx | Rx += mpy(Rs.l,Rt.l):sat
				hi->instruction = HEX_INS_M2_MPY_ACC_SAT_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.l):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee800080) {
				// 11101110100sssssPP0ttttt100xxxxx | Rx += mpy(Rs.l,Rt.l):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_ACC_SAT_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.l):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec000060) {
				// 11101100000sssssPP0ttttt011ddddd | Rd = mpy(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPY_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec800060) {
				// 11101100100sssssPP0ttttt011ddddd | Rd = mpy(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPY_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec000040) {
				// 11101100000sssssPP0ttttt010ddddd | Rd = mpy(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPY_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec800040) {
				// 11101100100sssssPP0ttttt010ddddd | Rd = mpy(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPY_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec000020) {
				// 11101100000sssssPP0ttttt001ddddd | Rd = mpy(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPY_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec800020) {
				// 11101100100sssssPP0ttttt001ddddd | Rd = mpy(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPY_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec000000) {
				// 11101100000sssssPP0ttttt000ddddd | Rd = mpy(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPY_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec800000) {
				// 11101100100sssssPP0ttttt000ddddd | Rd = mpy(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPY_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee200060) {
				// 11101110001sssssPP0ttttt011xxxxx | Rx -= mpy(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPY_NAC_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeea00060) {
				// 11101110101sssssPP0ttttt011xxxxx | Rx -= mpy(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPY_NAC_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee200040) {
				// 11101110001sssssPP0ttttt010xxxxx | Rx -= mpy(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPY_NAC_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeea00040) {
				// 11101110101sssssPP0ttttt010xxxxx | Rx -= mpy(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPY_NAC_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee200020) {
				// 11101110001sssssPP0ttttt001xxxxx | Rx -= mpy(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPY_NAC_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeea00020) {
				// 11101110101sssssPP0ttttt001xxxxx | Rx -= mpy(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPY_NAC_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee200000) {
				// 11101110001sssssPP0ttttt000xxxxx | Rx -= mpy(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPY_NAC_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeea00000) {
				// 11101110101sssssPP0ttttt000xxxxx | Rx -= mpy(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPY_NAC_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee2000e0) {
				// 11101110001sssssPP0ttttt111xxxxx | Rx -= mpy(Rs.h,Rt.h):sat
				hi->instruction = HEX_INS_M2_MPY_NAC_SAT_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeea000e0) {
				// 11101110101sssssPP0ttttt111xxxxx | Rx -= mpy(Rs.h,Rt.h):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_NAC_SAT_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee2000c0) {
				// 11101110001sssssPP0ttttt110xxxxx | Rx -= mpy(Rs.h,Rt.l):sat
				hi->instruction = HEX_INS_M2_MPY_NAC_SAT_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.l):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeea000c0) {
				// 11101110101sssssPP0ttttt110xxxxx | Rx -= mpy(Rs.h,Rt.l):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_NAC_SAT_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.l):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee2000a0) {
				// 11101110001sssssPP0ttttt101xxxxx | Rx -= mpy(Rs.l,Rt.h):sat
				hi->instruction = HEX_INS_M2_MPY_NAC_SAT_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeea000a0) {
				// 11101110101sssssPP0ttttt101xxxxx | Rx -= mpy(Rs.l,Rt.h):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_NAC_SAT_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee200080) {
				// 11101110001sssssPP0ttttt100xxxxx | Rx -= mpy(Rs.l,Rt.l):sat
				hi->instruction = HEX_INS_M2_MPY_NAC_SAT_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.l):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeea00080) {
				// 11101110101sssssPP0ttttt100xxxxx | Rx -= mpy(Rs.l,Rt.l):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_NAC_SAT_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.l):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec200060) {
				// 11101100001sssssPP0ttttt011ddddd | Rd = mpy(Rs.h,Rt.h):rnd
				hi->instruction = HEX_INS_M2_MPY_RND_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeca00060) {
				// 11101100101sssssPP0ttttt011ddddd | Rd = mpy(Rs.h,Rt.h):<<1:rnd
				hi->instruction = HEX_INS_M2_MPY_RND_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):<<1:rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec200040) {
				// 11101100001sssssPP0ttttt010ddddd | Rd = mpy(Rs.h,Rt.l):rnd
				hi->instruction = HEX_INS_M2_MPY_RND_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeca00040) {
				// 11101100101sssssPP0ttttt010ddddd | Rd = mpy(Rs.h,Rt.l):<<1:rnd
				hi->instruction = HEX_INS_M2_MPY_RND_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):<<1:rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec200020) {
				// 11101100001sssssPP0ttttt001ddddd | Rd = mpy(Rs.l,Rt.h):rnd
				hi->instruction = HEX_INS_M2_MPY_RND_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeca00020) {
				// 11101100101sssssPP0ttttt001ddddd | Rd = mpy(Rs.l,Rt.h):<<1:rnd
				hi->instruction = HEX_INS_M2_MPY_RND_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):<<1:rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec200000) {
				// 11101100001sssssPP0ttttt000ddddd | Rd = mpy(Rs.l,Rt.l):rnd
				hi->instruction = HEX_INS_M2_MPY_RND_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeca00000) {
				// 11101100101sssssPP0ttttt000ddddd | Rd = mpy(Rs.l,Rt.l):<<1:rnd
				hi->instruction = HEX_INS_M2_MPY_RND_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):<<1:rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec0000e0) {
				// 11101100000sssssPP0ttttt111ddddd | Rd = mpy(Rs.h,Rt.h):sat
				hi->instruction = HEX_INS_M2_MPY_SAT_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec8000e0) {
				// 11101100100sssssPP0ttttt111ddddd | Rd = mpy(Rs.h,Rt.h):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec0000c0) {
				// 11101100000sssssPP0ttttt110ddddd | Rd = mpy(Rs.h,Rt.l):sat
				hi->instruction = HEX_INS_M2_MPY_SAT_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec8000c0) {
				// 11101100100sssssPP0ttttt110ddddd | Rd = mpy(Rs.h,Rt.l):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec0000a0) {
				// 11101100000sssssPP0ttttt101ddddd | Rd = mpy(Rs.l,Rt.h):sat
				hi->instruction = HEX_INS_M2_MPY_SAT_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec8000a0) {
				// 11101100100sssssPP0ttttt101ddddd | Rd = mpy(Rs.l,Rt.h):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec000080) {
				// 11101100000sssssPP0ttttt100ddddd | Rd = mpy(Rs.l,Rt.l):sat
				hi->instruction = HEX_INS_M2_MPY_SAT_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec800080) {
				// 11101100100sssssPP0ttttt100ddddd | Rd = mpy(Rs.l,Rt.l):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec2000e0) {
				// 11101100001sssssPP0ttttt111ddddd | Rd = mpy(Rs.h,Rt.h):rnd:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_RND_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeca000e0) {
				// 11101100101sssssPP0ttttt111ddddd | Rd = mpy(Rs.h,Rt.h):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_RND_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec2000c0) {
				// 11101100001sssssPP0ttttt110ddddd | Rd = mpy(Rs.h,Rt.l):rnd:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_RND_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeca000c0) {
				// 11101100101sssssPP0ttttt110ddddd | Rd = mpy(Rs.h,Rt.l):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_RND_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec2000a0) {
				// 11101100001sssssPP0ttttt101ddddd | Rd = mpy(Rs.l,Rt.h):rnd:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_RND_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeca000a0) {
				// 11101100101sssssPP0ttttt101ddddd | Rd = mpy(Rs.l,Rt.h):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_RND_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec200080) {
				// 11101100001sssssPP0ttttt100ddddd | Rd = mpy(Rs.l,Rt.l):rnd:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_RND_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeca00080) {
				// 11101100101sssssPP0ttttt100ddddd | Rd = mpy(Rs.l,Rt.l):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_MPY_SAT_RND_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xed000020) {
				// 11101101000sssssPP0ttttt001ddddd | Rd = mpy(Rs,Rt)
				hi->instruction = HEX_INS_M2_MPY_UP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeda00040) {
				// 11101101101sssssPP0ttttt010ddddd | Rd = mpy(Rs,Rt):<<1
				hi->instruction = HEX_INS_M2_MPY_UP_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xede00000) {
				// 11101101111sssssPP0ttttt000ddddd | Rd = mpy(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M2_MPY_UP_S1_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6000060) {
				// 11100110000sssssPP0ttttt011xxxxx | Rxx += mpy(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYD_ACC_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6800060) {
				// 11100110100sssssPP0ttttt011xxxxx | Rxx += mpy(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYD_ACC_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6000040) {
				// 11100110000sssssPP0ttttt010xxxxx | Rxx += mpy(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYD_ACC_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6800040) {
				// 11100110100sssssPP0ttttt010xxxxx | Rxx += mpy(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYD_ACC_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6000020) {
				// 11100110000sssssPP0ttttt001xxxxx | Rxx += mpy(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYD_ACC_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6800020) {
				// 11100110100sssssPP0ttttt001xxxxx | Rxx += mpy(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYD_ACC_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6000000) {
				// 11100110000sssssPP0ttttt000xxxxx | Rxx += mpy(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYD_ACC_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6800000) {
				// 11100110100sssssPP0ttttt000xxxxx | Rxx += mpy(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYD_ACC_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4000060) {
				// 11100100000sssssPP0ttttt011ddddd | Rdd = mpy(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYD_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4800060) {
				// 11100100100sssssPP0ttttt011ddddd | Rdd = mpy(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYD_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4000040) {
				// 11100100000sssssPP0ttttt010ddddd | Rdd = mpy(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYD_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4800040) {
				// 11100100100sssssPP0ttttt010ddddd | Rdd = mpy(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYD_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4000020) {
				// 11100100000sssssPP0ttttt001ddddd | Rdd = mpy(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYD_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4800020) {
				// 11100100100sssssPP0ttttt001ddddd | Rdd = mpy(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYD_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4000000) {
				// 11100100000sssssPP0ttttt000ddddd | Rdd = mpy(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYD_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4800000) {
				// 11100100100sssssPP0ttttt000ddddd | Rdd = mpy(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYD_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6200060) {
				// 11100110001sssssPP0ttttt011xxxxx | Rxx -= mpy(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYD_NAC_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6a00060) {
				// 11100110101sssssPP0ttttt011xxxxx | Rxx -= mpy(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYD_NAC_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6200040) {
				// 11100110001sssssPP0ttttt010xxxxx | Rxx -= mpy(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYD_NAC_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6a00040) {
				// 11100110101sssssPP0ttttt010xxxxx | Rxx -= mpy(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYD_NAC_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6200020) {
				// 11100110001sssssPP0ttttt001xxxxx | Rxx -= mpy(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYD_NAC_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6a00020) {
				// 11100110101sssssPP0ttttt001xxxxx | Rxx -= mpy(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYD_NAC_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6200000) {
				// 11100110001sssssPP0ttttt000xxxxx | Rxx -= mpy(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYD_NAC_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6a00000) {
				// 11100110101sssssPP0ttttt000xxxxx | Rxx -= mpy(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYD_NAC_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4200060) {
				// 11100100001sssssPP0ttttt011ddddd | Rdd = mpy(Rs.h,Rt.h):rnd
				hi->instruction = HEX_INS_M2_MPYD_RND_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4a00060) {
				// 11100100101sssssPP0ttttt011ddddd | Rdd = mpy(Rs.h,Rt.h):<<1:rnd
				hi->instruction = HEX_INS_M2_MPYD_RND_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.h):<<1:rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4200040) {
				// 11100100001sssssPP0ttttt010ddddd | Rdd = mpy(Rs.h,Rt.l):rnd
				hi->instruction = HEX_INS_M2_MPYD_RND_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4a00040) {
				// 11100100101sssssPP0ttttt010ddddd | Rdd = mpy(Rs.h,Rt.l):<<1:rnd
				hi->instruction = HEX_INS_M2_MPYD_RND_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.h,%s.l):<<1:rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4200020) {
				// 11100100001sssssPP0ttttt001ddddd | Rdd = mpy(Rs.l,Rt.h):rnd
				hi->instruction = HEX_INS_M2_MPYD_RND_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4a00020) {
				// 11100100101sssssPP0ttttt001ddddd | Rdd = mpy(Rs.l,Rt.h):<<1:rnd
				hi->instruction = HEX_INS_M2_MPYD_RND_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.h):<<1:rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4200000) {
				// 11100100001sssssPP0ttttt000ddddd | Rdd = mpy(Rs.l,Rt.l):rnd
				hi->instruction = HEX_INS_M2_MPYD_RND_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4a00000) {
				// 11100100101sssssPP0ttttt000ddddd | Rdd = mpy(Rs.l,Rt.l):<<1:rnd
				hi->instruction = HEX_INS_M2_MPYD_RND_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpy(%s.l,%s.l):<<1:rnd %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xed000000) {
				// 11101101000sssssPP0ttttt000ddddd | Rd = mpyi(Rs,Rt)
				hi->instruction = HEX_INS_M2_MPYI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyi(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xe0800000) {
				// 11100000100sssssPP0iiiiiiiiddddd | Rd = -mpyi(Rs,#Ii)
				hi->instruction = HEX_INS_M2_MPYSIN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				sprintf(hi->mnem, "%s %s = -mpyi(%s,#0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xe0000000) {
				// 11100000000sssssPP0iiiiiiiiddddd | Rd = +mpyi(Rs,#Ii)
				hi->instruction = HEX_INS_M2_MPYSIP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				sprintf(hi->mnem, "%s %s = +mpyi(%s,##0x%x) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xed600020) {
				// 11101101011sssssPP0ttttt001ddddd | Rd = mpysu(Rs,Rt)
				hi->instruction = HEX_INS_M2_MPYSU_UP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpysu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee400060) {
				// 11101110010sssssPP0ttttt011xxxxx | Rx += mpyu(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYU_ACC_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeec00060) {
				// 11101110110sssssPP0ttttt011xxxxx | Rx += mpyu(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYU_ACC_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee400040) {
				// 11101110010sssssPP0ttttt010xxxxx | Rx += mpyu(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYU_ACC_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeec00040) {
				// 11101110110sssssPP0ttttt010xxxxx | Rx += mpyu(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYU_ACC_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee400020) {
				// 11101110010sssssPP0ttttt001xxxxx | Rx += mpyu(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYU_ACC_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeec00020) {
				// 11101110110sssssPP0ttttt001xxxxx | Rx += mpyu(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYU_ACC_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee400000) {
				// 11101110010sssssPP0ttttt000xxxxx | Rx += mpyu(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYU_ACC_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeec00000) {
				// 11101110110sssssPP0ttttt000xxxxx | Rx += mpyu(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYU_ACC_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec400060) {
				// 11101100010sssssPP0ttttt011ddddd | Rd = mpyu(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYU_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xecc00060) {
				// 11101100110sssssPP0ttttt011ddddd | Rd = mpyu(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYU_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec400040) {
				// 11101100010sssssPP0ttttt010ddddd | Rd = mpyu(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYU_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xecc00040) {
				// 11101100110sssssPP0ttttt010ddddd | Rd = mpyu(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYU_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec400020) {
				// 11101100010sssssPP0ttttt001ddddd | Rd = mpyu(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYU_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xecc00020) {
				// 11101100110sssssPP0ttttt001ddddd | Rd = mpyu(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYU_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xec400000) {
				// 11101100010sssssPP0ttttt000ddddd | Rd = mpyu(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYU_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xecc00000) {
				// 11101100110sssssPP0ttttt000ddddd | Rd = mpyu(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYU_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee600060) {
				// 11101110011sssssPP0ttttt011xxxxx | Rx -= mpyu(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYU_NAC_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeee00060) {
				// 11101110111sssssPP0ttttt011xxxxx | Rx -= mpyu(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYU_NAC_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee600040) {
				// 11101110011sssssPP0ttttt010xxxxx | Rx -= mpyu(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYU_NAC_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeee00040) {
				// 11101110111sssssPP0ttttt010xxxxx | Rx -= mpyu(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYU_NAC_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee600020) {
				// 11101110011sssssPP0ttttt001xxxxx | Rx -= mpyu(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYU_NAC_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeee00020) {
				// 11101110111sssssPP0ttttt001xxxxx | Rx -= mpyu(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYU_NAC_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xee600000) {
				// 11101110011sssssPP0ttttt000xxxxx | Rx -= mpyu(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYU_NAC_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeee00000) {
				// 11101110111sssssPP0ttttt000xxxxx | Rx -= mpyu(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYU_NAC_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xed400020) {
				// 11101101010sssssPP0ttttt001ddddd | Rd = mpyu(Rs,Rt)
				hi->instruction = HEX_INS_M2_MPYU_UP;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6400060) {
				// 11100110010sssssPP0ttttt011xxxxx | Rxx += mpyu(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYUD_ACC_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6c00060) {
				// 11100110110sssssPP0ttttt011xxxxx | Rxx += mpyu(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYUD_ACC_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6400040) {
				// 11100110010sssssPP0ttttt010xxxxx | Rxx += mpyu(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYUD_ACC_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6c00040) {
				// 11100110110sssssPP0ttttt010xxxxx | Rxx += mpyu(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYUD_ACC_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6400020) {
				// 11100110010sssssPP0ttttt001xxxxx | Rxx += mpyu(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYUD_ACC_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6c00020) {
				// 11100110110sssssPP0ttttt001xxxxx | Rxx += mpyu(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYUD_ACC_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6400000) {
				// 11100110010sssssPP0ttttt000xxxxx | Rxx += mpyu(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYUD_ACC_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6c00000) {
				// 11100110110sssssPP0ttttt000xxxxx | Rxx += mpyu(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYUD_ACC_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpyu(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4400060) {
				// 11100100010sssssPP0ttttt011ddddd | Rdd = mpyu(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYUD_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4c00060) {
				// 11100100110sssssPP0ttttt011ddddd | Rdd = mpyu(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYUD_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4400040) {
				// 11100100010sssssPP0ttttt010ddddd | Rdd = mpyu(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYUD_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4c00040) {
				// 11100100110sssssPP0ttttt010ddddd | Rdd = mpyu(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYUD_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4400020) {
				// 11100100010sssssPP0ttttt001ddddd | Rdd = mpyu(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYUD_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4c00020) {
				// 11100100110sssssPP0ttttt001ddddd | Rdd = mpyu(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYUD_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4400000) {
				// 11100100010sssssPP0ttttt000ddddd | Rdd = mpyu(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYUD_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe4c00000) {
				// 11100100110sssssPP0ttttt000ddddd | Rdd = mpyu(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYUD_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mpyu(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6600060) {
				// 11100110011sssssPP0ttttt011xxxxx | Rxx -= mpyu(Rs.h,Rt.h)
				hi->instruction = HEX_INS_M2_MPYUD_NAC_HH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6e00060) {
				// 11100110111sssssPP0ttttt011xxxxx | Rxx -= mpyu(Rs.h,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYUD_NAC_HH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.h,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6600040) {
				// 11100110011sssssPP0ttttt010xxxxx | Rxx -= mpyu(Rs.h,Rt.l)
				hi->instruction = HEX_INS_M2_MPYUD_NAC_HL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6e00040) {
				// 11100110111sssssPP0ttttt010xxxxx | Rxx -= mpyu(Rs.h,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYUD_NAC_HL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.h,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6600020) {
				// 11100110011sssssPP0ttttt001xxxxx | Rxx -= mpyu(Rs.l,Rt.h)
				hi->instruction = HEX_INS_M2_MPYUD_NAC_LH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6e00020) {
				// 11100110111sssssPP0ttttt001xxxxx | Rxx -= mpyu(Rs.l,Rt.h):<<1
				hi->instruction = HEX_INS_M2_MPYUD_NAC_LH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.l,%s.h):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6600000) {
				// 11100110011sssssPP0ttttt000xxxxx | Rxx -= mpyu(Rs.l,Rt.l)
				hi->instruction = HEX_INS_M2_MPYUD_NAC_LL_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe6e00000) {
				// 11100110111sssssPP0ttttt000xxxxx | Rxx -= mpyu(Rs.l,Rt.l):<<1
				hi->instruction = HEX_INS_M2_MPYUD_NAC_LL_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpyu(%s.l,%s.l):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef800020) {
				// 11101111100sssssPP0ttttt001xxxxx | Rx -= add(Rs,Rt)
				hi->instruction = HEX_INS_M2_NACCI;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02000) == 0xe2800000) {
				// 11100010100sssssPP0iiiiiiiixxxxx | Rx -= add(Rs,#Ii)
				hi->instruction = HEX_INS_M2_NACCII;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_IMM;
				hi->ops[2].op.imm = (((hi_u32)&0x1fe0) >> 5); // Ii
				if (hi->ops[2].op.imm & (1 << 7)) { // signed
					hi->ops[2].op.imm |= (0xffffffff << 7);
				}
				hex_op_extend(&(hi->ops[2]), false); // Extension possible
				if (((st32)hi->ops[2].op.imm) < 0) {
					sprintf(signed_imm, "%s%s0x%x", "##", "-", abs((st32)hi->ops[2].op.imm)); // Add a minus sign before hex number
				} else {
					sprintf(signed_imm, "%s0x%x", "##", (st32)hi->ops[2].op.imm);
				}
				sprintf(hi->mnem, "%s %s -= add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), signed_imm, hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef000060) {
				// 11101111000sssssPP0ttttt011xxxxx | Rx += sub(Rt,Rs)
				hi->instruction = HEX_INS_M2_SUBACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s += sub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8600000) {
				// 11101000011sssssPP0ttttt000ddddd | Rdd = vabsdiffh(Rtt,Rss)
				hi->instruction = HEX_INS_M2_VABSDIFFH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vabsdiffh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8200000) {
				// 11101000001sssssPP0ttttt000ddddd | Rdd = vabsdiffw(Rtt,Rss)
				hi->instruction = HEX_INS_M2_VABSDIFFW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vabsdiffw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea400080) {
				// 11101010010sssssPP0ttttt100xxxxx | Rxx += vcmpyi(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_VCMAC_S0_SAT_I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vcmpyi(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea200080) {
				// 11101010001sssssPP0ttttt100xxxxx | Rxx += vcmpyr(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_VCMAC_S0_SAT_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vcmpyr(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe84000c0) {
				// 11101000010sssssPP0ttttt110ddddd | Rdd = vcmpyi(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_VCMPY_S0_SAT_I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpyi(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe82000c0) {
				// 11101000001sssssPP0ttttt110ddddd | Rdd = vcmpyr(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_VCMPY_S0_SAT_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpyr(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8c000c0) {
				// 11101000110sssssPP0ttttt110ddddd | Rdd = vcmpyi(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_VCMPY_S1_SAT_I;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpyi(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8a000c0) {
				// 11101000101sssssPP0ttttt110ddddd | Rdd = vcmpyr(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_VCMPY_S1_SAT_R;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vcmpyr(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea000080) {
				// 11101010000sssssPP0ttttt100xxxxx | Rxx += vdmpy(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_VDMACS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vdmpy(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea800080) {
				// 11101010100sssssPP0ttttt100xxxxx | Rxx += vdmpy(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_VDMACS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vdmpy(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9000000) {
				// 11101001000sssssPP0ttttt000ddddd | Rd = vdmpy(Rss,Rtt):rnd:sat
				hi->instruction = HEX_INS_M2_VDMPYRS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vdmpy(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9800000) {
				// 11101001100sssssPP0ttttt000ddddd | Rd = vdmpy(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_VDMPYRS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vdmpy(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8000080) {
				// 11101000000sssssPP0ttttt100ddddd | Rdd = vdmpy(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_VDMPYS_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vdmpy(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8800080) {
				// 11101000100sssssPP0ttttt100ddddd | Rdd = vdmpy(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_VDMPYS_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vdmpy(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7200020) {
				// 11100111001sssssPP0ttttt001xxxxx | Rxx += vmpyh(Rs,Rt)
				hi->instruction = HEX_INS_M2_VMAC2;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += vmpyh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea200040) {
				// 11101010001sssssPP0ttttt010xxxxx | Rxx += vmpyeh(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VMAC2ES;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyeh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea0000c0) {
				// 11101010000sssssPP0ttttt110xxxxx | Rxx += vmpyeh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_VMAC2ES_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyeh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea8000c0) {
				// 11101010100sssssPP0ttttt110xxxxx | Rxx += vmpyeh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_VMAC2ES_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vmpyeh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe70000a0) {
				// 11100111000sssssPP0ttttt101xxxxx | Rxx += vmpyh(Rs,Rt):sat
				hi->instruction = HEX_INS_M2_VMAC2S_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += vmpyh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe78000a0) {
				// 11100111100sssssPP0ttttt101xxxxx | Rxx += vmpyh(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M2_VMAC2S_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += vmpyh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe76000a0) {
				// 11100111011sssssPP0ttttt101xxxxx | Rxx += vmpyhsu(Rs,Rt):sat
				hi->instruction = HEX_INS_M2_VMAC2SU_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += vmpyhsu(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7e000a0) {
				// 11100111111sssssPP0ttttt101xxxxx | Rxx += vmpyhsu(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M2_VMAC2SU_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += vmpyhsu(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe80000c0) {
				// 11101000000sssssPP0ttttt110ddddd | Rdd = vmpyeh(Rss,Rtt):sat
				hi->instruction = HEX_INS_M2_VMPY2ES_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyeh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe88000c0) {
				// 11101000100sssssPP0ttttt110ddddd | Rdd = vmpyeh(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M2_VMPY2ES_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vmpyeh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe50000a0) {
				// 11100101000sssssPP0ttttt101ddddd | Rdd = vmpyh(Rs,Rt):sat
				hi->instruction = HEX_INS_M2_VMPY2S_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vmpyh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xed2000e0) {
				// 11101101001sssssPP0ttttt111ddddd | Rd = vmpyh(Rs,Rt):rnd:sat
				hi->instruction = HEX_INS_M2_VMPY2S_S0PACK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vmpyh(%s,%s):rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe58000a0) {
				// 11100101100sssssPP0ttttt101ddddd | Rdd = vmpyh(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M2_VMPY2S_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vmpyh(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeda000e0) {
				// 11101101101sssssPP0ttttt111ddddd | Rd = vmpyh(Rs,Rt):<<1:rnd:sat
				hi->instruction = HEX_INS_M2_VMPY2S_S1PACK;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vmpyh(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe50000e0) {
				// 11100101000sssssPP0ttttt111ddddd | Rdd = vmpyhsu(Rs,Rt):sat
				hi->instruction = HEX_INS_M2_VMPY2SU_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vmpyhsu(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe58000e0) {
				// 11100101100sssssPP0ttttt111ddddd | Rdd = vmpyhsu(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M2_VMPY2SU_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vmpyhsu(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe92000e0) {
				// 11101001001sssssPP0ttttt111ddddd | Rd = vraddh(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VRADDH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vraddh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9000020) {
				// 11101001000sssssPP0ttttt001ddddd | Rd = vradduh(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VRADDUH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vradduh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea000000) {
				// 11101010000sssssPP0ttttt000xxxxx | Rxx += vrcmpyi(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VRCMACI_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrcmpyi(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea400000) {
				// 11101010010sssssPP0ttttt000xxxxx | Rxx += vrcmpyi(Rss,Rtt*)
				hi->instruction = HEX_INS_M2_VRCMACI_S0C;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrcmpyi(%s,%s*) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea000020) {
				// 11101010000sssssPP0ttttt001xxxxx | Rxx += vrcmpyr(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VRCMACR_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrcmpyr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea600020) {
				// 11101010011sssssPP0ttttt001xxxxx | Rxx += vrcmpyr(Rss,Rtt*)
				hi->instruction = HEX_INS_M2_VRCMACR_S0C;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrcmpyr(%s,%s*) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8000000) {
				// 11101000000sssssPP0ttttt000ddddd | Rdd = vrcmpyi(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VRCMPYI_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrcmpyi(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8400000) {
				// 11101000010sssssPP0ttttt000ddddd | Rdd = vrcmpyi(Rss,Rtt*)
				hi->instruction = HEX_INS_M2_VRCMPYI_S0C;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrcmpyi(%s,%s*) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8000020) {
				// 11101000000sssssPP0ttttt001ddddd | Rdd = vrcmpyr(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VRCMPYR_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrcmpyr(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8600020) {
				// 11101000011sssssPP0ttttt001ddddd | Rdd = vrcmpyr(Rss,Rtt*)
				hi->instruction = HEX_INS_M2_VRCMPYR_S0C;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrcmpyr(%s,%s*) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeaa00080) {
				// 11101010101sssssPP0ttttt100xxxxx | Rxx += vrcmpys(Rss,Rtt):<<1:sat:raw:hi
				hi->instruction = HEX_INS_M2_VRCMPYS_ACC_S1_H;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrcmpys(%s,%s):<<1:sat:raw:hi %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeae00080) {
				// 11101010111sssssPP0ttttt100xxxxx | Rxx += vrcmpys(Rss,Rtt):<<1:sat:raw:lo
				hi->instruction = HEX_INS_M2_VRCMPYS_ACC_S1_L;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrcmpys(%s,%s):<<1:sat:raw:lo %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8a00080) {
				// 11101000101sssssPP0ttttt100ddddd | Rdd = vrcmpys(Rss,Rtt):<<1:sat:raw:hi
				hi->instruction = HEX_INS_M2_VRCMPYS_S1_H;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrcmpys(%s,%s):<<1:sat:raw:hi %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8e00080) {
				// 11101000111sssssPP0ttttt100ddddd | Rdd = vrcmpys(Rss,Rtt):<<1:sat:raw:lo
				hi->instruction = HEX_INS_M2_VRCMPYS_S1_L;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrcmpys(%s,%s):<<1:sat:raw:lo %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9a000c0) {
				// 11101001101sssssPP0ttttt110ddddd | Rd = vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi
				hi->instruction = HEX_INS_M2_VRCMPYS_S1RP_H;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrcmpys(%s,%s):<<1:rnd:sat:raw:hi %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9a000e0) {
				// 11101001101sssssPP0ttttt111ddddd | Rd = vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo
				hi->instruction = HEX_INS_M2_VRCMPYS_S1RP_L;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrcmpys(%s,%s):<<1:rnd:sat:raw:lo %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea000040) {
				// 11101010000sssssPP0ttttt010xxxxx | Rxx += vrmpyh(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VRMAC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrmpyh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8000040) {
				// 11101000000sssssPP0ttttt010ddddd | Rdd = vrmpyh(Rss,Rtt)
				hi->instruction = HEX_INS_M2_VRMPY_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrmpyh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef800060) {
				// 11101111100sssssPP0ttttt011xxxxx | Rx ^= xor(Rs,Rt)
				hi->instruction = HEX_INS_M2_XOR_XACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef400000) {
				// 11101111010sssssPP0ttttt000xxxxx | Rx &= and(Rs,Rt)
				hi->instruction = HEX_INS_M4_AND_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef200020) {
				// 11101111001sssssPP0ttttt001xxxxx | Rx &= and(Rs,~Rt)
				hi->instruction = HEX_INS_M4_AND_ANDN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= and(%s,~%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef400020) {
				// 11101111010sssssPP0ttttt001xxxxx | Rx &= or(Rs,Rt)
				hi->instruction = HEX_INS_M4_AND_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef400040) {
				// 11101111010sssssPP0ttttt010xxxxx | Rx &= xor(Rs,Rt)
				hi->instruction = HEX_INS_M4_AND_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s &= xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef600000) {
				// 11101111011sssssPP0ttttt000xxxxx | Rx += mpy(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M4_MAC_UP_S1_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += mpy(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe3000000) {
				// 11100011000sssssPP0yyyyy000uuuuu | Ry = add(Ru,mpyi(Ryin,Rs))
				hi->instruction = HEX_INS_M4_MPYRR_ADDR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f00) >> 8); // Ry32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Ru32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Ry32in
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = add(%s,mpyi(%sin,%s)) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef600020) {
				// 11101111011sssssPP0ttttt001xxxxx | Rx -= mpy(Rs,Rt):<<1:sat
				hi->instruction = HEX_INS_M4_NAC_UP_S1_SAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s -= mpy(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef400060) {
				// 11101111010sssssPP0ttttt011xxxxx | Rx |= and(Rs,Rt)
				hi->instruction = HEX_INS_M4_OR_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef200000) {
				// 11101111001sssssPP0ttttt000xxxxx | Rx |= and(Rs,~Rt)
				hi->instruction = HEX_INS_M4_OR_ANDN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= and(%s,~%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xefc00000) {
				// 11101111110sssssPP0ttttt000xxxxx | Rx |= or(Rs,Rt)
				hi->instruction = HEX_INS_M4_OR_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xefc00020) {
				// 11101111110sssssPP0ttttt001xxxxx | Rx |= xor(Rs,Rt)
				hi->instruction = HEX_INS_M4_OR_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s |= xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe54000e0) {
				// 11100101010sssssPP0ttttt111ddddd | Rdd = pmpyw(Rs,Rt)
				hi->instruction = HEX_INS_M4_PMPYW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = pmpyw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe72000e0) {
				// 11100111001sssssPP0ttttt111xxxxx | Rxx ^= pmpyw(Rs,Rt)
				hi->instruction = HEX_INS_M4_PMPYW_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= pmpyw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe5c000e0) {
				// 11100101110sssssPP0ttttt111ddddd | Rdd = vpmpyh(Rs,Rt)
				hi->instruction = HEX_INS_M4_VPMPYH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vpmpyh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7a000e0) {
				// 11100111101sssssPP0ttttt111xxxxx | Rxx ^= vpmpyh(Rs,Rt)
				hi->instruction = HEX_INS_M4_VPMPYH_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= vpmpyh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea2000c0) {
				// 11101010001sssssPP0ttttt110xxxxx | Rxx += vrmpyweh(Rss,Rtt)
				hi->instruction = HEX_INS_M4_VRMPYEH_ACC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrmpyweh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeaa000c0) {
				// 11101010101sssssPP0ttttt110xxxxx | Rxx += vrmpyweh(Rss,Rtt):<<1
				hi->instruction = HEX_INS_M4_VRMPYEH_ACC_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrmpyweh(%s,%s):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8400080) {
				// 11101000010sssssPP0ttttt100ddddd | Rdd = vrmpyweh(Rss,Rtt)
				hi->instruction = HEX_INS_M4_VRMPYEH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrmpyweh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8c00080) {
				// 11101000110sssssPP0ttttt100ddddd | Rdd = vrmpyweh(Rss,Rtt):<<1
				hi->instruction = HEX_INS_M4_VRMPYEH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrmpyweh(%s,%s):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea6000c0) {
				// 11101010011sssssPP0ttttt110xxxxx | Rxx += vrmpywoh(Rss,Rtt)
				hi->instruction = HEX_INS_M4_VRMPYOH_ACC_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrmpywoh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeae000c0) {
				// 11101010111sssssPP0ttttt110xxxxx | Rxx += vrmpywoh(Rss,Rtt):<<1
				hi->instruction = HEX_INS_M4_VRMPYOH_ACC_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrmpywoh(%s,%s):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8200040) {
				// 11101000001sssssPP0ttttt010ddddd | Rdd = vrmpywoh(Rss,Rtt)
				hi->instruction = HEX_INS_M4_VRMPYOH_S0;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrmpywoh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8a00040) {
				// 11101000101sssssPP0ttttt010ddddd | Rdd = vrmpywoh(Rss,Rtt):<<1
				hi->instruction = HEX_INS_M4_VRMPYOH_S1;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrmpywoh(%s,%s):<<1 %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xefc00040) {
				// 11101111110sssssPP0ttttt010xxxxx | Rx ^= and(Rs,Rt)
				hi->instruction = HEX_INS_M4_XOR_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xef200040) {
				// 11101111001sssssPP0ttttt010xxxxx | Rx ^= and(Rs,~Rt)
				hi->instruction = HEX_INS_M4_XOR_ANDN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= and(%s,~%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xefc00060) {
				// 11101111110sssssPP0ttttt011xxxxx | Rx ^= or(Rs,Rt)
				hi->instruction = HEX_INS_M4_XOR_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s ^= or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea200020) {
				// 11101010001sssssPP0ttttt001xxxxx | Rxx += vdmpybsu(Rss,Rtt):sat
				hi->instruction = HEX_INS_M5_VDMACBSU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vdmpybsu(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8a00020) {
				// 11101000101sssssPP0ttttt001ddddd | Rdd = vdmpybsu(Rss,Rtt):sat
				hi->instruction = HEX_INS_M5_VDMPYBSU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vdmpybsu(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7c00020) {
				// 11100111110sssssPP0ttttt001xxxxx | Rxx += vmpybsu(Rs,Rt)
				hi->instruction = HEX_INS_M5_VMACBSU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += vmpybsu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe7800020) {
				// 11100111100sssssPP0ttttt001xxxxx | Rxx += vmpybu(Rs,Rt)
				hi->instruction = HEX_INS_M5_VMACBUU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s += vmpybu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe5400020) {
				// 11100101010sssssPP0ttttt001ddddd | Rdd = vmpybsu(Rs,Rt)
				hi->instruction = HEX_INS_M5_VMPYBSU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vmpybsu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe5800020) {
				// 11100101100sssssPP0ttttt001ddddd | Rdd = vmpybu(Rs,Rt)
				hi->instruction = HEX_INS_M5_VMPYBUU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vmpybu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeac00020) {
				// 11101010110sssssPP0ttttt001xxxxx | Rxx += vrmpybsu(Rss,Rtt)
				hi->instruction = HEX_INS_M5_VRMACBSU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrmpybsu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea800020) {
				// 11101010100sssssPP0ttttt001xxxxx | Rxx += vrmpybu(Rss,Rtt)
				hi->instruction = HEX_INS_M5_VRMACBUU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += vrmpybu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8c00020) {
				// 11101000110sssssPP0ttttt001ddddd | Rdd = vrmpybsu(Rss,Rtt)
				hi->instruction = HEX_INS_M5_VRMPYBSU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrmpybsu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8800020) {
				// 11101000100sssssPP0ttttt001ddddd | Rdd = vrmpybu(Rss,Rtt)
				hi->instruction = HEX_INS_M5_VRMPYBUU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = vrmpybu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8e00000) {
				// 11101000111sssssPP0ttttt000ddddd | Rdd = vabsdiffb(Rtt,Rss)
				hi->instruction = HEX_INS_M6_VABSDIFFB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vabsdiffb(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8a00000) {
				// 11101000101sssssPP0ttttt000ddddd | Rdd = vabsdiffub(Rtt,Rss)
				hi->instruction = HEX_INS_M6_VABSDIFFUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				sprintf(hi->mnem, "%s %s = vabsdiffub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8600040) {
				// 11101000011sssssPP0ttttt010ddddd | Rdd = cmpyiw(Rss,Rtt)
				hi->instruction = HEX_INS_M7_DCMPYIW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyiw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea600040) {
				// 11101010011sssssPP0ttttt010xxxxx | Rxx += cmpyiw(Rss,Rtt)
				hi->instruction = HEX_INS_M7_DCMPYIW_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += cmpyiw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8e00040) {
				// 11101000111sssssPP0ttttt010ddddd | Rdd = cmpyiw(Rss,Rtt*)
				hi->instruction = HEX_INS_M7_DCMPYIWC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyiw(%s,%s*) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea4000c0) {
				// 11101010010sssssPP0ttttt110xxxxx | Rxx += cmpyiw(Rss,Rtt*)
				hi->instruction = HEX_INS_M7_DCMPYIWC_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += cmpyiw(%s,%s*) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8800040) {
				// 11101000100sssssPP0ttttt010ddddd | Rdd = cmpyrw(Rss,Rtt)
				hi->instruction = HEX_INS_M7_DCMPYRW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyrw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xea800040) {
				// 11101010100sssssPP0ttttt010xxxxx | Rxx += cmpyrw(Rss,Rtt)
				hi->instruction = HEX_INS_M7_DCMPYRW_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += cmpyrw(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe8c00040) {
				// 11101000110sssssPP0ttttt010ddddd | Rdd = cmpyrw(Rss,Rtt*)
				hi->instruction = HEX_INS_M7_DCMPYRWC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyrw(%s,%s*) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xeac00040) {
				// 11101010110sssssPP0ttttt010xxxxx | Rxx += cmpyrw(Rss,Rtt*)
				hi->instruction = HEX_INS_M7_DCMPYRWC_ACC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rxx32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s += cmpyrw(%s,%s*) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9200000) {
				// 11101001001sssssPP0ttttt000ddddd | Rd = cmpyiw(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M7_WCMPYIW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyiw(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9a00000) {
				// 11101001101sssssPP0ttttt000ddddd | Rd = cmpyiw(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M7_WCMPYIW_RND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyiw(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9000080) {
				// 11101001000sssssPP0ttttt100ddddd | Rd = cmpyiw(Rss,Rtt*):<<1:sat
				hi->instruction = HEX_INS_M7_WCMPYIWC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyiw(%s,%s*):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9800080) {
				// 11101001100sssssPP0ttttt100ddddd | Rd = cmpyiw(Rss,Rtt*):<<1:rnd:sat
				hi->instruction = HEX_INS_M7_WCMPYIWC_RND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyiw(%s,%s*):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9400000) {
				// 11101001010sssssPP0ttttt000ddddd | Rd = cmpyrw(Rss,Rtt):<<1:sat
				hi->instruction = HEX_INS_M7_WCMPYRW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyrw(%s,%s):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9c00000) {
				// 11101001110sssssPP0ttttt000ddddd | Rd = cmpyrw(Rss,Rtt):<<1:rnd:sat
				hi->instruction = HEX_INS_M7_WCMPYRW_RND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyrw(%s,%s):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9600000) {
				// 11101001011sssssPP0ttttt000ddddd | Rd = cmpyrw(Rss,Rtt*):<<1:sat
				hi->instruction = HEX_INS_M7_WCMPYRWC;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyrw(%s,%s*):<<1:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xe9e00000) {
				// 11101001111sssssPP0ttttt000ddddd | Rd = cmpyrw(Rss,Rtt*):<<1:rnd:sat
				hi->instruction = HEX_INS_M7_WCMPYRWC_RND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rss32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rtt32
				sprintf(hi->mnem, "%s %s = cmpyrw(%s,%s*):<<1:rnd:sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_double_regs(hi->ops[1].op.reg), hex_get_double_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		case 0xf:
			if ((hi_u32 & 0xffe020e0) == 0xf3000000) {
				// 11110011000sssssPP0ttttt000ddddd | Rd = add(Rs,Rt)
				hi->instruction = HEX_INS_A2_ADD;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf6400000) {
				// 11110110010sssssPP0ttttt000ddddd | Rd = add(Rs,Rt):sat
				hi->instruction = HEX_INS_A2_ADDSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = add(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf1000000) {
				// 11110001000sssssPP0ttttt000ddddd | Rd = and(Rs,Rt)
				hi->instruction = HEX_INS_A2_AND;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf3800000) {
				// 11110011100sssssPP0ttttt000ddddd | Rd = combine(Rt.h,Rs.h)
				hi->instruction = HEX_INS_A2_COMBINE_HH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = combine(%s.h,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf3a00000) {
				// 11110011101sssssPP0ttttt000ddddd | Rd = combine(Rt.h,Rs.l)
				hi->instruction = HEX_INS_A2_COMBINE_HL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = combine(%s.h,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf3c00000) {
				// 11110011110sssssPP0ttttt000ddddd | Rd = combine(Rt.l,Rs.h)
				hi->instruction = HEX_INS_A2_COMBINE_LH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = combine(%s.l,%s.h) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf3e00000) {
				// 11110011111sssssPP0ttttt000ddddd | Rd = combine(Rt.l,Rs.l)
				hi->instruction = HEX_INS_A2_COMBINE_LL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = combine(%s.l,%s.l) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf5000000) {
				// 11110101000sssssPP0ttttt000ddddd | Rdd = combine(Rs,Rt)
				hi->instruction = HEX_INS_A2_COMBINEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = combine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf1200000) {
				// 11110001001sssssPP0ttttt000ddddd | Rd = or(Rs,Rt)
				hi->instruction = HEX_INS_A2_OR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfb000080) {
				// 11111011000sssssPP0ttttt1uuddddd | if (!Pu) Rd = add(Rs,Rt)
				hi->instruction = HEX_INS_A2_PADDF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfb002080) {
				// 11111011000sssssPP1ttttt1uuddddd | if (!Pu.new) Rd = add(Rs,Rt)
				hi->instruction = HEX_INS_A2_PADDFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfb000000) {
				// 11111011000sssssPP0ttttt0uuddddd | if (Pu) Rd = add(Rs,Rt)
				hi->instruction = HEX_INS_A2_PADDT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfb002000) {
				// 11111011000sssssPP1ttttt0uuddddd | if (Pu.new) Rd = add(Rs,Rt)
				hi->instruction = HEX_INS_A2_PADDTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) %s = add(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9000080) {
				// 11111001000sssssPP0ttttt1uuddddd | if (!Pu) Rd = and(Rs,Rt)
				hi->instruction = HEX_INS_A2_PANDF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9002080) {
				// 11111001000sssssPP1ttttt1uuddddd | if (!Pu.new) Rd = and(Rs,Rt)
				hi->instruction = HEX_INS_A2_PANDFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9000000) {
				// 11111001000sssssPP0ttttt0uuddddd | if (Pu) Rd = and(Rs,Rt)
				hi->instruction = HEX_INS_A2_PANDT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9002000) {
				// 11111001000sssssPP1ttttt0uuddddd | if (Pu.new) Rd = and(Rs,Rt)
				hi->instruction = HEX_INS_A2_PANDTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) %s = and(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9200080) {
				// 11111001001sssssPP0ttttt1uuddddd | if (!Pu) Rd = or(Rs,Rt)
				hi->instruction = HEX_INS_A2_PORF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9202080) {
				// 11111001001sssssPP1ttttt1uuddddd | if (!Pu.new) Rd = or(Rs,Rt)
				hi->instruction = HEX_INS_A2_PORFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9200000) {
				// 11111001001sssssPP0ttttt0uuddddd | if (Pu) Rd = or(Rs,Rt)
				hi->instruction = HEX_INS_A2_PORT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9202000) {
				// 11111001001sssssPP1ttttt0uuddddd | if (Pu.new) Rd = or(Rs,Rt)
				hi->instruction = HEX_INS_A2_PORTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) %s = or(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfb200080) {
				// 11111011001sssssPP0ttttt1uuddddd | if (!Pu) Rd = sub(Rt,Rs)
				hi->instruction = HEX_INS_A2_PSUBF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s) %s = sub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfb202080) {
				// 11111011001sssssPP1ttttt1uuddddd | if (!Pu.new) Rd = sub(Rt,Rs)
				hi->instruction = HEX_INS_A2_PSUBFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (!%s.new) %s = sub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfb200000) {
				// 11111011001sssssPP0ttttt0uuddddd | if (Pu) Rd = sub(Rt,Rs)
				hi->instruction = HEX_INS_A2_PSUBT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s) %s = sub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfb202000) {
				// 11111011001sssssPP1ttttt0uuddddd | if (Pu.new) Rd = sub(Rt,Rs)
				hi->instruction = HEX_INS_A2_PSUBTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s if (%s.new) %s = sub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9600080) {
				// 11111001011sssssPP0ttttt1uuddddd | if (!Pu) Rd = xor(Rs,Rt)
				hi->instruction = HEX_INS_A2_PXORF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) %s = xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9602080) {
				// 11111001011sssssPP1ttttt1uuddddd | if (!Pu.new) Rd = xor(Rs,Rt)
				hi->instruction = HEX_INS_A2_PXORFNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) %s = xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9600000) {
				// 11111001011sssssPP0ttttt0uuddddd | if (Pu) Rd = xor(Rs,Rt)
				hi->instruction = HEX_INS_A2_PXORT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) %s = xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf9602000) {
				// 11111001011sssssPP1ttttt0uuddddd | if (Pu.new) Rd = xor(Rs,Rt)
				hi->instruction = HEX_INS_A2_PXORTNEW;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) %s = xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf3200000) {
				// 11110011001sssssPP0ttttt000ddddd | Rd = sub(Rt,Rs)
				hi->instruction = HEX_INS_A2_SUB;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf6c00000) {
				// 11110110110sssssPP0ttttt000ddddd | Rd = sub(Rt,Rs):sat
				hi->instruction = HEX_INS_A2_SUBSAT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = sub(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf6000000) {
				// 11110110000sssssPP0ttttt000ddddd | Rd = vaddh(Rs,Rt)
				hi->instruction = HEX_INS_A2_SVADDH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vaddh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf6200000) {
				// 11110110001sssssPP0ttttt000ddddd | Rd = vaddh(Rs,Rt):sat
				hi->instruction = HEX_INS_A2_SVADDHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vaddh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf6600000) {
				// 11110110011sssssPP0ttttt000ddddd | Rd = vadduh(Rs,Rt):sat
				hi->instruction = HEX_INS_A2_SVADDUHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vadduh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf7000000) {
				// 11110111000sssssPP0ttttt000ddddd | Rd = vavgh(Rs,Rt)
				hi->instruction = HEX_INS_A2_SVAVGH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vavgh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf7200000) {
				// 11110111001sssssPP0ttttt000ddddd | Rd = vavgh(Rs,Rt):rnd
				hi->instruction = HEX_INS_A2_SVAVGHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = vavgh(%s,%s):rnd %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf7600000) {
				// 11110111011sssssPP0ttttt000ddddd | Rd = vnavgh(Rt,Rs)
				hi->instruction = HEX_INS_A2_SVNAVGH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vnavgh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf6800000) {
				// 11110110100sssssPP0ttttt000ddddd | Rd = vsubh(Rt,Rs)
				hi->instruction = HEX_INS_A2_SVSUBH;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsubh(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf6a00000) {
				// 11110110101sssssPP0ttttt000ddddd | Rd = vsubh(Rt,Rs):sat
				hi->instruction = HEX_INS_A2_SVSUBHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsubh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf6e00000) {
				// 11110110111sssssPP0ttttt000ddddd | Rd = vsubuh(Rt,Rs):sat
				hi->instruction = HEX_INS_A2_SVSUBUHS;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = vsubuh(%s,%s):sat %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf1600000) {
				// 11110001011sssssPP0ttttt000ddddd | Rd = xor(Rs,Rt)
				hi->instruction = HEX_INS_A2_XOR;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = xor(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf1800000) {
				// 11110001100sssssPP0ttttt000ddddd | Rd = and(Rt,~Rs)
				hi->instruction = HEX_INS_A4_ANDN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = and(%s,~%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf1a00000) {
				// 11110001101sssssPP0ttttt000ddddd | Rd = or(Rt,~Rs)
				hi->instruction = HEX_INS_A4_ORN;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				sprintf(hi->mnem, "%s %s = or(%s,~%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf3400000) {
				// 11110011010sssssPP0ttttt000ddddd | Rd = cmp.eq(Rs,Rt)
				hi->instruction = HEX_INS_A4_RCMPEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf3600000) {
				// 11110011011sssssPP0ttttt000ddddd | Rd = !cmp.eq(Rs,Rt)
				hi->instruction = HEX_INS_A4_RCMPNEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = !cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfd000080) {
				// 11111101000sssssPP0ttttt1uuddddd | if (!Pu) Rdd = combine(Rs,Rt)
				hi->instruction = HEX_INS_C2_CCOMBINEWF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s) %s = combine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfd002080) {
				// 11111101000sssssPP1ttttt1uuddddd | if (!Pu.new) Rdd = combine(Rs,Rt)
				hi->instruction = HEX_INS_C2_CCOMBINEWNEWF;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (!%s.new) %s = combine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfd002000) {
				// 11111101000sssssPP1ttttt0uuddddd | if (Pu.new) Rdd = combine(Rs,Rt)
				hi->instruction = HEX_INS_C2_CCOMBINEWNEWT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s.new) %s = combine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xfd000000) {
				// 11111101000sssssPP0ttttt0uuddddd | if (Pu) Rdd = combine(Rs,Rt)
				hi->instruction = HEX_INS_C2_CCOMBINEWT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s if (%s) %s = combine(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[1].op.reg), hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xf2000000) {
				// 11110010000sssssPP0ttttt000000dd | Pd = cmp.eq(Rs,Rt)
				hi->instruction = HEX_INS_C2_CMPEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xf2400000) {
				// 11110010010sssssPP0ttttt000000dd | Pd = cmp.gt(Rs,Rt)
				hi->instruction = HEX_INS_C2_CMPGT;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmp.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xf2600000) {
				// 11110010011sssssPP0ttttt000000dd | Pd = cmp.gtu(Rs,Rt)
				hi->instruction = HEX_INS_C2_CMPGTU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = cmp.gtu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe02080) == 0xf4000000) {
				// 11110100000sssssPP0ttttt0uuddddd | Rd = mux(Pu,Rs,Rt)
				hi->instruction = HEX_INS_C2_MUX;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 4;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x60) >> 5); // Pu4
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[3].type = HEX_OP_TYPE_REG;
				hi->ops[3].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = mux(%s,%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_int_regs(hi->ops[0].op.reg), hex_get_pred_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hex_get_int_regs(hi->ops[3].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xf2400010) {
				// 11110010010sssssPP0ttttt000100dd | Pd = !cmp.gt(Rs,Rt)
				hi->instruction = HEX_INS_C4_CMPLTE;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = !cmp.gt(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xf2600010) {
				// 11110010011sssssPP0ttttt000100dd | Pd = !cmp.gtu(Rs,Rt)
				hi->instruction = HEX_INS_C4_CMPLTEU;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = !cmp.gtu(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020fc) == 0xf2000010) {
				// 11110010000sssssPP0ttttt000100dd | Pd = !cmp.eq(Rs,Rt)
				hi->instruction = HEX_INS_C4_CMPNEQ;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x3) >> 0); // Pd4
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = !cmp.eq(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_pred_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			if ((hi_u32 & 0xffe020e0) == 0xf5800000) {
				// 11110101100sssssPP0ttttt000ddddd | Rdd = packhl(Rs,Rt)
				hi->instruction = HEX_INS_S2_PACKHL;
				hi->pkt_info.parse_bits = ((hi_u32)&0xc000) >> 14;
				hi->pkt_info.loop_attr = HEX_NO_LOOP;
				hex_set_pkt_info(&(hi->pkt_info));
				hi->op_count = 3;
				hi->ops[0].type = HEX_OP_TYPE_REG;
				hi->ops[0].op.reg = (((hi_u32)&0x1f) >> 0); // Rdd32
				hi->ops[1].type = HEX_OP_TYPE_REG;
				hi->ops[1].op.reg = (((hi_u32)&0x1f0000) >> 16); // Rs32
				hi->ops[2].type = HEX_OP_TYPE_REG;
				hi->ops[2].op.reg = (((hi_u32)&0x1f00) >> 8); // Rt32
				sprintf(hi->mnem, "%s %s = packhl(%s,%s) %s", hi->pkt_info.syntax_prefix, hex_get_double_regs(hi->ops[0].op.reg), hex_get_int_regs(hi->ops[1].op.reg), hex_get_int_regs(hi->ops[2].op.reg), hi->pkt_info.syntax_postfix);
				break;
			}
			break;
		}
	}
	return 4;
}