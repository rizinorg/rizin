add=add immediate to register
addf.s=add floating short
addi=add immediate
adf=add on condition flag
and=and
andbsu=and bit string upward
andi=and immediate
andnbsu=and not bit string upward
bc=branch on condition
be=branch if equal
be=branch if zero/equal
bge=branch if greater/equal (signed)
bgt=branch if greater than (signed)
bh=branch if higher (unsigned)
bl=branch if carry/less than
ble=branch if less/equal (signed)
blt=branch if less than (signed)
bn=branch if negative
bne=branch if not zero/equal
bnh=branch if not higher (unsigned)
bnl=branch if not carry/less than
bnv=branch if not overflow
bp=branch if positive
br=branch always
bsh=byte swap halfword
bsw=byte swap word
bv=branch if overflow
callt=call with table lookup
caxi=compare and exchange for interlock
caxi=compare and exchange interlocked
cli=clear interrupt disable flag
clr1=clear bit
cmov=conditional move
cmp=compare two registers and update flags
cmpf.s=compare floating short
ctret=return from callt
cvt.sw=convert floating short to word
cvt.ws=convert word to floating short
di=disable interrupts
dispose=function dispose
div=divide signed
divf.s=divide floating short
divh=divide half word
divq=divide quad word
divu=divide unsigned
ei=enable interrupts
eiret=return from trap or interrupt
feret=return from trap or interrupt
fetrap=software trap
halt=halt cpu
hsh=halfword swap half word
hsw=halfword swap word
in.b=input byte
in.h=input halfword
in.w=input word
jal=jump and link
jarl=jump and register link
jmp=jump register
jr=jump relative
ld.b=load signed byte
ld.bu=load unsigned byte
ld.h=load halfword
ld.hu=load unsigned half word
ld.w=load word
ldsr=load into system register
mac=multiply and add word
mov=move
movbsu=move bit string upward
movea=add immediate
movhi=add high halfword
mpyhw=multiply halfword signed
mul=multiply signed
mulf.s=multiply floating short
mulu=multiply unsigned
nop1=do nothing once
nop=do nothing
not1=bitwise NOT given bit
not=not
notbsu=not bit string upward
or=bitwise or
orbsu=or bit string upward
ori=logical OR
ori=or immediate
ornbsu=or not bit string immediate
out.b=output byte
out.h=output halfword
out.w=output word
prepare=create stack frame
reti=return from trap or interrupt
rev=reverse bits
rie=reserved instruction exception
sar=shift arithmetic right
sasf=shift and flag condition
satadd=saturated addition
satsub=saturated substraction
satsubi=saturated substrcation
satsubr=saturated reverse substract
sbf=conditional substraction
sch0bsd=search bit 0 downward
sch0bsu=search bit 0 upward
sch0l=search zero from left
sch0r=search zero from right
sch1bsd=search bit 1 downward
sch1bsu=search bit 1 upward
sch1l=search one from left
sch1r=search one from right
sei=set interrupt disable flag
set1=set bit
setf=set flag condition
shl=shift left
shr=shift right
sst.b=store byte
sst.h=store half word
sst.w=store word
st.b=store byte
st.h=store halfword
st.w=store word
stsr=store from system register
sub=subtract
subf.s=subtract floating short
subr=reverse substraction
switch=jump with table lookup
sxb=sign extend byte
sxh=sign extend halfword
synce=synchronize exceptions
syncm=synchronize memory
syncp=synchronize pipeline
syscall=system call
trap=trap
trap=trap
trnc.sw=truncate floating short to word
tst1=test bit
tst=test registers
xb=swap low bytes
xh=swap halfwords
xor=exclusive bitwise OR on registers
xorbsu=exclusive or bit string upward
xori=exclusive or immediate
xornbsu=exclusive or not bit string upward
zxb=zero extend byte
zxh=zero extend half
