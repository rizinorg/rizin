adc=add with carry
add=add two values
adds=add two values and update flags
addeq=add two values if Z set (equal)
addne=add two values if Z clear (not equal)
and=logical AND
ands=logical AND that updates flags
andeq=logical AND if Z set (equal)
andne=logical AND if Z clear (not equal)
b=branches the program counter to dst (pc aka r15)
bcc=branch if C clear (no carry)
bcs=branch if C set (carry)
beq=branches if equal (see 'b') Z is set
bge=branch if N clear and V clear
bgt=branch if Z, N and V clear
bhi=branch if C set and Z clear
bl=branches and link, similar to call in i386, set lr(r14) = pc, changes pc (r15) )
ble=branch if (Z || (N && V)) or !N && V) or !N && V
bls=branch if C clear or Z set
blt=branch if N clear and V set
blx=branch link and optionally exchange to Thumb
bmi=branch if N set
bne=branch if Z clear (not equal)
bpl=branch if N clear
bvc=branch if V clear
bvs=branch if V set
bx=branches and exchanges cpu mode to 16 bits (thumb mode)
bxj=branches and exchanges cpu mode to Jazzele (jumps to a bytecode vector)
cdp=coprocessor data operations
cmn=compare negated
cmp=compare
cmp=compares two registers
cps=change processor state
eor=logical exclusive OR (XOR)
eors=logical exclusive OR (XOR) and update flags
eoreq=logical exclusive OR (XOR) if Z set (equal)
eorne=logical exclusive OR (XOR) if Z clear (not equal)
flt=armfpu: convert int to float: flt 
ldc=load from memory to coprocessor
ldf=armfpu: load float value pointed by reg+(offset): ldf f0, [r0,#off]
ldm.w=load multiple words from memory into registers
ldmda=decrement after
ldmdb=decrement before
ldmia=incrememnt after
ldmib=increment before
ldr=load from memory to register
ldraa=load from memory to register authenticanting the pointer using A key
ldrab=load from memory to register authenticanting the pointer using B key
ldr.w=load from memory to register
ldrh=load half word (16bit) from memory to register
ldrb=load byte from memory to register
ldrb.w=load from memory to register
ldreq=load from memory to register if Z set (equal)
ldrne=load from memory to register if Z clear (not equal)
mcr=move to coprocessor from ARM register
mcrr=move to coprocessor from two ARM register
mov.w=move 3byte immediate into register
mov=move value between registers
movs=move immediate into register and update flags
asr=arithmetic shift right
asrs=arithmetic shift right and update flags
movt=write 16 bit value on top of halfword
movw=write 16 bit value on lower bits
orr=logical inclusive OR
orrs=logical inclusive OR and update flags
orreq=logical inclusive OR if Z set (equal)
orrne=logical inclusive OR if Z clear (not equal)
rfe=return from exception (loads pc+cpsr)
rsb=reverse substract
rsc=reverse substract with carry
sbc=substract with carry
sbfx=signed bit field extract
srs=store return state
stc=store coprocessor register
stc=store from coprocessor to memory
stf=armfpu: store float value pointed by reg+(offset): ldf [r0,#off]
str=store register into memory
strb=store byte value in register into memory
strb.w=store byte value in register into memory
strh=store byte value in register into memory
strh.w=store byte value in register into memory
strd=store floating point value in memory
streq=store register into memory if Z set (equal)
strne=store register into memory if Z clear (not equal)
sub=substract two values
subs=substract two values and update flags
lsr=logical shift right
lsl=logical shift left
lsrs=logical shift right and update flags
lsls=logical shift left and update flags
subeq=substract two values if Z set (equal)
subne=substract two values if Z clear (not equal)
svc=supervisor call
teq=test equivalence
tst.w=logical AND register value with 12-bit immediate value
tst=test
ubfx=unsigned bit field extract
uxtab16=zero extend bytes to halfwords add halfwords
uxtab=zero extend byte to word, add
vadd=vector add
vsri=vector shift right and insert
wfs=armfpu: write fp status register. wfs r0
cpsie=like msr, but only enable interrupts (i or f)
cpsid=like msr, but only disable interrupts (i or f)
uxth=extracts bits[15:0] and zero extends to 32 bits.
sxth=extracts bits[15:0] and sign extends to 32 bits.
uxtb=extracts bits[7:0] and zero extends to 32 bits.
sxtb=extracts bits[7:0] and sign extends to 32 bits.
sxtw=signed extend word
pop=load N elements from stack into given registers
vldmia=vector load memory into paired registers
pop.w=load N words from stack into registers
it=if then
bic=logical bit clear
bics=Bitwise bit clear (shifted register), setting the condition flags.
bics.w=word bitwise bit clear and update flags
udiv=unsigned division
sdiv=signed division
mul=multiply
mla=multiply and accumulate
mls=multiply and substract
rsbs=subtracts the value from zero, producing the arithmetic negative of the value, and updates flags
rsbs.w=substract the negative value
uxtab=zero extend Byte and Add. Extends an 8-bit value to a 32-bit value.
uxtb.w=zero textend word and add, extend to 32bit value
wfi=wait for interrupt
wfe=wait for event
yield=alias for hint instructrion
dc=data cache operation (alias of sys)
ic=instruction cache operation (alias of sys)
dsb=data synchronization barrier.
isb=instruction synchronization barrier.
movz=move shifted 16-bit immediate to register.
hlt=external debug breakpoint.
hvc=hypervisor call
eret=return from exception
paciasp=function prelude for pointer authentication using A key
pacibsp=function prelude for pointer authentication using B key
autiasp=authenticate return pointer before returning from function using A key
autibsp=authenticate return pointer before returning from function using B key
xpaci=strip pac from instruction pointer
xpacd=strip pac from data pointer
retaa=return with authenticated pointer using A key
retab=return with authenticated pointer using B key
xpaclri=system strip pointer authentication
blraa=brank and link with pointer authentication
blraaz=variants of blraa
blrab=variants of blraa
blrabz=variants of blraa
braa=branch with pointer authentication using A key
braaz=variant of braa
brab=branch with pointer authentication using B key
brabz=variant of brabz
stadd=atomic add word (arm v8.1)
staddl=atomic add dword (arm v8.1)
cbnz=compare and branch on non-zero
cbz=compare and branch on zero
adcs=add with carry and update flags
ldm=load to multiple registers from memory
stm=store multiple registers to memory
addlo=add if C is clear (no carry)
mvn=move bitwise NOT
mvns=move bitwise NOT and update flags
blo=variant of bcc
bhs=variant of bcs