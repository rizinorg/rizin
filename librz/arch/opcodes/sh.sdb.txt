add=add binary
addc=add with carry
addv=add with (v flag) overflow check
and.b=bitise and (byte)
and=bitwise and
bf.s=branch if false with delay slot
bf/s=branch if false with delay slot
bf=branch if false
bra=branch
braf=branch far
bsr=branch to subroutine
bsrf=branch to subroutine far
bt.s=branch if true with delay slot
bt/s=branch if true with delay slot
bt=branch if true
clrmac=clear mac register
clrs=clear s bit
clrt=clear t bit
cmp/eq=compare rm,rn : set t if rn == rm
cmp/ge=compare rm,rn : set t if rn >= rm (signed)
cmp/gt=compare rm,rn : set t if rn > rm (signed)
cmp/hi=compare rm,rn : set t if  rn > rm (unsigned)
cmp/hs=compare rm,rn : set t if  rn >= rm (unsigned)
cmp/pl=set t if rn > 0
cmp/pz=set t if rn >= 0
cmp/str=compare rm,rn : set t if any bytes are equal
div0s=divide (step 0) as signed
div0u=divide (step 0) as unsigned
div1=divide 1 step
dmuls.l=double-length multiply as signed
dmulu.l=double-length multiply as unsigned
dt=decrement and test
exts.b=extend byte as signed
exts.w=extend word as signed
extu.b=extend byte as unsigned
extu.w=extend word as unsigned
fabs=floating-point absolute value
fadd=floating-point add
fcmp/eq=compare (float) frm, frn: set t if frm == frn
fcmp/gt=compare (float) frm, frn: set t if frn > frm
fcnvds=floating-point convert double to single precision
fcnvsd=floating-point convert single to double precision
fdiv=floating-point divide
fipr=floating-point inner product
fldi0=floating-point load immediate 0.0
fldi1=floating-point loa immediate 1.0
flds=floating-point load to system register
float=floating-point convert from integer
fmac=floating-point multiply and accumulate
fmov.s=floating-point move
fmov=floating-point move
fmul=floating-point multiply
fneg=floating-point negate value
frchg=fr-bit change
fschg=sz-bit change
fsqrt=floating-point square root
fsts=floating-point store system register
fsub=floating-point subtract
ftrc=floating-point truncate and convert to integer
ftrv=floating-point transform vector
jmp=jump
jsr=jump to subroutine
ldc.l=load to control register
ldc=load to control register
lds.l=load to fpu/system register
lds=load to fpu/system register
ldtlb=load pteh/ptel/ptea to tlb
mac.l=multiply and accumulate long
mac.w=multiply and accumulate word
mov.b=move byte
mov.l=move longword
mov.w=move word
mov=move data
mova=move effective address
movca.l=move with cache block allocation
movt=move t bit to rn
mul.l=multiply long
muls.w=multiply as signed word
mulu.w=multiply as unsigned word
neg=negate
negc=negate with carry
nop=no operation
not=not-logical complement
ocbi=operand cache block invalidate
ocbp=operand cache block purge
ocbwb=operand cache block write back
or=bitwise or
or=bitwise or (byte)
pref=prefetch data to cache
rotcl=rotate with carry left
rotcr=rotate with carry right
rotl=rotate left
rotr=rotate right
rte=return from exception
rts=return from subroutine
sets=set s bit
sett=set t bit
shad=shift arithmetic dynamically
shal=shift arithmetic left
shar=shift arithmetic right
shld=shift logical dynamically
shll=shift logical left
shll2=shift logical left 2
shll8=shift logical left 8
shll16=shift logical left 16
shlr=shift logical right
shlr2=shift logical right 2
shlr8=shift logical right 8
shlr16=shift logical right 16
sleep=sleep
stc.l=store control register
stc=store control register
sts.l=store system/fpu register
sts=store system/fpu register
sub=subtract binary
subc=subtract with carry
subv=subtract with (v flag) underflow check
swap.b=swap register lower bytes
swap.w=swap register words
tas.b=test and set byte
trapa=trap always
tst.b=test logical, byte
tst=test logical
xor.b=bitwise exclusive-or (byte)
xor=bitwise exclusive-or
xtrct=middle extraction from linked register
