NAME=global variables list
FILE=bins/elf/float_ex1/float_ex1_globals
CMDS=<<EOF
aaa
avglt
EOF
EXPECT=<<EOF
name       type        size address  decl_file                                                   decl_line decl_col 
--------------------------------------------------------------------------------------------------------------------
a          float       0x4  0x404040 /home/xvilka/rizin/rizin-testbins/elf/float_ex1/float_ex1.c 38        15
bb         const float 0x4  0x402010 /home/xvilka/rizin/rizin-testbins/elf/float_ex1/float_ex1.c 16        13
b          const float 0x4  0x402068 /home/xvilka/rizin/rizin-testbins/elf/float_ex1/float_ex1.c 39        21
aa         double      0x8  0x404038 /home/xvilka/rizin/rizin-testbins/elf/float_ex1/float_ex1.c 17        8
staticsome some_t      0x16 0x404060 /home/xvilka/rizin/rizin-testbins/elf/float_ex1/float_ex1.c 15        15
EOF
RUN

NAME=afvx
FILE=bins/elf/ls.odd
CMDS=<<EOF
af
afvx
afv=
EOF
EXPECT=<<EOF
afvR
      arg3  0x5312
afvW
      arg3
* arg3
R 0x5312  mov r9, rdx
EOF
RUN

NAME=afvx2
FILE=bins/mach0/mac-ls
CMDS=<<EOF
af
afvx
afv=
EOF
EXPECT=<<EOF
afvR
      argv  0x10000106c
      argc  0x10000106f
  var_648h  0x100001072
  var_650h  0x100001617,0x100001691
  var_65ch  0x100001784
  var_658h  0x10000173c,0x100001807,0x10000181c
  var_654h  0x100001736,0x1000017dd,0x1000017f2
  var_660h  0x1000017d4
  var_668h  0x1000018f1
  var_66ch  0x10000190b
  var_678h  0x100001911
   var_3ch  0x10000179e
  var_448h  0x1000015f8
   var_38h  0x1000010d6
   var_36h  0x1000010f0
afvW
      argv
      argc
  var_648h
  var_650h  0x100001079
  var_65ch  0x100001137,0x100001315
  var_658h  0x10000114c,0x1000014f2
  var_654h  0x100001156,0x1000012d8
  var_660h  0x100001160,0x1000014ce
  var_668h  0x100001597
  var_66ch  0x1000015a3
  var_678h  0x1000015ad
   var_3ch
  var_448h
   var_38h
   var_36h
* var_648h
R 0x100001072  lea rax, [var_648h]
* var_650h
R 0x100001617  lea rbx, [var_650h]
R 0x100001691  lea rsi, [var_650h]
W 0x100001079  mov qword [var_650h], rax
* var_65ch
R 0x100001784  cmp dword [var_65ch], 0
W 0x100001137  mov dword [var_65ch], 0
W 0x100001315  mov dword [var_65ch], 1
* var_658h
R 0x10000173c  or ebx, dword [var_658h]
R 0x100001807  cmp dword [var_658h], 0
R 0x10000181c  cmp dword [var_658h], 0
W 0x10000114c  mov dword [var_658h], 0
W 0x1000014f2  mov dword [var_658h], 1
* var_654h
R 0x100001736  mov ebx, dword [var_654h]
R 0x1000017dd  cmp dword [var_654h], 0
R 0x1000017f2  cmp dword [var_654h], 0
W 0x100001156  mov dword [var_654h], 0
W 0x1000012d8  mov dword [var_654h], 1
* var_660h
R 0x1000017d4  cmp dword [var_660h], 0
W 0x100001160  mov dword [var_660h], 0
W 0x1000014ce  mov dword [var_660h], 1
* var_668h
R 0x1000018f1  mov rax, qword [var_668h]
W 0x100001597  mov qword [var_668h], rcx
* var_66ch
R 0x10000190b  mov edi, dword [var_66ch]
W 0x1000015a3  mov dword [var_66ch], eax
* var_678h
R 0x100001911  mov rsi, qword [var_678h]
W 0x1000015ad  mov qword [var_678h], rax
* var_3ch
R 0x10000179e  lea rdi, [var_3ch]
* var_448h
R 0x1000015f8  lea rdi, [var_448h]
* var_38h
R 0x1000010d6  lea rdx, [var_38h]
* var_36h
R 0x1000010f0  movzx eax, word [var_36h]
* argv
R 0x10000106c  mov rbx, rsi
* argc
R 0x10000106f  mov r14d, edi
EOF
RUN

NAME=afvxa
FILE=bins/elf/ls.odd
CMDS=<<EOF
af
afv=
afvxv
EOF
EXPECT=<<EOF
* arg3
R 0x5312  mov r9, rdx
afvR
afvW
EOF
RUN

NAME=afvxa2
FILE=bins/mach0/mac-ls
CMDS=<<EOF
af
afv=
afvxa
EOF
EXPECT=<<EOF
* var_648h
R 0x100001072  lea rax, [var_648h]
* var_650h
R 0x100001617  lea rbx, [var_650h]
R 0x100001691  lea rsi, [var_650h]
W 0x100001079  mov qword [var_650h], rax
* var_65ch
R 0x100001784  cmp dword [var_65ch], 0
W 0x100001137  mov dword [var_65ch], 0
W 0x100001315  mov dword [var_65ch], 1
* var_658h
R 0x10000173c  or ebx, dword [var_658h]
R 0x100001807  cmp dword [var_658h], 0
R 0x10000181c  cmp dword [var_658h], 0
W 0x10000114c  mov dword [var_658h], 0
W 0x1000014f2  mov dword [var_658h], 1
* var_654h
R 0x100001736  mov ebx, dword [var_654h]
R 0x1000017dd  cmp dword [var_654h], 0
R 0x1000017f2  cmp dword [var_654h], 0
W 0x100001156  mov dword [var_654h], 0
W 0x1000012d8  mov dword [var_654h], 1
* var_660h
R 0x1000017d4  cmp dword [var_660h], 0
W 0x100001160  mov dword [var_660h], 0
W 0x1000014ce  mov dword [var_660h], 1
* var_668h
R 0x1000018f1  mov rax, qword [var_668h]
W 0x100001597  mov qword [var_668h], rcx
* var_66ch
R 0x10000190b  mov edi, dword [var_66ch]
W 0x1000015a3  mov dword [var_66ch], eax
* var_678h
R 0x100001911  mov rsi, qword [var_678h]
W 0x1000015ad  mov qword [var_678h], rax
* var_3ch
R 0x10000179e  lea rdi, [var_3ch]
* var_448h
R 0x1000015f8  lea rdi, [var_448h]
* var_38h
R 0x1000010d6  lea rdx, [var_38h]
* var_36h
R 0x1000010f0  movzx eax, word [var_36h]
* argv
R 0x10000106c  mov rbx, rsi
* argc
R 0x10000106f  mov r14d, edi
afvR
      argv  0x10000106c
      argc  0x10000106f
afvW
      argv
      argc
EOF
RUN

NAME=afvxv
FILE=bins/elf/ls.odd
CMDS=<<EOF
af
afv=
afvxv
EOF
EXPECT=<<EOF
* arg3
R 0x5312  mov r9, rdx
afvR
afvW
EOF
RUN

NAME=afvxv2
FILE=bins/mach0/mac-ls
CMDS=<<EOF
af
afv=
afvxv
EOF
EXPECT=<<EOF
* var_648h
R 0x100001072  lea rax, [var_648h]
* var_650h
R 0x100001617  lea rbx, [var_650h]
R 0x100001691  lea rsi, [var_650h]
W 0x100001079  mov qword [var_650h], rax
* var_65ch
R 0x100001784  cmp dword [var_65ch], 0
W 0x100001137  mov dword [var_65ch], 0
W 0x100001315  mov dword [var_65ch], 1
* var_658h
R 0x10000173c  or ebx, dword [var_658h]
R 0x100001807  cmp dword [var_658h], 0
R 0x10000181c  cmp dword [var_658h], 0
W 0x10000114c  mov dword [var_658h], 0
W 0x1000014f2  mov dword [var_658h], 1
* var_654h
R 0x100001736  mov ebx, dword [var_654h]
R 0x1000017dd  cmp dword [var_654h], 0
R 0x1000017f2  cmp dword [var_654h], 0
W 0x100001156  mov dword [var_654h], 0
W 0x1000012d8  mov dword [var_654h], 1
* var_660h
R 0x1000017d4  cmp dword [var_660h], 0
W 0x100001160  mov dword [var_660h], 0
W 0x1000014ce  mov dword [var_660h], 1
* var_668h
R 0x1000018f1  mov rax, qword [var_668h]
W 0x100001597  mov qword [var_668h], rcx
* var_66ch
R 0x10000190b  mov edi, dword [var_66ch]
W 0x1000015a3  mov dword [var_66ch], eax
* var_678h
R 0x100001911  mov rsi, qword [var_678h]
W 0x1000015ad  mov qword [var_678h], rax
* var_3ch
R 0x10000179e  lea rdi, [var_3ch]
* var_448h
R 0x1000015f8  lea rdi, [var_448h]
* var_38h
R 0x1000010d6  lea rdx, [var_38h]
* var_36h
R 0x1000010f0  movzx eax, word [var_36h]
* argv
R 0x10000106c  mov rbx, rsi
* argc
R 0x10000106f  mov r14d, edi
afvR
  var_648h  0x100001072
  var_650h  0x100001617,0x100001691
  var_65ch  0x100001784
  var_658h  0x10000173c,0x100001807,0x10000181c
  var_654h  0x100001736,0x1000017dd,0x1000017f2
  var_660h  0x1000017d4
  var_668h  0x1000018f1
  var_66ch  0x10000190b
  var_678h  0x100001911
   var_3ch  0x10000179e
  var_448h  0x1000015f8
   var_38h  0x1000010d6
   var_36h  0x1000010f0
afvW
  var_648h
  var_650h  0x100001079
  var_65ch  0x100001137,0x100001315
  var_658h  0x10000114c,0x1000014f2
  var_654h  0x100001156,0x1000012d8
  var_660h  0x100001160,0x1000014ce
  var_668h  0x100001597
  var_66ch  0x1000015a3
  var_678h  0x1000015ad
   var_3ch
  var_448h
   var_38h
   var_36h
EOF
RUN

NAME=Detect register args used only by callee
FILE==
CMDS=<<EOF
e asm.bytes=true
e asm.arch=x86
e asm.bits=64
e analysis.cc=ms
wx 40534883ec20418bd8e80a00000003c34883c4205bc3cccc2bca8bc1c3
aa
pd 13
EOF
EXPECT=<<EOF
/ fcn.00000000(int64_t arg1, int64_t arg2, int64_t arg3);
|           ; arg int64_t arg1 @ rcx
|           ; arg int64_t arg2 @ rdx
|           ; arg int64_t arg3 @ r8
|           0x00000000      4053           push  rbx
|           0x00000002      4883ec20       sub   rsp, 0x20
|           0x00000006      418bd8         mov   ebx, r8d              ; arg3
|           0x00000009      e80a000000     call  fcn.00000018
|           0x0000000e      03c3           add   eax, ebx
|           0x00000010      4883c420       add   rsp, 0x20
|           0x00000014      5b             pop   rbx
\           0x00000015      c3             ret
            0x00000016      cc             int3
            0x00000017      cc             int3
            ; CALL XREF from fcn.00000000 @ 0x9
/ fcn.00000018(int64_t arg1, int64_t arg2);
|           ; arg int64_t arg1 @ rcx
|           ; arg int64_t arg2 @ rdx
|           0x00000018      2bca           sub   ecx, edx              ; arg2
|           0x0000001a      8bc1           mov   eax, ecx              ; arg1
\           0x0000001c      c3             ret
EOF
RUN

NAME=Detect register args type used only by callees
FILE=bins/pe/rarg_detection.dll
CMDS=<<EOF
s sym.rarg_detection.dll_funcB
af
s sym.rarg_detection.dll_funcC
af
afvl
EOF
EXPECT=<<EOF
arg int64_t arg3 @ r8
arg const char *s @ rcx
arg int64_t arg2 @ rdx
EOF
RUN

NAME=Variables in register save stack area
FILE=bins/pe/testx64.exe
CMDS=<<EOF
s 0x14000184c
af
afvl
EOF
EXPECT=<<EOF
var int64_t var_8h @ stack + 0x8
var int64_t var_10h @ stack + 0x10
var int64_t var_18h @ stack + 0x18
var int64_t var_20h @ stack + 0x20
EOF
RUN

NAME=Variable access with misc registers (x86)
FILE==
ARGS=-a x86 -b 64
CMDS=<<EOF
e asm.flags=false
e asm.bytes=true
e analysis.cc=ms
wx 488bc448895808488970104889781841574881ecb00000008364242000488d48884c8d9c24b0000000498b5b10498b7318498b7b20498be3415fc3
af
aaef
afvx
pdf
EOF
EXPECT=<<EOF
afvR
   var_98h  0x18
    var_8h  0x21
    var_0h
   var_s8h  0x29
  var_s10h  0x2d
  var_s18h  0x31
   var_78h
afvW
   var_98h  0x18
    var_8h
    var_0h
   var_s8h  0x3
  var_s10h  0x7
  var_s18h  0xb
   var_78h
/ fcn.00000000();
|           ; var int64_t var_98h @ stack - 0x98
|           ; var int64_t var_78h @ stack - 0x78
|           ; var int64_t var_8h @ stack - 0x8
|           ; var int64_t var_0h @ stack + 0x0
|           ; var int64_t var_s8h @ stack + 0x8
|           ; var int64_t var_s10h @ stack + 0x10
|           ; var int64_t var_s18h @ stack + 0x18
|           0x00000000      488bc4         mov   rax, rsp
|           0x00000003      48895808       mov   qword [var_s8h], rbx
|           0x00000007      48897010       mov   qword [var_s10h], rsi
|           0x0000000b      48897818       mov   qword [var_s18h], rdi
|           0x0000000f      4157           push  r15
|           0x00000011      4881ecb00000.  sub   rsp, 0xb0
|           0x00000018      8364242000     and   dword [var_98h], 0
|           0x0000001d      488d4888       lea   rcx, [var_78h]
|           0x00000021      4c8d9c24b000.  lea   r11, [var_8h]
|           0x00000029      498b5b10       mov   rbx, qword [var_s8h]
|           0x0000002d      498b7318       mov   rsi, qword [var_s10h]
|           0x00000031      498b7b20       mov   rdi, qword [var_s18h]
|           0x00000035      498be3         mov   rsp, r11
|           0x00000038      415f           pop   r15
\           0x0000003a      c3             ret
EOF
RUN

NAME=Variable access with misc registers (ARM)
FILE==
ARGS=-a arm -b 16
CMDS=<<EOF
e asm.bytes=true
e asm.flags=false
e asm.comments=false
wx 80b483b000af78600b467b8013467b707b78002b03d07a887b689a6103e07b881a047b689a6100bf0c37bd465df8047b7047
af
aaef
afvx
pdf
EOF
EXPECT=<<EOF
afvR
      arg1  0x6
      arg2  0x8
      arg3  0xc
   var_10h
    var_ch  0x18,0x22
    var_eh  0x16,0x1e
    var_fh  0x10
    var_4h
afvW
      arg1
      arg2
      arg3
   var_10h
    var_ch  0x6
    var_eh  0xa
    var_fh  0xe
    var_4h
/ fcn.00000000(int16_t arg1, int16_t arg2, int16_t arg3);
|           ; arg int16_t arg1 @ r0
|           ; arg int16_t arg2 @ r1
|           ; arg int16_t arg3 @ r2
|           ; var int32_t var_10h @ stack - 0x10
|           ; var int8_t var_fh @ stack - 0xf
|           ; var int16_t var_eh @ stack - 0xe
|           ; var int32_t var_ch @ stack - 0xc
|           ; var int32_t var_4h @ stack - 0x4
|           0x00000000      80b4           push  {r7}
|           0x00000002      83b0           sub   sp, 0xc
|           0x00000004      00af           add   r7, var_10h
|           0x00000006      7860           str   r0, [var_ch]
|           0x00000008      0b46           mov   r3, r1
|           0x0000000a      7b80           strh  r3, [var_eh]
|           0x0000000c      1346           mov   r3, r2
|           0x0000000e      7b70           strb  r3, [var_fh]
|           0x00000010      7b78           ldrb  r3, [var_fh]
|           0x00000012      002b           cmp   r3, 0
|       ,=< 0x00000014      03d0           beq   0x1e
|       |   0x00000016      7a88           ldrh  r2, [var_eh]
|       |   0x00000018      7b68           ldr   r3, [var_ch]
|       |   0x0000001a      9a61           str   r2, [r3, 0x18]
|      ,==< 0x0000001c      03e0           b     0x26
|      |`-> 0x0000001e      7b88           ldrh  r3, [var_eh]
|      |    0x00000020      1a04           lsls  r2, r3, 0x10
|      |    0x00000022      7b68           ldr   r3, [var_ch]
|      |    0x00000024      9a61           str   r2, [r3, 0x18]
|      `--> 0x00000026      00bf           nop
|           0x00000028      0c37           adds  r7, 0xc
|           0x0000002a      bd46           mov   sp, r7
|           0x0000002c      5df8047b       pop   {r7}
\           0x00000030      7047           bx    lr
EOF
RUN

NAME=Takeover variables
FILE==
ARGS=-a x86 -b 32
CMDS=<<EOF
wx e805000000e80600000039d1742577145589e583ec048b5d088b4d0c895dfc83f90174098b45fc8945fc49ebf28b45fc89ec5dc3
aac
afvl  @ 10
afvx @ 10
afvl  @ 16
afvx @ 16
EOF
EXPECT=<<EOF
afvR
afvW
var int32_t var_8h @ stack - 0x4
arg int32_t var_4h @ stack + 0x0
arg int32_t arg_4h @ stack + 0x8
arg int32_t arg_8h @ stack + 0xc
afvR
    arg_4h  0x16
    arg_8h  0x19
    var_4h  0x24,0x2d
    var_8h
afvW
    arg_4h
    arg_8h
    var_4h  0x27
    var_8h  0x1c
EOF
RUN

NAME=Analyze function with 0 basic blocks
FILE=bins/elf/ls
CMDS=<<EOF
af+ a @ 0
aa
EOF
EXPECT=
RUN

NAME=Analyze vars accessed from bp (x86)
FILE=bins/elf/vars-x86_64-bp
CMDS=<<EOF
s sym.varfunc
af
afvl
EOF
EXPECT=<<EOF
var int64_t var_18h @ stack - 0x18
var int64_t var_14h @ stack - 0x14
var int64_t var_10h @ stack - 0x10
var int64_t var_ch @ stack - 0xc
EOF
RUN

NAME=Vars from dwarf accessed from bp (x86)
FILE=bins/elf/vars-x86_64-bp
CMDS=<<EOF
aaa
s sym.varfunc
e asm.comments=0
pdf
EOF
EXPECT=<<EOF
/ int varfunc()
|           ; var int lightbulb @ stack - 0x18
|           ; var int sun @ stack - 0x14
|           ; var int last @ stack - 0x10
|           ; var int chance @ stack - 0xc
|           0x0000113c      push  rbp                                  ; main.c:9
|           0x0000113d      mov   rbp, rsp
|           0x00001140      sub   rsp, 0x10
|           0x00001144      mov   dword [lightbulb], 1                 ; main.c:15
|           0x0000114b      mov   dword [sun], 2                       ; main.c:16
|           0x00001152      mov   dword [last], 3                      ; main.c:17
|           0x00001159      mov   dword [chance], 4                    ; main.c:18
|           0x00001160      mov   eax, 0                               ; main.c:20
|           0x00001165      call  dbg.leaffunc
|           0x0000116a      mov   eax, dword [chance]                  ; main.c:22
|           0x0000116d      mov   dword [sun], eax
|           0x00001170      mov   eax, dword [lightbulb]               ; main.c:23
|           0x00001173      leave                                      ; main.c:24
\           0x00001174      ret
EOF
RUN

NAME=Analyze vars accessed from sp (x86)
FILE=bins/elf/vars-x86_64-sp
CMDS=<<EOF
s sym.varfunc
af
afvl
EOF
EXPECT=<<EOF
var int64_t var_10h @ stack - 0x10
var int64_t var_ch @ stack - 0xc
var int64_t var_8h @ stack - 0x8
var int64_t var_4h @ stack - 0x4
EOF
RUN

NAME=Vars from dwarf accessed from sp (x86)
FILE=bins/elf/vars-x86_64-sp
CMDS=<<EOF
aaa
s sym.varfunc
e asm.comments=0
pdf
EOF
EXPECT=<<EOF
/ int varfunc()
|           ; var int lightbulb @ stack - 0x10
|           ; var int sun @ stack - 0xc
|           ; var int last @ stack - 0x8
|           ; var int chance @ stack - 0x4
|           0x00001137      sub   rsp, 0x10                            ; main.c:9
|           0x0000113b      mov   dword [rsp], 1                       ; main.c:15
|           0x00001142      mov   dword [sun], 2                       ; main.c:16
|           0x0000114a      mov   dword [last], 3                      ; main.c:17
|           0x00001152      mov   dword [chance], 4                    ; main.c:18
|           0x0000115a      mov   eax, 0                               ; main.c:20
|           0x0000115f      call  dbg.leaffunc
|           0x00001164      mov   eax, dword [chance]                  ; main.c:22
|           0x00001168      mov   dword [sun], eax
|           0x0000116c      mov   eax, dword [rsp]                     ; main.c:23
|           0x0000116f      add   rsp, 0x10                            ; main.c:24
\           0x00001173      ret
EOF
RUN

NAME=Vars and Args from dwarf accessed from sp (x86)
FILE=bins/elf/vars_args/example.x64
CMDS=<<EOF
aaa
s dbg.foo
pdf
EOF
EXPECT=<<EOF
            ; CALL XREF from dbg.main @ 0x11c0
/ int foo(int num)
|           ; var int64_t arg1 @ rdi
|           ; arg int num @ stack - 0x2c
|           ; var int int_one @ stack - 0x20
|           ; var long int long_twenty @ stack - 0x18
|           ; var short int minus_seven @ stack - 0x24
|           ; var int mult_int @ stack - 0x1c
|           ; var long int add_long @ stack - 0x10
|           ; var short int sub_short @ stack - 0x22
|           0x00001139      push  rbp                                  ; example.c:3
|           0x0000113a      mov   rbp, rsp
|           0x0000113d      sub   rsp, 0x30
|           0x00001141      mov   dword [num], edi                     ; arg1
|           0x00001144      mov   dword [int_one], 1                   ; example.c:4
|           0x0000114b      mov   qword [long_twenty], 0x14            ; example.c:5
|           0x00001153      mov   word [minus_seven], 0xfff9           ; example.c:6
|           0x00001159      mov   edx, dword [int_one]                 ; example.c:7
|           0x0000115c      mov   eax, edx
|           0x0000115e      add   eax, eax
|           0x00001160      add   eax, edx
|           0x00001162      add   eax, eax
|           0x00001164      mov   dword [mult_int], eax
|           0x00001167      mov   rax, qword [long_twenty]             ; example.c:8
|           0x0000116b      add   rax, 7
|           0x0000116f      mov   qword [add_long], rax
|           0x00001173      movzx eax, word [minus_seven]              ; example.c:9
|           0x00001177      sub   eax, 9
|           0x0000117a      mov   word [sub_short], ax
|           0x0000117e      movsx esi, word [sub_short]                ; example.c:11
|           0x00001182      mov   rcx, qword [add_long]
|           0x00001186      mov   edx, dword [mult_int]
|           0x00001189      mov   eax, dword [num]
|           0x0000118c      mov   r8d, esi
|           0x0000118f      mov   esi, eax
|           0x00001191      lea   rax, str.result__d__d__ld__ld        ; 0x2004 ; "result %d %d %ld %ld\n"
|           0x00001198      mov   rdi, rax                             ; const char *format
|           0x0000119b      mov   eax, 0
|           0x000011a0      call  sym.imp.printf                       ; int printf(const char *format)
|           0x000011a5      mov   eax, 0xa                             ; example.c:13
|           0x000011aa      leave                                      ; example.c:14
\           0x000011ab      ret
EOF
RUN

NAME=Function arguments from DWARF (arm)
FILE=bins/elf/float_ex1/float_ex1_arm
CMDS=<<EOF
aaa
s sym.fn1
e asm.comments=0
pdf
EOF
EXPECT=<<EOF
            ;-- fn1:
/ dbg.fn1 (int a, char *g, double q, struct Some *gg, some_t **out);
|           ; var int16_t var_20h @ stack - 0x20
|           ; arg some_t **out @ stack - 0x1e
|           ; arg struct Some *gg @ stack - 0x1a
|           ; arg double q @ stack - 0x16
|           ; arg char *g @ stack - 0xe
|           ; arg int a @ stack - 0xa
|           0x000005e0      push  {r7, lr}
|           0x000005e2      sub   sp, 0x18
|           0x000005e4      add   r7, var_20h
|           0x000005e6      str   r0, [r7, 0x14]
|           0x000005e8      str   r1, [r7, 0x10]
|           0x000005ea      vstr  d0, [r7, 8]
|           0x000005ee      str   r2, [r7, 4]
|           0x000005f0      str   r3, [r7]
|           0x000005f2      ldr   r3, [r7, 4]
|           0x000005f4      cmp   r3, 0
|       ,=< 0x000005f6      beq   0x5fe
|       |   0x000005f8      ldr   r3, [r7]
|       |   0x000005fa      cmp   r3, 0
|      ,==< 0x000005fc      bne   0x602
|      |`-> 0x000005fe      movs  r3, 0
|      |,=< 0x00000600      b     0x642
|      `--> 0x00000602      movs  r0, 0x14
|       |   0x00000604      blx   sym.imp.malloc
|       |   0x00000608      mov   r3, r0
|       |   0x0000060a      mov   r2, r3
|       |   0x0000060c      ldr   r3, [r7]
|       |   0x0000060e      str   r2, [r3]
|       |   0x00000610      ldr   r3, [r7]
|       |   0x00000612      ldr   r3, [r3]
|       |   0x00000614      ldr   r2, [r7, 0x14]
|       |   0x00000616      str   r2, [r3]
|       |   0x00000618      ldr   r3, [r7]
|       |   0x0000061a      ldr   r3, [r3]
|       |   0x0000061c      adds  r3, 4
|       |   0x0000061e      movs  r2, 5
|       |   0x00000620      ldr   r1, [r7, 0x10]
|       |   0x00000622      mov   r0, r3
|       |   0x00000624      blx   sym.imp.strncpy
|       |   0x00000628      ldr   r3, [r7]
|       |   0x0000062a      ldr   r3, [r3]
|       |   0x0000062c      vldr  d7, [r7, 8]
|       |   0x00000630      vcvt.f32.f64 s15, d7
|       |   0x00000634      vstr  s15, [r3, 0xc]
|       |   0x00000638      ldr   r3, [r7]
|       |   0x0000063a      ldr   r3, [r3]
|       |   0x0000063c      ldr   r2, [r7, 4]
|       |   0x0000063e      str   r2, [r3, 0x10]
|       |   0x00000640      movs  r3, 1
|       `-> 0x00000642      mov   r0, r3
|           0x00000644      adds  r7, 0x18
|           0x00000646      mov   sp, r7
\           0x00000648      pop   {r7, pc}
EOF
BROKEN=1
RUN

NAME=Function arguments from DWARF (arm_nodebug)
FILE=bins/elf/float_ex1/float_ex1_arm_nodebug
BROKEN=1
CMDS=<<EOF
aaa
s sym.fn1
e asm.comments=0
pdf
EOF
EXPECT=<<EOF
/ sym.fn1 (int16_t arg1, int16_t arg2, int16_t arg3, int16_t arg4);
|           ; arg int16_t arg1 @ r0
|           ; arg int16_t arg2 @ r1
|           ; arg int16_t arg3 @ r2
|           ; arg int16_t arg4 @ r3
|           ; var int16_t var_20h @ stack - 0x20
|           0x000005e0      push  {r7, lr}
|           0x000005e2      sub   sp, 0x18
|           0x000005e4      add   r7, var_20h
|           0x000005e6      str   r0, [r7, 0x14]
|           0x000005e8      str   r1, [r7, 0x10]
|           0x000005ea      vstr  d0, [r7, 8]
|           0x000005ee      str   r2, [r7, 4]
|           0x000005f0      str   r3, [r7]
|           0x000005f2      ldr   r3, [r7, 4]
|           0x000005f4      cmp   r3, 0
|       ,=< 0x000005f6      beq   0x5fe
|       |   0x000005f8      ldr   r3, [r7]
|       |   0x000005fa      cmp   r3, 0
|      ,==< 0x000005fc      bne   0x602
|      |`-> 0x000005fe      movs  r3, 0
|      |,=< 0x00000600      b     0x642
|      `--> 0x00000602      movs  r0, 0x14
|       |   0x00000604      blx   sym.imp.malloc
|       |   0x00000608      mov   r3, r0
|       |   0x0000060a      mov   r2, r3
|       |   0x0000060c      ldr   r3, [r7]
|       |   0x0000060e      str   r2, [r3]
|       |   0x00000610      ldr   r3, [r7]
|       |   0x00000612      ldr   r3, [r3]
|       |   0x00000614      ldr   r2, [r7, 0x14]
|       |   0x00000616      str   r2, [r3]
|       |   0x00000618      ldr   r3, [r7]
|       |   0x0000061a      ldr   r3, [r3]
|       |   0x0000061c      adds  r3, 4
|       |   0x0000061e      movs  r2, 5
|       |   0x00000620      ldr   r1, [r7, 0x10]
|       |   0x00000622      mov   r0, r3
|       |   0x00000624      blx   sym.imp.strncpy
|       |   0x00000628      ldr   r3, [r7]
|       |   0x0000062a      ldr   r3, [r3]
|       |   0x0000062c      vldr  d7, [r7, 8]
|       |   0x00000630      vcvt.f32.f64 s15, d7
|       |   0x00000634      vstr  s15, [r3, 0xc]
|       |   0x00000638      ldr   r3, [r7]
|       |   0x0000063a      ldr   r3, [r3]
|       |   0x0000063c      ldr   r2, [r7, 4]
|       |   0x0000063e      str   r2, [r3, 0x10]
|       |   0x00000640      movs  r3, 1
|       `-> 0x00000642      mov   r0, r3
|           0x00000644      adds  r7, 0x18
|           0x00000646      mov   sp, r7
\           0x00000648      pop   {r7, pc}
EOF
RUN

NAME=Function arguments from DWARF (arm_stripped)
FILE=bins/elf/float_ex1/float_ex1_arm_stripped
BROKEN=1
CMDS=<<EOF
aaa
s 0x5e0
e asm.comments=0
pdf
EOF
EXPECT=<<EOF
/ fcn.000005e0 (int16_t arg1, int16_t arg2, int16_t arg3, int16_t arg4);
|           ; arg int16_t arg1 @ r0
|           ; arg int16_t arg2 @ r1
|           ; arg int16_t arg3 @ r2
|           ; arg int16_t arg4 @ r3
|           ; var int16_t var_20h @ stack - 0x20
|           0x000005e0      push  {r7, lr}
|           0x000005e2      sub   sp, 0x18
|           0x000005e4      add   r7, var_20h
|           0x000005e6      str   r0, [r7, 0x14]
|           0x000005e8      str   r1, [r7, 0x10]
|           0x000005ea      vstr  d0, [r7, 8]
|           0x000005ee      str   r2, [r7, 4]
|           0x000005f0      str   r3, [r7]
|           0x000005f2      ldr   r3, [r7, 4]
|           0x000005f4      cmp   r3, 0
|       ,=< 0x000005f6      beq   0x5fe
|       |   0x000005f8      ldr   r3, [r7]
|       |   0x000005fa      cmp   r3, 0
|      ,==< 0x000005fc      bne   0x602
|      |`-> 0x000005fe      movs  r3, 0
|      |,=< 0x00000600      b     0x642
|      `--> 0x00000602      movs  r0, 0x14
|       |   0x00000604      blx   sym.imp.malloc
|       |   0x00000608      mov   r3, r0
|       |   0x0000060a      mov   r2, r3
|       |   0x0000060c      ldr   r3, [r7]
|       |   0x0000060e      str   r2, [r3]
|       |   0x00000610      ldr   r3, [r7]
|       |   0x00000612      ldr   r3, [r3]
|       |   0x00000614      ldr   r2, [r7, 0x14]
|       |   ;-- aav.0x00000616:
|       |   0x00000616      str   r2, [r3]
|       |   0x00000618      ldr   r3, [r7]
|       |   0x0000061a      ldr   r3, [r3]
|       |   0x0000061c      adds  r3, 4
|       |   0x0000061e      movs  r2, 5
|       |   0x00000620      ldr   r1, [r7, 0x10]
|       |   0x00000622      mov   r0, r3
|       |   0x00000624      blx   sym.imp.strncpy
|       |   0x00000628      ldr   r3, [r7]
|       |   0x0000062a      ldr   r3, [r3]
|       |   0x0000062c      vldr  d7, [r7, 8]
|       |   0x00000630      vcvt.f32.f64 s15, d7
|       |   0x00000634      vstr  s15, [r3, 0xc]
|       |   0x00000638      ldr   r3, [r7]
|       |   0x0000063a      ldr   r3, [r3]
|       |   0x0000063c      ldr   r2, [r7, 4]
|       |   0x0000063e      str   r2, [r3, 0x10]
|       |   0x00000640      movs  r3, 1
|       `-> 0x00000642      mov   r0, r3
|           0x00000644      adds  r7, 0x18
|           0x00000646      mov   sp, r7
\           0x00000648      pop   {r7, pc}
EOF
RUN

NAME=Function va_args arguments from DWARF
FILE=bins/elf/float_ex1/float_ex1_hightec
CMDS=<<EOF
aaa
(sig; afvl; afvlt; afs; pd 1; echo "---------")
s dbg.printf
.(sig)
s dbg.prout
.(sig)
s dbg._fpadd_parts
.(sig)
s dbg.strnlen_s
.(sig)
s dbg._Wctomb
.(sig)
s dbg._Mbtowc
.(sig)
s dbg.feraiseexcept
.(sig)
s dbg._Atrealloc
.(sig)
s dbg.fn1
.(sig)
EOF
EXPECT=<<EOF
var va_list ap @ stack + 0x4
arg const char *fmt @ a4
var int ans @ ...
is_arg name type         constraints origin addr                                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------
false  ap   va_list                  DWARF  loclist: [(0x80000c22, 20): CFA+0,	(0x80000c36, 5): a7,	(0x80000c3b, 1): CFA+0]
true   fmt  const char *             DWARF  loclist: [(0x80000c22, 10): a4,	(0x80000c2c, 15): a6,	(0x80000c3b, 1): <evaluation waiting>]
false  ans  int                      DWARF  empty
int printf(const char *fmt, ...);
            ; CALL XREFS from dbg.main @ 0x8000054e, 0x80000636
/ int printf(const char *fmt, ...)
|           ; arg const char *fmt @ a4
|           ; var int ans @ ...
|           ; var va_list ap @ stack + 0x4
|           0x80000c22      mov.aa a6, a4                              ; printf.c:10 ; arg5
---------
arg void *str @ a4
arg const char *buf @ a4
var int32_t arg6 @ a5
arg size_t n @ d5
is_arg name type         constraints origin addr                                                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------
true   str  void *                   DWARF  loclist: [(0x80000c04, 6): a4,	(0x80000c0a, 24): a15]
true   buf  const char *             DWARF  loclist: [(0x80000c04, 12): a5,	(0x80000c10, 3): a4,	(0x80000c13, 15): <evaluation waiting>]
false  arg6 int32_t                  rizin  a5
true   n    size_t                   DWARF  loclist: [(0x80000c04, 10): d4,	(0x80000c0e, 5): d5,	(0x80000c13, 7): d15,	(0x80000c1a, 8): <evaluation waiting>]
void * prout(void *str, const char *buf, size_t n);
/ void * prout(void *str, const char *buf, size_t n)
|           ; var int32_t arg6 @ a5
|           ; arg void *str @ a4
|           ; arg const char *buf @ a4
|           ; arg size_t n @ d5
|           0x80000c04      mov.aa a15, a4                             ; printf.c:5 ; arg5
---------
arg fp_number_type *b @ a2
arg fp_number_type *a @ a4
var int32_t arg6 @ a5
arg fp_number_type *tmp @ a6
var int b_normal_exp @ d2
var intfrac tfraction @ COMPOSITE
var fractype b_fraction @ COMPOSITE
var int a_normal_exp @ LOCLIST
var fractype a_fraction @ LOCLIST
is_arg name         type             constraints origin addr                                                                                                                                                                                                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
true   b            fp_number_type *             DWARF  loclist: [(0x80003c60, 44): a5,	(0x80003c8c, 2): a2,	(0x80003c8e, 4): a5,	(0x80003c92, 6): a2,	(0x80003c98, 28): a5,	(0x80003cb4, 2): a2,	(0x80003cb6, 4): a5,	(0x80003cba, 47): a2,	(0x80003ce9, 39): a12,	(0x80003d10, 13): a2,	(0x80003d1d, 41): a12,	(0x80003d46, 16): a2,	(0x80003d56, 172): a12,	(0x80003e02, 2): <evaluation waiting>]
true   a            fp_number_type *             DWARF  loclist: [(0x80003c60, 60): a4,	(0x80003c9c, 18): a2,	(0x80003cae, 6): <evaluation waiting>,	(0x80003cb4, 53): a4,	(0x80003ce9, 39): a13,	(0x80003d10, 13): a4,	(0x80003d1d, 41): a13,	(0x80003d46, 16): a4,	(0x80003d56, 172): a13,	(0x80003e02, 2): <evaluation waiting>]
false  arg6         int32_t                      rizin  a5
true   tmp          fp_number_type *             DWARF  loclist: [(0x80003c60, 137): a6,	(0x80003ce9, 39): a15,	(0x80003d10, 13): a6,	(0x80003d1d, 41): a15,	(0x80003d46, 16): a6,	(0x80003d56, 148): a15,	(0x80003dea, 24): a2,	(0x80003e02, 2): <evaluation waiting>]
false  b_normal_exp int                          DWARF  loclist: [(0x80003cc0, 32): d2,	(0x80003ce0, 9): <evaluation waiting>,	(0x80003d10, 13): d2,	(0x80003d46, 16): d2]
false  tfraction    intfrac                      DWARF  composite: [(.0, 32): d2,	(.0, 32): d3]
false  b_fraction   fractype                     DWARF  loclist: [(0x80003cd8, 48): composite: [(.0, 32): d8,	(.0, 32): d9],	(0x80003d0e, 244): composite: [(.0, 32): d8,	(.0, 32): d9]]
false  a_normal_exp int                          DWARF  loclist: [(0x80003cbc, 144): d15,	(0x80003d4c, 6): a4+8,	(0x80003d52, 54): d15,	(0x80003d88, 16): a15+8,	(0x80003dc6, 10): d15,	(0x80003dd0, 6): a15+8]
false  a_fraction   fractype                     DWARF  loclist: [(0x80003cd4, 104): composite: [(.0, 32): d10,	(.0, 32): d11],	(0x80003d44, 12): composite: [(.0, 32): d10,	(.0, 32): d11],	(0x80003d50, 2): a4+12,	(0x80003d52, 176): composite: [(.0, 32): d10,	(.0, 32): d11]]
fp_number_type * _fpadd_parts(fp_number_type *a, fp_number_type *b, fp_number_type *tmp);
            ; CALL XREF from dbg.__adddf3 @ 0x80003e32
            ; CALL XREF from dbg.__subdf3 @ 0x80003e72
/ fp_number_type * _fpadd_parts(fp_number_type *a, fp_number_type *b, fp_number_type *tmp)
|           ; var int32_t arg6 @ a5
|           ; arg fp_number_type *a @ a4
|           ; arg fp_number_type *b @ a2
|           ; arg fp_number_type *tmp @ a6
|           ; var intfrac tfraction @ COMPOSITE
|           ; var int a_normal_exp @ LOCLIST
|           ; var int b_normal_exp @ d2
|           ; var fractype a_fraction @ LOCLIST
|           ; var fractype b_fraction @ COMPOSITE
|           0x80003c60      ld.bu d15, [a4]#0                          ; fp-bit.c:604 ; arg5
---------
arg const char *s @ a2
var const char *sc @ a2
var int32_t arg5 @ a4
arg size_t maxsize @ d4
is_arg name    type         constraints origin addr                                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
true   s       const char *             DWARF  loclist: [(0x800030ca, 18): a4,	(0x800030dc, 4): <evaluation waiting>,	(0x800030e0, 10): a4,	(0x800030ea, 2): a2]
false  sc      const char *             DWARF  a2
false  arg5    int32_t                  rizin  a4
true   maxsize size_t                   DWARF  loclist: [(0x800030ca, 8): d4,	(0x800030ea, 2): d4]
size_t strnlen_s(const char *s, size_t maxsize);
            ; CALL XREF from dbg._Fail_s @ 0x8000191e
/ size_t strnlen_s(const char *s, size_t maxsize)
|           ; var int32_t arg5 @ a4
|           ; arg const char *s @ a2
|           ; arg size_t maxsize @ d4
|           ; var const char *sc @ a2
|           0x800030ca      mov   d2, #0                               ; strnlen_s.c:6
---------
var _Statab *pwcstate @ a13
arg char *s @ a4
arg mbstate_t *pst @ a5
arg wchar_t wc @ d4
var _Statab *pmbstate @ ...
is_arg name     type        constraints origin addr                                                   
------------------------------------------------------------------------------------------------------
false  pwcstate _Statab *               DWARF  a13
true   s        char *                  DWARF  loclist: [(0x800018a6, 21): a4,	(0x800018bb, 49): a15]
true   pst      mbstate_t *             DWARF  loclist: [(0x800018a6, 21): a5,	(0x800018bb, 49): a12]
true   wc       wchar_t                 DWARF  loclist: [(0x800018a6, 21): d4,	(0x800018bb, 49): d15]
false  pmbstate _Statab *               DWARF  empty
int _Wctomb(char *s, wchar_t wc, mbstate_t *pst);
            ; CALL XREF from dbg._Putstr @ 0x800014d2
/ int _Wctomb(char *s, wchar_t wc, mbstate_t *pst)
|           ; arg char *s @ a4
|           ; arg wchar_t wc @ d4
|           ; arg mbstate_t *pst @ a5
|           ; var _Statab *pmbstate @ ...
|           ; var _Statab *pwcstate @ a13
|           0x800018a6      movh.a a2, #0xd000                         ; xwctomb.c:123
---------
arg mbstate_t *pst @ a12
arg const char *s @ a13
arg wchar_t *pwc @ a14
var int32_t arg5 @ a4
var int32_t arg6 @ a5
var int32_t arg7 @ a6
arg size_t nin @ d15
is_arg name type         constraints origin addr                                                   
---------------------------------------------------------------------------------------------------
true   pst  mbstate_t *              DWARF  loclist: [(0x80003084, 23): a6,	(0x8000309b, 21): a12]
true   s    const char *             DWARF  loclist: [(0x80003084, 23): a5,	(0x8000309b, 21): a13]
true   pwc  wchar_t *                DWARF  loclist: [(0x80003084, 23): a4,	(0x8000309b, 21): a14]
false  arg5 int32_t                  rizin  a4
false  arg6 int32_t                  rizin  a5
false  arg7 int32_t                  rizin  a6
true   nin  size_t                   DWARF  loclist: [(0x80003084, 23): d4,	(0x8000309b, 21): d15]
int _Mbtowc(wchar_t *pwc, const char *s, size_t nin, mbstate_t *pst);
            ; CALL XREF from dbg._Printf @ 0x80000d02
/ int _Mbtowc(wchar_t *pwc, const char *s, size_t nin, mbstate_t *pst)
|           ; var int32_t arg5 @ a4
|           ; var int32_t arg6 @ a5
|           ; var int32_t arg7 @ a6
|           ; arg wchar_t *pwc @ a14
|           ; arg const char *s @ a13
|           ; arg size_t nin @ d15
|           ; arg mbstate_t *pst @ a12
|           0x80003084      movh.a a15, #0xd000                        ; xmbtowc.c:150
---------
arg int except @ d4
is_arg name   type constraints origin addr 
-------------------------------------------
true   except int              DWARF  d4
int feraiseexcept(int except);
            ; CALL XREF from dbg._Feraise @ 0x8000343e
/ int feraiseexcept(int except)
|           ; arg int except @ d4
|           0x800037d8      mov   d2, #0                               ; feraiseexcept.c:173
---------
var size_t size_arg @ a0
var Ppvoidfn newfuns @ a2
var size_t inc @ d15
is_arg name     type     constraints origin addr                                                    
----------------------------------------------------------------------------------------------------
false  size_arg size_t               rizin  a0
false  newfuns  Ppvoidfn             DWARF  loclist: [(0x800019aa, 14): a2,	(0x800019b8, 100): a12]
false  inc      size_t               DWARF  d15
int _Atrealloc();
            ; CALL XREF from dbg.atexit @ 0x80001a4c
            ; CALL XREF from dbg._Atexit @ 0x800033b8
/ int _Atrealloc()
|           ; var size_t size_arg @ a0
|           ; var size_t inc @ d15
|           ; var Ppvoidfn newfuns @ a2
|           0x80001994      movh.a a15, #0xd000                        ; exit.c:22
---------
arg some_t **out @ stack - 0x18
arg struct Some *gg @ stack - 0x14
arg double q @ stack - 0x10
arg char *g @ stack - 0x8
arg int a @ stack - 0x4
var size_t size_arg @ a0
var int32_t arg5 @ a4
var int32_t arg6 @ a5
var int32_t arg7 @ a6
is_arg name     type          constraints origin addr   
--------------------------------------------------------
true   out      some_t **                 DWARF  a14-24
true   gg       struct Some *             DWARF  a14-20
true   q        double                    DWARF  a14-16
true   g        char *                    DWARF  a14-8
true   a        int                       DWARF  a14-4
false  size_arg size_t                    rizin  a0
false  arg5     int32_t                   rizin  a4
false  arg6     int32_t                   rizin  a5
false  arg7     int32_t                   rizin  a6
void dbg.fn1(int a, char *g, double q, struct Some *gg, some_t **out);
            ; CALL XREF from dbg.main @ 0x8000059e
/ _Bool fn1(int a, char *g, double q, struct Some *gg, some_t **out)
|           ; var int32_t arg5 @ a4
|           ; var int32_t arg6 @ a5
|           ; var int32_t arg7 @ a6
|           ; var size_t size_arg @ a0
|           ; arg int a @ stack - 0x4
|           ; arg char *g @ stack - 0x8
|           ; arg double q @ stack - 0x10
|           ; arg struct Some *gg @ stack - 0x14
|           ; arg some_t **out @ stack - 0x18
|           0x8000041c      mov.aa a14, sp                             ; float_ex1.c:15
---------
EOF
RUN

NAME=Function arguments from DWARF (tricore-gcc)
FILE=bins/elf/float_ex1/float_ex1_tricore_gcc
CMDS=<<EOF
aaa
s sym.fn1
e asm.comments=0
pdf
EOF
EXPECT=<<EOF
/ sym.fn1(size_t nbytes, int32_t arg5, int32_t arg6, int32_t arg7);
|           ; arg size_t nbytes @ a0
|           ; arg int32_t arg5 @ a4
|           ; arg int32_t arg6 @ a5
|           ; arg int32_t arg7 @ a6
|           0x800004ce      mov.aa a14, sp
|           0x800004d0      sub.a sp, #0x18
|           0x800004d2      st.w  [a14]#-4, d4
|           0x800004d6      st.a  [a14]#-8, a4
|           0x800004da      st.d  [a14]#-0x10, e6
|           0x800004de      st.a  [a14]#-0x14, a5
|           0x800004e2      st.a  [a14]#-0x18, a6
|           0x800004e6      ld.w  d15, [a14]#-0x14
|       ,=< 0x800004ea      jz    d15, 0x800004f2
|       |   0x800004ec      ld.w  d15, [a14]#-0x18
|      ,==< 0x800004f0      jnz   d15, 0x800004f6
|      |`-> 0x800004f2      mov   d15, #0
|      |,=< 0x800004f4      j     0x8000054c
|      `--> 0x800004f6      mov   d4, #0x14
|       |   0x800004fa      call  dbg.malloc
|       |   0x800004fe      mov.aa a15, a2
|       |   0x80000500      mov.d d15, a15
|       |   0x80000502      ld.a  a15, [a14]#-0x18
|       |   0x80000506      st.w  [a15]#0, d15
|       |   0x80000508      ld.a  a15, [a14]#-0x18
|       |   0x8000050c      ld.a  a15, [a15]#0
|       |   0x8000050e      ld.w  d15, [a14]#-4
|       |   0x80000512      st.w  [a15]#0, d15
|       |   0x80000514      ld.a  a15, [a14]#-0x18
|       |   0x80000518      nop
|       |   0x8000051a      ld.w  d15, [a15]#0
|       |   0x8000051c      mov.a a15, d15
|       |   0x8000051e      add.a a15, #4
|       |   0x80000520      mov   d4, #5
|       |   0x80000522      ld.a  a5, [a14]#-8
|       |   0x80000526      mov.aa a4, a15
|       |   0x80000528      call  dbg.strncpy
|       |   0x8000052c      ld.a  a15, [a14]#-0x18
|       |   0x80000530      ld.a  a15, [a15]#0
|       |   0x80000532      ld.d  e4, [a14]#-0x10
|       |   0x80000536      call  dbg.__truncdfsf2
|       |   0x8000053a      mov   d15, d2
|       |   0x8000053c      st.w  [a15]#0xc, d15
|       |   0x8000053e      ld.a  a15, [a14]#-0x18
|       |   0x80000542      ld.a  a15, [a15]#0
|       |   0x80000544      ld.w  d15, [a14]#-0x14
|       |   0x80000548      st.w  [a15]#0x10, d15
|       |   0x8000054a      mov   d15, #1
|       `-> 0x8000054c      mov   d2, d15
\           0x8000054e      ret
EOF
RUN

NAME=Repeated function analysis - arguments and vars
FILE=bins/elf/analysis/001.make.elf.x86_64
CMDS=<<EOF
aaa
s 0x0040bbe0
afi
echo ---
afvl
pd 1
aaa
afvl
pd 1
aaa
afvl
pd 1
EOF
EXPECT=<<EOF
offset: 0x0040bbe0
name: sym.variable_expand_for_file
size: 129
is-pure: false
realsz: 120
stackframe: 0
call-convention: amd64
cyclomatic-cost: 37
cyclomatic-complexity: 3
loops: 1
bits: 64
type: sym
num-bbs: 5
edges: 6
end-bbs: 1
call-refs: 0x0040b0f0 C 0x0040b0f0 J
data-refs: 0x006331a0 0x00636050 0x006331a0 0x00636050 0x006331a0 0x00636050
code-xrefs: 0x0040cc17 C 0x00412775 C
noreturn: false
in-degree: 2
out-degree: 1
data-xrefs:
locals: 3
args: 2
var char *result @ rax
var struct variable_set_list *savev @ rbp
var floc *savef @ rbx
arg struct file *file @ rsi
arg const char *line @ rsi
---
var char *result @ rax
var struct variable_set_list *savev @ rbp
var floc *savef @ rbx
arg struct file *file @ rsi
arg const char *line @ rsi
            ; CALL XREF from dbg.expand_deps @ 0x40cc17
            ; CALL XREF from dbg.pattern_search @ 0x412775
/ char *sym.variable_expand_for_file(const char *line, struct file *file);
|           ; arg const char *line @ rsi
|           ; arg struct file *file @ rsi
|           ; var char *result @ rax
|           ; var struct variable_set_list *savev @ rbp
|           ; var floc *savef @ rbx
|           0x0040bbe0      test  rsi, rsi                             ; expand.c:458 ; file
var char *result @ rax
var struct variable_set_list *savev @ rbp
var floc *savef @ rbx
arg struct file *file @ rsi
arg const char *line @ rsi
            ; CALL XREF from dbg.expand_deps @ 0x40cc17
            ; CALL XREF from dbg.pattern_search @ 0x412775
/ char *sym.variable_expand_for_file(const char *line, struct file *file);
|           ; arg const char *line @ rsi
|           ; arg struct file *file @ rsi
|           ; var char *result @ rax
|           ; var struct variable_set_list *savev @ rbp
|           ; var floc *savef @ rbx
|           0x0040bbe0      test  rsi, rsi                             ; expand.c:458 ; file
var char *result @ rax
var struct variable_set_list *savev @ rbp
var floc *savef @ rbx
arg struct file *file @ rsi
arg const char *line @ rsi
            ; CALL XREF from dbg.expand_deps @ 0x40cc17
            ; CALL XREF from dbg.pattern_search @ 0x412775
/ char *sym.variable_expand_for_file(const char *line, struct file *file);
|           ; arg const char *line @ rsi
|           ; arg struct file *file @ rsi
|           ; var char *result @ rax
|           ; var struct variable_set_list *savev @ rbp
|           ; var floc *savef @ rbx
|           0x0040bbe0      test  rsi, rsi                             ; expand.c:458 ; file
EOF
RUN
